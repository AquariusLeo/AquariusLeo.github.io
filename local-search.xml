<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux笔记-正则表达式</title>
    <link href="/posts/789.html"/>
    <url>/posts/789.html</url>
    
    <content type="html"><![CDATA[<h1 id="正则表达式RegularExpression"><a href="#正则表达式RegularExpression" class="headerlink" title="正则表达式RegularExpression"></a>正则表达式RegularExpression</h1><p>一种字符串处理的表示方式。正则表达式可用在多种场合，常见的用法是用grep&#x2F;sed&#x2F;awk命令对文件内容进行匹配筛选，如 <code>grep -n &quot;g..d&quot; tmp.txt</code> 命令匹配文件中含有g??d形式的行，并输出行号。还可用于vim编辑器中。</p><h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><ul><li>[:alnum:]：英文大小写字符及数字（注意匹配时要写双层方括号，如 [[:alnum:]] 、[^[:digit:]]）</li><li>[:alpha:]：英文大小写字符</li><li>[:lower:]：英文小写字符，即a~z</li><li>[:upper:]：英文大写字符，即A~Z</li><li>[:digit:]：数字，即0~9</li><li>[:blank:]：空格键与Tab键</li><li>[:graph:]：除了空格符（空格键与[Tab]按键）外的其他所有按键</li><li>[:cntrl:]：控制按键，包括CR、LF、Tab、Del等</li><li>[:print:]：代表任何可以被打印出来的字符</li><li>[:punct:]：代表标点符号（punctuation symbol），亦即:”‘?!;:#$</li><li>[:space:]：任何会产生空白的字符，包括空格键、[Tab]、 CR等</li><li>[:xdigit:]：代表十六进制的数字类型，因此包括0 ~ 9、A ~ F、a ~ f 的数字与字符</li></ul><h2 id="基础RE字符"><a href="#基础RE字符" class="headerlink" title="基础RE字符"></a>基础RE字符</h2><ul><li>^word：^匹配行首</li><li>word$：$匹配行尾</li><li>.：小数点，匹配一个任意字符</li><li>*：星号，与一个RE字符搭配使用，表示前一个RE字符重复0到无穷多次（注意正则表达式与通配符不同，通配符中星号代表0到无穷多个字符，？代表任意一个字符）</li><li>\：将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\\‘ 匹配 “\“，而 ‘\(‘ 则匹配 “(“。</li><li>[list]：字符集合，匹配一个方括号中的字符，注意仅匹配一个</li><li>[n1-n2]：字符范围，匹配两个字符之间的连续字符中的一个</li><li>[^list]：反向选择，匹配不在list中的字符</li><li>{n,m}：代表前一个RE字符重复n到m次，{n}表示重复n次，{n,}表示重复至少n次</li></ul><blockquote><p>注意 { 与 } 符号在shell中有特殊含义（用于变量），所以如果在shell中grep使用正则，要加上转义符\ 。例如输入 <code>grep -n &quot;o\&#123;2\&#125;&quot; tmp.txt</code>  将在文件中匹配含有两个o的字符串。在其他地方用正则不用这样。</p></blockquote><h2 id="拓展RE字符"><a href="#拓展RE字符" class="headerlink" title="拓展RE字符"></a>拓展RE字符</h2><ul><li>拓展正则表达式要使用egrep（grep -E的别名）或sed  -r，见私房菜P376</li><li>+：加号，与一个RE字符搭配使用，表示前一个RE字符重复1到无穷多次</li><li>?：问号，与一个RE字符搭配使用，表示前一个RE字符重复0或1次</li><li>|：或，如 gd|god</li><li>( )：标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用</li><li>( )+：多个重复群组的判别</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ul><li>t[ae]st  匹配test或tast</li><li>[^g]oo  匹配oo，但前边不能是g</li><li>[^[:lower:]]oo  匹配oo，前边不能是小写字母</li><li>[0-9]或[[:digit:]]  匹配数字0-9</li><li>^the   匹配位于行首的the</li><li>^[^[:alpha:]]   匹配行首非英文字母</li><li>\.$   匹配以小数点结尾的行</li><li>^$   匹配空白行</li><li>^#   匹配以#开头的行</li><li>a*  匹配0到无穷多个字符a</li><li>aa*  匹配1到无穷多个字符a，以此类推</li><li>.*   匹配0到无穷多个任意字符</li><li>go{2,5}g   匹配两个g中间出现2~5次o</li></ul><blockquote><p>例：<code>grep -n &quot;go\&#123;2,5\&#125;g&quot; tmp.txt</code></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux笔记-Linux快捷键</title>
    <link href="/posts/9abd.html"/>
    <url>/posts/9abd.html</url>
    
    <content type="html"><![CDATA[<h1 id="Linux快捷键"><a href="#Linux快捷键" class="headerlink" title="Linux快捷键"></a>Linux快捷键</h1><ul><li>Ctrl+Alt+F1~F6    切换终端</li><li>Tab    自动补全</li><li>移动光标<ul><li>Ctrl+A    移动光标到开头</li><li>Ctrl+B    移动光标到结尾</li><li>Ctrl+F    光标往后移动一个字符</li><li>Ctrl+B    光标往前移动一个字符</li></ul></li><li>剪切字符<ul><li>Ctrl+K    剪切光标到行尾的字符</li><li>Ctrl+U    剪切光标到行首的字符</li><li>Ctrl+Y    将剪切的字符进行粘贴</li></ul></li><li>复制粘贴<ul><li>Ctrl+Ins    复制</li><li>Shift+Ins    粘贴</li></ul></li><li>Ctrl+C    中断当前命令</li><li>Ctrl+U    删除已输入的命令串</li><li>Ctrl+D    键盘输入结束（End Of File）或离开命令行模式（相当于输入exit）</li><li>Ctrl+R    搜索命令行使用过的历史命令记录</li><li>Ctrl+L    清屏</li><li>Ctrl+Z    暂停</li><li>Ctrl+S    锁屏</li><li>Ctrl+Q    解除锁屏</li><li>Esc+.    获取上一条命令的最后部分</li><li>\ + Enter    在下一行继续输入命令</li><li>Shift+PageUp&#x2F;PageDown    命令行模式下向前&#x2F;后翻页</li><li>!!    执行上一条命令</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CurveZMQ协议简介</title>
    <link href="/posts/f088.html"/>
    <url>/posts/f088.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要介绍ZeroMQ的安全模型——CurveZMQ 协议，简单描述其流程。将个人理解记录为笔记。</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ZeroMQ的安全模型基于 CurveZMQ 协议，该协议基于 Curve25519 椭圆曲线加密算法，使用公钥加密和对称密钥加密相结合的方式。CurveZMQ 提供了端到端的加密通信，确保消息在传输过程中不会被窃听或篡改。同时，CurveZMQ 还实现了一个基于公钥&#x2F;私钥对的认证机制，以验证通信节点的身份。</p><p>CurveZMQ 可以解决重放攻击、放大攻击、MIM攻击、密钥盗窃、客户端识别和各种拒绝服务攻击。</p><p>CurveZMQ 的安全性证明和详细过程参考：<a href="https://rfc.zeromq.org/spec/26/">https://rfc.zeromq.org/spec/26/</a></p><p>其他参考网站：</p><p><a href="https://libzmq.readthedocs.io/en/latest/zmq_curve.html">https://libzmq.readthedocs.io/en/latest/zmq_curve.html</a></p><p><a href="https://blog.csdn.net/weixin_45661808/article/details/145155486">https://blog.csdn.net/weixin_45661808/article/details/145155486</a></p><p><a href="https://developer.aliyun.com/article/1463834">https://developer.aliyun.com/article/1463834</a></p><h2 id="CurveZMQ-加密通信过程"><a href="#CurveZMQ-加密通信过程" class="headerlink" title="CurveZMQ 加密通信过程"></a>CurveZMQ 加密通信过程</h2><h3 id="1-密钥对生成"><a href="#1-密钥对生成" class="headerlink" title="1. 密钥对生成"></a>1. 密钥对生成</h3><p>每个使用 CurveZMQ 的通信端（客户端和服务端）都需要生成一个公钥和私钥的密钥对。这个密钥对由以下两部分组成：</p><ol><li>私钥（Secret Key）：此密钥只能由持有者知道，用于生成共享密钥。</li><li>公钥（Public Key）：这个密钥可以公开，用来交换给对方。</li></ol><p>密钥对生成过程是通过 zmq_curve_keypair() 函数完成的（Curve25519 算法）。</p><p>客户端生成长期的<u>客户端密钥对</u>：<strong>客户端公钥</strong>、<strong>客户端私钥</strong>。</p><p>服务端生成长期的<u>服务端密钥对</u>：<strong>服务端公钥</strong>、<strong>服务端私钥</strong>。</p><h3 id="2-公钥交换"><a href="#2-公钥交换" class="headerlink" title="2. 公钥交换"></a>2. 公钥交换</h3><ul><li>在 CurveZMQ 协议中，公钥用于验证身份并生成共享密钥。因此，通信双方必须交换各自的公钥。</li><li>交换公钥的方式可以是通过配置或预先共享的方式进行。也可以在一个安全的渠道（如 HTTPS）中进行。</li><li>交换完成后，客户端知道服务端长期公钥，服务端知道客户端长期公钥</li></ul><h3 id="3-CurveZMQ握手过程"><a href="#3-CurveZMQ握手过程" class="headerlink" title="3. CurveZMQ握手过程"></a>3. CurveZMQ握手过程</h3><p>握手过程的官方详细介绍见：<a href="https://rfc.zeromq.org/spec/26/">https://rfc.zeromq.org/spec/26/</a></p><ol><li>客户端发起连接，首先生成一个临时密钥对。向服务端发出一个<strong>HELLO命令</strong>，其中包含客户端临时公钥。</li><li>当服务器收到HELLO时，它会生成自己的临时密钥对，并将这个 服务器临时私钥 编码为“cookie”（cookie&#x3D;客户端临时公钥+服务器临时私钥），作为<strong>WELCOME命令</strong>发送回客户端。WELCOME命令还包含服务器临时公钥，加密后只有客户端可以读取。然后丢弃此临时密钥对。</li><li>客户端收到WELCOME命令，解密得到服务器临时公钥和“cookie”。然后客户端发回一个<strong>INITIATE命令</strong>，其中包含“cookie”、经过加密（使用服务器长期公钥）的客户端永久公钥，只有服务端能够读取到。</li><li>服务器读取INITIATE命令，解密后可读取客户端永久公钥，然后可以对客户端身份进行验证。然后还可以读取cookie，获取客户端临时公钥、服务器临时公私钥对。随即服务器回复<strong>READY命令</strong>，表示握手成功。</li><li>至此，通过安全的方式，双方各自拥有了自己的临时私钥、对方的临时公钥。利用 Curve25519 椭圆曲线算法的特性，双方可以独立地计算出相同的<strong>共享密钥</strong> (Shared Secret)，该密钥将作为本次会话的<strong>会话密钥</strong> (Session Key)。</li></ol><p><img src="https://wbenergy.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDExNjZjZThiZTQ4OTgwZmNkNWE3MDNkY2FhMTdhYjlfaDU2N1k5OXd1a0NuS29qdE9LdGlmclE0aEVUTUYxbjNfVG9rZW46Q3JLdGJVek1Xb1BUdFl4azd3aWNVRmRobnpkXzE3NTcxNzQ5Mzc6MTc1NzE3ODUzN19WNA" alt="img"></p><h3 id="4-加密消息传输阶段"><a href="#4-加密消息传输阶段" class="headerlink" title="4. 加密消息传输阶段"></a>4. 加密消息传输阶段</h3><p> ZeroMQ 底层使用之前协商出的会话密钥、随机数和 Poly1305 认证加密算法对消息进行加密和认证。</p><h2 id="大模型对于CurveZMQ的介绍"><a href="#大模型对于CurveZMQ的介绍" class="headerlink" title="大模型对于CurveZMQ的介绍"></a>大模型对于CurveZMQ的介绍</h2><p>下面提供两份Deepseek对于CurveZMQ的介绍，结合阅读有助于理解：</p><h4 id="文件1："><a href="#文件1：" class="headerlink" title="文件1："></a>文件1：</h4><div class="row">    <embed src="/pdf/基于CurveZMQ的加密通信方案设计-DeepSeek.pdf" width="100%" height="550" type="application/pdf"></div><h4 id="文件2："><a href="#文件2：" class="headerlink" title="文件2："></a>文件2：</h4><div class="row">    <embed src="/pdf/CurveZMQ密钥生成与安全通信详解-DeepSeek.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ZMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学术论文分享 - Hierarchical Reinforcement Learning-based Mobility-aware Content Caching and Delivery Policy for Vehicle Networks</title>
    <link href="/posts/3fb7.html"/>
    <url>/posts/3fb7.html</url>
    
    <content type="html"><![CDATA[<p>在此分享个人在2022年ICA3PP（International Conference on Algorithms and Architectures for Parallel Processing）会议发表的一篇论文。😏</p><p><strong>欢迎引用</strong>：以下为bib格式：🫡</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs routeros">@InProceedings&#123;10.1007/978-3-031-22677-9_3,<br><span class="hljs-attribute">author</span>=<span class="hljs-string">&quot;Zhang, Le</span><br><span class="hljs-string">and Lai, Yongxuan</span><br><span class="hljs-string">and Yang, Fan&quot;</span>,<br><span class="hljs-attribute">editor</span>=<span class="hljs-string">&quot;Meng, Weizhi</span><br><span class="hljs-string">and Lu, Rongxing</span><br><span class="hljs-string">and Min, Geyong</span><br><span class="hljs-string">and Vaidya, Jaideep&quot;</span>,<br><span class="hljs-attribute">title</span>=<span class="hljs-string">&quot;Hierarchical Reinforcement Learning-Based Mobility-Aware Content Caching and Delivery Policy for Vehicle Networks&quot;</span>,<br><span class="hljs-attribute">booktitle</span>=<span class="hljs-string">&quot;Algorithms and Architectures for Parallel Processing&quot;</span>,<br><span class="hljs-attribute">year</span>=<span class="hljs-string">&quot;2023&quot;</span>,<br><span class="hljs-attribute">publisher</span>=<span class="hljs-string">&quot;Springer Nature Switzerland&quot;</span>,<br><span class="hljs-attribute">address</span>=<span class="hljs-string">&quot;Cham&quot;</span>,<br><span class="hljs-attribute">pages</span>=<span class="hljs-string">&quot;43--62&quot;</span>,<br><span class="hljs-attribute">isbn</span>=<span class="hljs-string">&quot;978-3-031-22677-9&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关键词</strong>：mobile edge computing ·vehicle network ·content caching and delivery ·hierarchical reinforcement learning ·deep deterministic policy gradient</p><p><strong>论文发表链接</strong>：<a href="https://link.springer.com/chapter/10.1007/978-3-031-22677-9_3">click here</a></p><div class="row">    <embed src="/pdf/HDRLCaching-论文全文.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>边缘计算</tag>
      
      <tag>车联网</tag>
      
      <tag>强化学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题总结</title>
    <link href="/posts/d4a8.html"/>
    <url>/posts/d4a8.html</url>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组理论基础"><a href="#数组理论基础" class="headerlink" title="数组理论基础"></a>数组理论基础</h3><p>数组是存放在<strong>连续内存空间</strong>上的<strong>相同类型数据</strong>的集合。在删除或者增添元素的时候，就难免要<strong>移动其他元素</strong>的地址。在C++中二维数组在地址空间上是连续的。<br>复习时记得回看C++数组以及<a href="http://c.biancheng.net/view/6749.html">vector的相关函数</a>。</p><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>在<strong>有序数组中查找元素</strong>，并且<strong>没有重复元素</strong>。使用left、right两个指针。需要清楚区间的定义，是左闭右闭还是左闭右开（建议左闭右闭）。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则。时间复杂度为O(logn)</p><blockquote><ol start="704"><li><a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html">二分查找</a></li></ol></blockquote><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>（快慢指针法）：通过<strong>两个指针</strong>在一个for循环下完成两个for循环的工作，来降低时间复杂度。要搞清楚每个指针在什么条件下移动，什么条件下不移动。</p><blockquote><ol start="27"><li>移除元素，977.有序数组的平方，844.有序数组的平方</li></ol></blockquote><h3 id="滑动窗口法"><a href="#滑动窗口法" class="headerlink" title="滑动窗口法"></a>滑动窗口法</h3><p>也属于双指针法，所谓滑动窗口，就是不断的调节<strong>子序列</strong>的起始位置和终止位置，从而得出我们要想的结果。首先想起始位置和终止位置移动会<strong>分别带来什么影响</strong>，然后要确定<strong>窗口内是什么</strong>，<strong>窗口的起始位置的移动规则</strong>，<strong>窗口的结束位置的移动规则</strong>。</p><blockquote><p>209.长度最小的子数组，<a href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮</a>，<a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> s, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> result = INT32_MAX;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口数值之和</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口起始位置</span><br>    <span class="hljs-type">int</span> subLength = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口的长度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) &#123;<br>        sum += nums[j];<br>        <span class="hljs-comment">// 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件</span><br>        <span class="hljs-keyword">while</span> (sum &gt;= s) &#123;<br>            subLength = (j - i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 取子序列的长度</span><br>            result = result &lt; subLength ? result : subLength;<br>            sum -= nums[i];<br>            i++;<br>            <span class="hljs-comment">// 起始位置的移动规则：sum&gt;=s，需要缩小滑动窗口之和，寻找是否存在j结尾的长度更小的子数组</span><br>        &#125;<br>        <span class="hljs-comment">// 结束位置的移动规则：sum&lt;s，需要增大滑动窗口之和，j后移  (while循环结束后sum就会小于s)</span><br>    &#125;<br>    <span class="hljs-comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span><br>    <span class="hljs-keyword">return</span> result == INT32_MAX ? <span class="hljs-number">0</span> : result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="模拟行为"><a href="#模拟行为" class="headerlink" title="模拟行为"></a>模拟行为</h3><p><strong>循环不变量</strong>原则，是写程序中的重要原则。确定模拟过程中遵循的规则。</p><blockquote><p>59.螺旋矩阵II，54.螺旋矩阵</p></blockquote><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="链表理论基础"><a href="#链表理论基础" class="headerlink" title="链表理论基础"></a>链表理论基础</h3><p>链表的节点在内存中是分散存储的，每一个节点由两部分组成，一个是<strong>数据域</strong>一个是<strong>指针域</strong>（存放指向下一个节点的指针），最后一个节点的指针域指向null。<strong>双链表</strong>：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。<strong>循环链表</strong>，顾名思义，就是链表首尾相连。<br>链表的操作：</p><ul><li><strong>删除节点</strong>：定位到删除节点的前一个节点，保存-&gt;next为tmp，将-&gt;next域设为-&gt;next-&gt;next，delete tmp。</li><li><strong>添加节点</strong>：定位到添加位置的前一个位置p，new一个新节点，next域设为p-&gt;next，p-&gt;next设为新节点地址。</li></ul><p>技巧：多<strong>画图模拟</strong>过程，考虑<strong>极端情况</strong>，包括：链表长为0，长为1，头结点位置，尾结点位置等</p><h3 id="虚节点-哨兵节点"><a href="#虚节点-哨兵节点" class="headerlink" title="虚节点&#x2F;哨兵节点"></a>虚节点&#x2F;哨兵节点</h3><p>使用一个头结点之前虚节点（dummyNode）可以有效简化删除&#x2F;添加节点时需要考虑头部位置的情况。</p><blockquote><p>203.移除链表元素，<strong>707</strong>.设计链表</p></blockquote><h3 id="双指针法-1"><a href="#双指针法-1" class="headerlink" title="双指针法"></a>双指针法</h3><p>常见的方式有prev与cur两个相差一步的指针（206、24）、slow与fast两个相差若干步的指针（19、面试02.07）、slow每次走一步fast每次走两步（142）</p><blockquote><p>206.反转链表、24.两两交换链表中的节点</p><p>19.删除链表的倒数第N个节点、面试题 02.07. 链表相交</p><p>142.环形链表II</p></blockquote><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><p>一般来说哈希表都是用来<strong>快速判断一个元素是否出现集合里</strong>。对于哈希表，要知道<strong>哈希函数</strong>和<strong>哈希碰撞</strong>在哈希表中的作用。哈希函数是把传入的key映射到哈希表的索引上。哈希碰撞处理有多个key映射到相同索引上时的情景，处理碰撞的普遍方式是拉链法和线性探测法。</p><p>接下来是常见的三种哈希结构：</p><ul><li>数组</li><li>set（集合）</li><li>map（映射）</li></ul><p>集合set是一组同类型数据的集合，unordered_set类似于python中的set。映射map是一组（key，value）键值对（pair类型）的集合，unordered_map类似于python的dict、java的hashmap。在C++中，set 和 map 分别提供以下三种数据结构：</p><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值能否重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>键值能否重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>以上六种常用的是unordered_set，unordered_map。具体接口可查询：<a href="http://c.biancheng.net/view/7250.html">unordered_set</a>、<a href="http://c.biancheng.net/view/7231.html">unordered_map</a></p><h3 id="数组作为哈希表"><a href="#数组作为哈希表" class="headerlink" title="数组作为哈希表"></a>数组作为哈希表</h3><p>数组本身也是一种哈希表或者说map。在一些涉及到字母等的题目中，哈希表元素个数有限（如26个字母），就可以用数组作为简便的哈希表，使用map的空间消耗要比数组大一些，因为map要维护红黑树或者符号表，而且还要做哈希函数的运算，所以数组更加简单直接有效。</p><blockquote><p>242.有效的字母异位词、383. 赎金信</p></blockquote><h3 id="set作为哈希表"><a href="#set作为哈希表" class="headerlink" title="set作为哈希表"></a>set作为哈希表</h3><p>在一些需要以较低的时间复杂度判断元素是否在一个集合中，或者是否重复出现过，就可以用unordered_set做容器。</p><blockquote><ol start="349"><li>两个数组的交集、202. 快乐数</li></ol></blockquote><h3 id="map作为哈希表"><a href="#map作为哈希表" class="headerlink" title="map作为哈希表"></a>map作为哈希表</h3><p>map是一种&lt;key, value&gt;的结构，在一些合适的题中很有用，如两数之和（1）、四数相加（454）。但一些题中哈希法太过复杂，反而适合用双指针法，如<strong>三数之和（15）、四数之和（18）</strong>，这两题值得重点关注。</p><blockquote><ol><li>两数之和、454.四数相加II</li></ol></blockquote><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>C++字符串：<a href="http://c.biancheng.net/view/2236.html">库函数</a></p><h3 id="双指针法-2"><a href="#双指针法-2" class="headerlink" title="双指针法"></a>双指针法</h3><p>一快一慢两个指针或者一头一尾。<br>很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</p><blockquote><p>344.反转字符串、剑指Offer 05.替换空格、151.翻转字符串里的单词</p></blockquote><h3 id="反转系列"><a href="#反转系列" class="headerlink" title="反转系列"></a>反转系列</h3><p>基本的字符串反转使用一前一后两个指针，时间复杂度是O(n)。一些题目用到了先整体反转再局部反转（151）和先局部反转再整体反转（剑指Offer58-II.左旋转字符串）的技巧。</p><blockquote><p>151.翻转字符串里的单词、剑指Offer58-II.左旋转字符串</p></blockquote><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>KMP算法用于在O(n+m)的时间复杂度内在文本串中匹配模式串。核心思想是当字符串不匹配时，利用已经匹配过的失败信息，跳过一些不可能的字符串匹配。需要掌握的要点是：</p><ul><li>前缀表&#x2F;next数组：作用是记录了模式串与文本串不匹配的时候，模式串应该从哪里开始重新匹配。<strong>next[i]的含义</strong>是在模式串中，下标 i 之前（包括i）的子串中，最长的相同前缀、后缀的长度</li><li>KMP有两种实现方法，包括next数组与前缀表相同、前缀表统一每位减一，两者等价，下面介绍相同的情况</li><li>参考辅助理解KMP：<a href="https://www.zhihu.com/question/21923021">理解KMP</a></li><li>KMP可以解决两种经典问题：模式串匹配问题（28. 实现 strStr()）、重复子串问题（459.重复的子字符串）</li><li>KMP包含两部分：快速建立前缀表和利用前缀表进行匹配。</li></ul><h4 id="快速建立前缀表："><a href="#快速建立前缀表：" class="headerlink" title="快速建立前缀表："></a>快速建立前缀表：</h4><p>思路：采用<strong>递推</strong>的方式求next数组。假设next[ 0~ i-1 ]已知的情况下，求next[ i ]的值。</p><ol><li>初始化：j指向前缀末尾位置，i指向后缀末尾位置，j&#x3D;0；</li><li>处理前后缀不相同的情况，j不断根据next[j-1]回退，直至s[i]&#x3D;s[j]或者j&#x3D;0；</li><li>处理前后缀相同的情况，s[i]&#x3D;s[j]，前后缀就可以扩展一位，j++，再赋给next[i]；</li><li>j 赋值给next[i]</li></ol><h4 id="利用前缀表进行匹配："><a href="#利用前缀表进行匹配：" class="headerlink" title="利用前缀表进行匹配："></a>利用前缀表进行匹配：</h4><ol><li>定义两个下标j 指向模式串起始位置，i指向文本串起始位置</li><li>for循环中i从0开始遍历文本串，如果在j位置匹配失败，j根据前缀表next[j-1]不断回溯，直至匹配成功</li><li>如果匹配成功，i、j后移一位（j+1，i在for循环中+1）</li><li>j移动到超出模式串的末尾，表示模式串匹配成功，返回i-模式串长度+1</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span></span>&#123;  <span class="hljs-comment">//next数组与前缀表相同，不减一的做法</span><br>        <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;  <span class="hljs-comment">// 1、初始化：j指向前缀末尾位置，i指向后缀末尾位置</span><br>        next[<span class="hljs-number">0</span>]=j;  <span class="hljs-comment">// next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;s.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-comment">// 每次循环开始时，j的值就是next[i-1]</span><br>            <span class="hljs-keyword">while</span> (j&gt;<span class="hljs-number">0</span> &amp;&amp; s[i]!=s[j])&#123;  <span class="hljs-comment">// 2、处理前后缀不相同的情况，j不断根据next[j-1]回退，直至s[i]=s[j]或者j=0</span><br>                j=next[j<span class="hljs-number">-1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (s[i]==s[j])&#123;  <span class="hljs-comment">// 3、处理前后缀相同的情况，s[i]=s[j]，前后缀就可以扩展一位，j++（即next[i-1]+1），再赋给next[i]</span><br>                j++;<br>            &#125;<br>            next[i]=j;  <span class="hljs-comment">// 4、更新next[i]</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (needle.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">// 处理特殊情况：模式串长度为0</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> next[needle.<span class="hljs-built_in">size</span>()];<br>        <span class="hljs-built_in">getNext</span>(next, needle);  <span class="hljs-comment">// 获得next数组，next[i]含义是下标i之前（包括i）的子串中，最长的相同前缀后缀的长度</span><br>        <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;haystack.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">while</span> (j&gt;<span class="hljs-number">0</span> &amp;&amp; haystack[i]!=needle[j])&#123;<br>                j=next[j<span class="hljs-number">-1</span>];  <span class="hljs-comment">// 如果在j位置匹配失败，j根据前缀表next[j-1]不断回溯，直至匹配成功</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (haystack[i]==needle[j])&#123;<br>                j++;  <span class="hljs-comment">// 匹配成功，j前移一位</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (j==needle.<span class="hljs-built_in">size</span>())&#123;<br>                <span class="hljs-keyword">return</span> i-needle.<span class="hljs-built_in">size</span>()<span class="hljs-number">+1</span>;  <span class="hljs-comment">// j移动到超出模式串的末尾，表示模式串匹配成功，返回i-模式串长度+1</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="双指针法-3"><a href="#双指针法-3" class="headerlink" title="双指针法"></a>双指针法</h2><p>双指针法广泛应用于<strong>数组、链表、字符串</strong>的题目中。</p><h3 id="fast-slow"><a href="#fast-slow" class="headerlink" title="fast &amp; slow"></a>fast &amp; slow</h3><p>定义一快一慢两个指针，有以下几种思路：</p><ul><li><p>fast和slow两个指针根据一些条件移动，复制元素，来模拟数组元素的移动</p><blockquote><ol start="27"><li>移除元素、剑指Offer 05.替换空格、151.翻转字符串里的单词</li></ol></blockquote></li><li><p>扩充数组至所需大小后，fast&amp;slow指针从后向前移动</p><blockquote><p>剑指Offer 05.替换空格</p></blockquote></li><li><p>fast指针先走几步，fast与slow相差n步，然后两个指针再同步移动</p><blockquote><p>19.删除链表的倒数第N个节点、面试题 02.07. 链表相交</p></blockquote></li><li><p>fast每次走两步，slow每次走一步，两者在环中相遇</p><blockquote><p>142.环形链表II</p></blockquote></li></ul><h3 id="left-right"><a href="#left-right" class="headerlink" title="left &amp; right"></a>left &amp; right</h3><p>定义一头一尾两个指针，向中间移动</p><blockquote><p>344.反转字符串、15.三数之和、18.四数之和</p></blockquote><h3 id="pre-cur链表类"><a href="#pre-cur链表类" class="headerlink" title="pre &amp; cur链表类"></a>pre &amp; cur链表类</h3><p>在链表中常定义pre &amp; cur两个指针，来进行链表next的修改</p><blockquote><p>206.反转链表、24.两两交换链表中的节点</p></blockquote><h3 id="反转类"><a href="#反转类" class="headerlink" title="反转类"></a>反转类</h3><p>字符串的反转，不仅可能用到fast &amp; slow，也可能用到先整体反转再局部反转，或先局部反转再整体反转的方法。</p><blockquote><p>344.反转字符串、151.翻转字符串里的单词、剑指Offer58-II.左旋转字符串</p></blockquote><h3 id="N数之和"><a href="#N数之和" class="headerlink" title="N数之和"></a>N数之和</h3><p>先将数组排序，遍历前N-2个数，最后两个数设置left &amp; right两个指针向中间移动，若和小了left向右，和大了right向左。</p><blockquote><p><strong>15.三数之和、18.四数之和</strong></p></blockquote><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>栈是<strong>先进后出</strong>的数据结构，队列是<strong>先进先出</strong>的数据结构。</p><p>stack、queue、priority_queue在STL中属于容器适配器，包装了STL中的基础容器类，本质上还是容器。stack、queue使用的默认基础容器是deque，priority_queue使用的默认基础容器是vector。可以自定义底层容器。</p><p>栈和队列不允许有遍历行为，不提供迭代器。</p><p><strong>优先级队列</strong>与队列相似，只能一端进一端出，但只能访问队头的元素。当元素进入队列后，会进行排序，保证队列按照预定义的优先级排列，默认使用std::less<T>进行从大到小排列。底层采用<strong>vector形式的大顶堆&#x2F;小顶堆</strong>。</p><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 不包含任何元素的 stack 适配器，并采用默认的 deque 基础容器</span><br>stack&lt;<span class="hljs-type">int</span>&gt; values;<br><span class="hljs-comment">// 使用list为基础容器的stack</span><br>stack&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; values;<br><span class="hljs-comment">// 用一个基础容器来初始化 stack 适配器，只要该容器的类型和 stack 底层使用的基础容器类型相同即可</span><br>list&lt;<span class="hljs-type">int</span>&gt; values&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>stack&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">my_stack</span>(values);<br><span class="hljs-comment">// 用一个 stack 适配器来初始化另一个 stack 适配器，只要它们存储的元素类型以及底层采用的基础容器类型相同即可</span><br>stack&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; my_stack=my_stack1;<br><span class="hljs-comment">//stack&lt;int, list&lt;int&gt;&gt; my_stack(my_stack1);</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>empty()</td><td>当 stack 栈中没有元素时，该成员函数返回 true；反之，返回 false。</td></tr><tr><td>size()</td><td>返回 stack 栈中存储元素的个数。</td></tr><tr><td>top()</td><td>返回一个栈顶元素的引用，类型为 T&amp;。如果栈为空，程序会报错。</td></tr><tr><td>push(const T&amp; val)</td><td>先复制 val，再将 val 副本压入栈顶。这是通过调用底层容器的 push_back() 函数完成的。</td></tr><tr><td>pop()</td><td>弹出栈顶元素。</td></tr></tbody></table><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 不包含任何元素的 queue 适配器，并采用默认的 deque 基础容器</span><br>queue&lt;<span class="hljs-type">int</span>&gt; values;<br><span class="hljs-comment">// 使用list为基础容器的queue</span><br>queue&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; values;<br><span class="hljs-comment">// 用一个基础容器来初始化 queue 适配器，只要该容器的类型和 queue 底层使用的基础容器类型相同即可</span><br>list&lt;<span class="hljs-type">int</span>&gt; values&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>queue&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">my_queue</span>(values);<br><span class="hljs-comment">// 用一个 queue 适配器来初始化另一个 queue 适配器，只要它们存储的元素类型以及底层采用的基础容器类型相同即可</span><br>queue&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; my_queue=my_queue1;<br><span class="hljs-comment">//queue&lt;int, list&lt;int&gt;&gt; my_queue(my_queue1);</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>empty()</td><td>如果 queue 中没有元素的话，返回 true。</td></tr><tr><td>size()</td><td>返回 queue 中元素的个数。</td></tr><tr><td>front()</td><td>返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</td></tr><tr><td>back()</td><td>返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</td></tr><tr><td>push(const T&amp; obj)</td><td>在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。</td></tr><tr><td>pop()</td><td>删除 queue 中的第一个元素。</td></tr></tbody></table><h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 空的 priority_queue 容器，底层默认 vector 容器，排序方式默认 std::less&lt;T&gt; 方法，即大顶堆</span><br>priority_queue&lt;<span class="hljs-type">int</span>&gt; values;<br><span class="hljs-comment">//使用普通数组初始化</span><br><span class="hljs-type">int</span> values[]&#123;<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>&#125;;<br><span class="hljs-function">priority_queue&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">copy_values</span><span class="hljs-params">(values,values<span class="hljs-number">+4</span>)</span></span>; <span class="hljs-comment">//&#123;4,2,3,1&#125;</span><br><span class="hljs-comment">//使用序列式容器初始化</span><br>array&lt;<span class="hljs-type">int</span>, 4&gt;values&#123; <span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span> &#125;;<br><span class="hljs-function">priority_queue&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">copy_values</span><span class="hljs-params">(values.begin(),values.end())</span></span>;<span class="hljs-comment">//&#123;4,2,3,1&#125;</span><br><span class="hljs-comment">// 手动指定 priority_queue 使用的底层容器以及排序规则</span><br><span class="hljs-type">int</span> values[]&#123; <span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span> &#125;;<br>priority_queue&lt;<span class="hljs-type">int</span>, deque&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">copy_values</span>(values, values<span class="hljs-number">+4</span>); <span class="hljs-comment">// 小顶堆</span><br><span class="hljs-comment">// 用函数对象类自定义排序规则</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cmp</span> &#123;  <span class="hljs-comment">// 函数对象类</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; left, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; right)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> left.second &gt; right.second;  <span class="hljs-comment">// 小顶堆，从小到大排序</span><br>    &#125;<br>&#125;;<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, Cmp&gt; pri_que;<br></code></pre></td></tr></table></figure><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>empty()</td><td>如果 priority_queue 为空的话，返回 true；反之，返回 false。</td></tr><tr><td>size()</td><td>返回 priority_queue 中存储元素的个数。</td></tr><tr><td>top()</td><td>返回 priority_queue 中第一个元素的引用形式。</td></tr><tr><td>push(const T&amp; obj)</td><td>根据既定的排序规则，将元素 obj 的副本存储到 priority_queue 中适当的位置。</td></tr><tr><td>pop()</td><td>移除 priority_queue 容器适配器中第一个元素。</td></tr></tbody></table><h3 id="栈经典题目"><a href="#栈经典题目" class="headerlink" title="栈经典题目"></a>栈经典题目</h3><p>栈在计算机系统、编译器中应用广泛，如：</p><blockquote><ol start="20"><li>有效的括号、71. 简化路径、1047. 删除字符串中的所有相邻重复项、150. 逆波兰表达式求值</li></ol></blockquote><h3 id="队列经典题目"><a href="#队列经典题目" class="headerlink" title="队列经典题目"></a>队列经典题目</h3><ul><li><p><strong>单调队列</strong></p><p>在  239. 滑动窗口最大值  中，需要这样一种队列：队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队里里的元素数值是由大到小的。这就是<strong>单调队列</strong>，即单调递减或单调递增的队列。设计单调队列的时候，pop和push操作要保持如下规则：</p><p>pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作<br>push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止。</p><blockquote><ol start="239"><li>滑动窗口最大值</li></ol></blockquote></li><li><p><strong>优先级队列</strong></p><p>优先级队列就是一个披着队列外衣的堆，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。是大顶堆&#x2F;小顶堆的现成的实现。</p><blockquote><p>347.前 K 个高频元素</p></blockquote></li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="理论基础-1"><a href="#理论基础-1" class="headerlink" title="理论基础"></a>理论基础</h3><ul><li><p><strong>满二叉树</strong>：一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，深度为k，有2^k-1个节点</p><img src="https://img-blog.csdnimg.cn/20200806185805576.png" alt="img" style="zoom:25%;" /></li><li><p><strong>完全二叉树</strong>：除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置</p><img src="https://img-blog.csdnimg.cn/20200920221638903.png" alt="img" style="zoom: 33%;" /></li><li><p><strong>二叉搜索树</strong>是一个有序树，</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul></li></ul><img src="https://img-blog.csdnimg.cn/20200806190304693.png" alt="img" style="zoom: 50%;" /><ul><li><p><strong>平衡二叉搜索树</strong>：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><img src="https://img-blog.csdnimg.cn/20200806190511967.png" alt="img" style="zoom:50%;" /><p>红黑树也是一种平衡二叉树，性能优于平衡二叉树。C++中map、set、multimap，multiset的底层实现都是红黑树。</p></li><li><p><strong>存储方式</strong>：二叉树可以链式存储，也可以顺序存储。顺序存储就是用数组来存储二叉树，如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。链式存储则是通过指针把分布在散落在各个地址的节点串联一起。</p></li><li><p><strong>遍历方式</strong>：</p><ul><li>深度优先遍历（DFS）<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历（BFS）<ul><li>层次遍历（迭代法）</li></ul></li></ul></li></ul><p>其中深度优先的迭代法是用栈的数据结构实现，层次遍历的迭代法是用队列的数据结构实现。</p><h3 id="递归遍历（DFS）"><a href="#递归遍历（DFS）" class="headerlink" title="递归遍历（DFS）"></a>递归遍历（DFS）</h3><p>写递归算法的三要素：</p><ul><li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 前序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右   // 前序遍历，中序和后序修改三句话顺序即可</span><br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-built_in">traversal</span>(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="迭代遍历（DFS）"><a href="#迭代遍历（DFS）" class="headerlink" title="迭代遍历（DFS）"></a>迭代遍历（DFS）</h3><p>使用<strong>栈的结构</strong>来模拟递归的过程，时间复杂度与递归相同，但空间更小。有两种实现方式，第一种实现三种遍历不一致，不好记；第二种实现加入空指针作为待处理的标记，三种遍历写法统一，更好记。记住一种即可。</p><p>注意由于栈的“先进后出”，编写代码时顺序要与前序的“中左右”相反，中&#x2F;后序同理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 前序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root!=<span class="hljs-literal">nullptr</span>) st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>())&#123;<br>            TreeNode* node=st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node!=<span class="hljs-literal">nullptr</span>)&#123;  <span class="hljs-comment">// 非空指针，表示该节点需要访问但不处理</span><br>                st.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 弹出该节点，接下来访问子节点，但不处理（将该节点加入result）该节点</span><br>                <span class="hljs-keyword">if</span> (node-&gt;right!=<span class="hljs-literal">nullptr</span>) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 右</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left!=<span class="hljs-literal">nullptr</span>) st.<span class="hljs-built_in">push</span>(node-&gt;left);  <span class="hljs-comment">// 左，注意这里是用栈的结构，顺序与前序遍历的“中左右”相反，应为“右左中”</span><br>                st.<span class="hljs-built_in">push</span>(node);  <span class="hljs-comment">// 中，  再次将该节点压入栈中</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">nullptr</span>);  <span class="hljs-comment">// 并加上一个空指针表示待处理</span><br>                <span class="hljs-comment">// 中序和后序修改上面四句话的顺序</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 遇到空指针，表示栈中的下一个节点是待处理的</span><br>                st.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 先弹出空指针</span><br>                node=st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(node-&gt;val);  <span class="hljs-comment">// 处理该节点，加入result</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="层序遍历（BFS）"><a href="#层序遍历（BFS）" class="headerlink" title="层序遍历（BFS）"></a>层序遍历（BFS）</h3><p>从左到右一层一层的去遍历二叉树，借助“先进先出”的<strong>队列的数据结构</strong>实现迭代式的写法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>            <span class="hljs-comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size()是不断变化的</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;  <span class="hljs-comment">// 当不需要输出二维的vector时可以省去size变量和for循环</span><br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                vec.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            result.<span class="hljs-built_in">push_back</span>(vec);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><p>二叉树类的题目通常有两种思路：<strong>递归法</strong>和<strong>迭代法</strong>。</p><ul><li>对于递归法，首先要搞清楚递归函数所要实现的功能是什么，然后按照递归算法的三要素来思考。这类做法通常是使用前&#x2F;中&#x2F;后序遍历三者之一</li><li>对于迭代法，通常是采用队列的数据结构，并采用层序遍历的方式（也有例外，如101. 对称二叉树使用迭代法，但不是层序遍历），要记住层序遍历的模板</li></ul><blockquote><p>226.翻转二叉树、101. 对称二叉树、104.二叉树的最大深度、111.二叉树的最小深度、222.完全二叉树的节点个数、110.平衡二叉树</p></blockquote><p>二叉树的题目可分为以下几种类型：</p><ul><li>求普通二叉树的属性：一般用后序，因为需要用到左右子树的属性来计算本节点的属性，但有例外</li><li>二叉树的修改与构造：使用前序，因为需要先构造中节点</li><li>求二叉搜索树的属性：使用中序</li></ul><p>题目归类：<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87.html">二叉树总结篇</a></p><p>未看的文章：23~33</p><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h3 id="理论基础-2"><a href="#理论基础-2" class="headerlink" title="理论基础"></a>理论基础</h3><p><strong>回溯是递归的副产品，只要有递归就会有回溯</strong>，所以回溯法也经常和二叉树遍历，深度优先搜索混在一起，因为这两种方式都是用了递归。回溯法就是暴力搜索，并不是什么高效的算法，最多再剪枝一下。</p><p><strong>回溯法解决的问题都可以抽象为树形结构</strong>。因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度就构成了树的深度</strong>。递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</p><p><strong><u>回溯法的模板：</u></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>回溯算法能解决如下问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>棋盘问题：N皇后，解数独等等</li></ul><h3 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h3><p><strong>剪枝技巧：</strong></p><ul><li>for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够题目要求的k个元素了，就没有必要搜索了（77.组合）</li><li>已选元素总和如果已经大于n（题中要求的和）了，那么往后遍历就没有意义了，直接剪掉（216.组合总和III）</li><li>其他剪枝技巧需要具体问题具体分析</li></ul><p>组合问题通常需要<strong>startIndex</strong>来控制for循环的起始位置，如果是一个集合来求组合的话，就需要startIndex；如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，如：17.电话号码的字母组合。</p><p><strong>去重问题</strong>：集合元素会有重复，但要求解集不能包含重复的组合。需要理解“同一树枝上重复”与“同一树层上重复”，具体看：40.组合总和II。</p><blockquote><p>77.组合、216.组合总和III、17.电话号码的字母组合、39. 组合总和、<strong>40.组合总和II</strong>、<strong>332.重新安排行程</strong></p></blockquote><h3 id="切割问题"><a href="#切割问题" class="headerlink" title="切割问题"></a>切割问题</h3><p>类似于组合问题，需要了解string的基本操作。</p><blockquote><p>131.分割回文串、93.复原IP地址</p></blockquote><h3 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h3><p>在树形结构中子集问题是要收集所有节点的结果，而组合问题是收集叶子节点的结果。</p><blockquote><p>78.子集</p></blockquote><h3 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h3><p>每层都是从0开始搜索而不是startIndex；需要used数组记录path里都放了哪些元素了。</p><blockquote><p>46.全排列</p></blockquote><h3 id="棋盘问题"><a href="#棋盘问题" class="headerlink" title="棋盘问题"></a>棋盘问题</h3><p>一些只需要找到一个解的问题（如：37. 解数独、332.重新安排行程），可以将回溯函数的<strong>返回值设为bool</strong>，当找到解直接用true返回所有递归，代码见<a href="https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html#%E5%9B%9E%E6%BA%AF%E6%B3%95">链接</a></p><blockquote><p>51.N皇后、37.解数独</p></blockquote><h3 id="时间-空间复杂度分析"><a href="#时间-空间复杂度分析" class="headerlink" title="时间&#x2F;空间复杂度分析"></a>时间&#x2F;空间复杂度分析</h3><p><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90">链接</a></p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211030124742.png" style="zoom: 80%;" /><p>未看的文章：13、14、16、19</p><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h3 id="理论基础-3"><a href="#理论基础-3" class="headerlink" title="理论基础"></a>理论基础</h3><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。贪心的问题通常是<strong>求一个最值</strong>，贪心问题没有一个固定套路，只能靠自己<strong>手动模拟</strong>，如果模拟中用了局部最优推出全局最优的思想，且<strong>找不出反例</strong>，就可以试一试贪心策略，如果不可行，可能需要动态规划。不需要精确的数学推导。</p><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><ul><li><p>有些题目数组是无序的，混乱中并不能产生最值，且题目与元素之间的相对位置无关，此时通常需要<strong>先对数组进行排序</strong>。需要看一下sort函数自定义排序规则的方式（见452. 用最少数量的箭引爆气球）。</p><p>但一些题目关乎相邻元素的关系、求连续子数组，就不能改变元素位置（如376. 摆动序列、 53. 最大子序和）。</p><blockquote><p>455.分发饼干、1005.K次取反后最大化的数组和、<strong>406.根据身高重建队列</strong>、452. 用最少数量的箭引爆气球</p></blockquote></li></ul><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="理论基础-4"><a href="#理论基础-4" class="headerlink" title="理论基础"></a>理论基础</h3><p>动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多<strong>重叠子问题</strong>，使用动态规划是最有效的。所以动态规划中<strong>每一个状态一定是由上一个状态推导出来的</strong>，这一点就区分于贪心，贪心没有状态推导，而是<strong>从局部直接选最优</strong>的。</p><p><strong>对于动态规划问题，拆解为如下五步曲：</strong></p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式（由以往的状态推导出当前的状态，即dp[i-1]或dp[i-2]等推出dp[i]。一般要分情况讨论）</li><li>dp数组如何初始化（结合递推公式确定初始化。有时初始化没有实际含义，仅仅是为了保证递推公式）</li><li>确定遍历顺序（for循环顺序，根据递推公式确定，看dp[i]依赖什么）</li><li>举例推导dp数组</li></ol><p><strong>做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果。写出代码后，如果出问题，把dp数组打印出来，看看究竟是不是按照自己思路推导的。</strong></p><blockquote><ol start="509"><li>斐波那契数、70. 爬楼梯、746. 使用最小花费爬楼梯、62.不同路径、63. 不同路径 II、<strong>343. 整数拆分</strong>、96.不同的二叉搜索树</li></ol></blockquote><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解物品价值总和最大是多少。</p><ul><li>二维dp数组：</li></ul><p>dp数组的定义：<strong>dp[i] [j]表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p><p>递推公式：dp[i] [j] &#x3D; max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i])    分别对应不取物品i和取物品i的两种情况</p><p>初始化：背包容量j为0，即dp[i] [0]，初始化为0；存放编号0的物品，当 j &lt; weight[0]时dp[0] [j] 初始化为0，当j &gt;&#x3D; weight[0]时dp[0] [j] 初始化为 value[0]。</p><p>遍历顺序：先遍历物品再遍历背包容量，或者反过来都可以</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>一维dp数组：</li></ul><p>利用<strong>滚动数组压缩空间复杂度</strong>，每完整刷新一轮数组就是增加了一件物品。</p><p>dp数组的定义：容量为j的背包，所背的物品价值可以最大为dp[j]</p><p>递推公式：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i])</p><p>初始化：背包容量j为0，即dp[0]，初始化为0；其他dp[j]的值随意，但一般也初始化为0。</p><p>遍历顺序：<strong>先遍历物品并且内层倒序遍历背包容量</strong>，不能反过来。倒序是为了保证递推式中用的dp[j - weight[i]]是上一轮的值，即dp[ i - 1 ] [j - weight[i]]。否则每个物品就会多次抽取，就变成了完全背包。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="416"><li>分割等和子集、<strong>1049. 最后一块石头的重量 II</strong></li></ol></blockquote><p>以上两道道题类似，都是<strong>把一组数分成两组，使得两组和的差值最小</strong>。做法是对和较小的那一组做DP，转化为容积为sum&#x2F;2的背包，每个物品的体积和价值都是相同的。dp[sum&#x2F;2]表示从原数组中选择一部分数，在和不超过sum&#x2F;2的情况下，所能达到的最大和。由于已经限制了DP部分的和不超过sum&#x2F;2，所以没有被DP选中的数之和（sum - dp[sum&#x2F;2]）一定是比DP部分的和大的，那么两组和的最小差值就是sum - dp[sum&#x2F;2] - dp[sum&#x2F;2]，不需要加绝对值。</p><blockquote><ol start="494"><li>目标和、 <strong>474.一和零</strong></li></ol></blockquote><p>目标和也是一组数分为两组，但将问题转化为<strong>恰好装满背包容积</strong>，有多少种装法，初始化有所不同。一和零也是01背包，但背包的容积有两个维度，做法一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 目标和</span><br>dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;  <span class="hljs-comment">// 初始化：加和为0的取法只有一种，即什么数也不取</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=x; j&gt;=nums[i]; j--)&#123;<br>        dp[j] += dp[j-nums[i]];  <span class="hljs-comment">// 递推公式</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><p>由01背包问题延伸而来，<strong>物品数量是无限的</strong>。</p><p><strong>题目总结</strong>：</p><ul><li><p><strong>纯完全背包</strong>，求解物品价值的总和最大是多少：</p><p>与01背包问题的解法区别仅在于遍历顺序，需要将一维dp数组的遍历顺序改为 外层遍历物品并且<strong>内层正序</strong>遍历背包容量。也可以先遍历背包容量再遍历物品。<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85">链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>内层正序遍历背包容量的话，每次递推公式里的 dp[ j - weight[i]] 就已经是被覆盖的值了，即本轮的值 dp[ i ] [ j - weight[i]] ，就可以做到多次选取物品。</p><blockquote><p><a href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html#_322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2">322. 零钱兑换</a></p></blockquote></li><li><p><strong>组合数</strong>，每个物品数量无限，求恰好凑成给定价值的组合数有多少：必须<strong>外层for循环遍历物品，内层for遍历背包</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] += dp[j - coins[i]];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">518. 零钱兑换 II</a></p></blockquote></li><li><p><strong>排列数</strong>，每个物品数量无限，求恰好凑成给定价值的排列数有多少：必须<strong>外层for遍历背包，内层for循环遍历物品</strong>。<a href="https://leetcode.cn/problems/combination-sum-iv/solution/zu-he-zong-he-iv-by-leetcode-solution-q8zv/">理解看这里</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= amount; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">if</span> (j - coins[i] &gt;= <span class="hljs-number">0</span>) dp[j] += dp[j - coins[i]];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html#_377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-iv">377. 组合总和 Ⅳ</a>、<a href="https://programmercarl.com/0139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86.html#_139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86">139.单词拆分</a></p></blockquote></li></ul><h3 id="打家劫舍系列"><a href="#打家劫舍系列" class="headerlink" title="打家劫舍系列"></a>打家劫舍系列</h3><blockquote><p><a href="https://leetcode-cn.com/problems/house-robber/">198.打家劫舍</a></p></blockquote><p>简单的动规题，dp[i] 由 dp[i-1] 和 dp[i-2] 推出</p><blockquote><p><a href="https://leetcode-cn.com/problems/house-robber-ii/">213.打家劫舍II</a></p></blockquote><p>考虑头尾两间房子，分两种情况，分别调用一次198.打家劫舍</p><blockquote><p><a href="https://leetcode.cn/problems/house-robber-iii/">337.打家劫舍 III</a></p></blockquote><p><strong>树形DP</strong>，结合了<strong>动态规划</strong>与<strong>二叉树的后序遍历</strong>。递归函数的返回值是偷与不偷的两个状态所得到的金钱构成的dp数组，必须要<strong>后序遍历</strong>，因为通过递归函数的返回值来计算父节点的dp数组。<a href="https://programmercarl.com/0337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">代码见</a></p><h3 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h3><blockquote><p><a href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">121.买卖股票的最佳时机</a></p><p><a href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">122.买卖股票的最佳时机II</a></p><p><a href="https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html">123.买卖股票的最佳时机III</a></p><p><a href="https://programmercarl.com/0188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV.html">188.买卖股票的最佳时机IV</a></p><p><a href="https://programmercarl.com/0309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html">309.最佳买卖股票时机含冷冻期</a></p><p><a href="https://programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">714.买卖股票的最佳时机含手续费</a></p></blockquote><p>做法类似，将状态分为持有和不持有（限制买卖次数时多分几个状态），定义一个二维的dp数组，第一维表示天数，第二维表示状态，dp[i] [0] 表示第i天结束时持有股票剩余金额，dp[i] [1] 表示第i天结束时不持有股票剩余金额，递推公式由dp[i-1]推出。</p><h3 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h3><blockquote><p>不连续（子序列）：</p><p><a href="https://programmercarl.com/0300.%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.html">300.最长递增子序列</a></p><p><a href="https://programmercarl.com/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html">1143.最长公共子序列</a></p><p><a href="https://programmercarl.com/1035.%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF.html">1035.不相交的线</a></p><p>连续（子数组）：</p><p><a href="https://programmercarl.com/0674.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97.html">674.最长连续递增序列</a></p><p><a href="https://programmercarl.com/0718.%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84.html">718.最长重复子数组</a></p><p><a href="https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">53.最大子序和</a></p><p>编辑距离：</p><p><a href="https://programmercarl.com/0392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.html">392.判断子序列</a></p><p><a href="https://programmercarl.com/0115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.html">115.不同的子序列</a></p><p><a href="https://programmercarl.com/0583.%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.html">583.两个字符串的删除操作</a></p><p><a href="https://programmercarl.com/0072.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html">72.编辑距离</a></p><p>回文串：</p><p><a href="https://programmercarl.com/0647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html">647.回文子串</a></p><p><a href="https://programmercarl.com/0516.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.html">516.最长回文子序列</a></p></blockquote><p>对于dp数组定义，一般是dp[i]表示以s[i]结尾的字符串或者在s[i]之前的。。。递推公式则要分类讨论，循环顺序根据递推公式决定。</p><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p><strong>单调栈的应用场景</strong>：通常是一维数组，要寻找任一个元素的<strong>右边或者左边第一个比自己大或者小的元素的位置</strong>，此时我们就要想到可以用单调栈了。时间复杂度为O(n)。</p><p><strong>单调栈的原理</strong>：当寻找右边第一个比自己大的元素时，栈中元素<strong>从栈底到栈顶应该是从大到小</strong>，遍历时遇到比栈顶元素小的元素，直接入栈；遇到比栈顶元素大的元素，就需要将栈顶元素出栈，再入栈（类似于<strong>汉诺塔</strong>，小盘子只能垒在大盘子上方），此时栈顶元素就已经找到了右边第一个比自己大的元素，即当前遍历的元素。</p><p>使用单调栈主要有三个<strong>判断条件</strong>，可以视情况合并为两个（取决于寻找的是右边严格大于自己的元素，还是大于等于）：</p><ul><li>当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况</li><li>当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况</li><li>当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">stack&lt;<span class="hljs-type">int</span>&gt; st;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(temperatures.size(), <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">// 这里的初始值0取决于问题的需求，表示没有右边比自己大的元素时的结果</span><br>st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;temperatures.<span class="hljs-built_in">size</span>(); i++)&#123;<br>    <span class="hljs-keyword">if</span> (temperatures[i] &lt;= temperatures[st.<span class="hljs-built_in">top</span>()])&#123;  <span class="hljs-comment">// 当前遍历的元素T[i]小于等于栈顶元素T[st.top()]的情况，直接入栈</span><br>        st.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况，取出栈顶元素再入栈</span><br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; temperatures[i] &gt; temperatures[st.<span class="hljs-built_in">top</span>()])&#123;<br>            result[st.<span class="hljs-built_in">top</span>()] = i-st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        st.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> result;<br></code></pre></td></tr></table></figure><p>当寻找右边比自己小的元素、左边比自己大&#x2F;小的元素时，可以进行类比，单调栈的顺序会有不同。</p><blockquote><p>739.每日温度、496.下一个更大元素 I、503.下一个更大元素II、<strong>42. 接雨水、84.柱状图中最大的矩形</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>求职</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的Git学习笔记</title>
    <link href="/posts/3059.html"/>
    <url>/posts/3059.html</url>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><p>Git是目前世界上最先进的分布式版本控制系统，可以自动记录每次文件的改动，还可以让同事协作编辑。在2005年由Linus开发。相比集中式，分布式版本控制系统没有“中央服务器”，每个人的电脑上都是一个完整的版本库，不必联网；修改文件后只需把各自的修改推送给对方；还支持分支管理。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><strong>工作区（worktree）：</strong>电脑中本地代码实际存放的目录。</li><li><strong>暂存区（staged&#x2F;index）：</strong>暂时存放文件的修改的地方，一般存放在 <strong>.git</strong> 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）。</li><li><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库。包含了所有的分支与版本。</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2015/02/1352126739_7909.jpg" alt="工作区与版本库"></p><ul><li>图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage&#x2F;index），标记为 “master” 的是 master 分支所代表的目录树。</li><li>当对工作区修改（或新增）的文件执行 <code>git add</code> 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</li><li>当执行提交操作 <code>git commit</code> 命令时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</li><li>HEAD指针指向版本库中当前分支、当前所在的版本（或者说指向某一个分支名，如main；而分支名main也是个指针，指向某一个commit）。可以使用<code>git reset</code>改变HEAD指针指向的版本。HEAD^表示当前版本的父版本，HEAD^^表示上两个版本，以此类推。commit_id也可以用版本号的前几位表示。</li></ul><h2 id="创建版本库（仓库）"><a href="#创建版本库（仓库）" class="headerlink" title="创建版本库（仓库）"></a>创建版本库（仓库）</h2><p>进入某个目录后，执行<code>git init</code>命令。该目录下就会自动生成 .git文件夹，该目录变成一个Git管理的版本库。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li><p><code>git add &lt;file&gt;</code> ：添加文件修改到暂存区</p></li><li><p><code>git commit -m &#39;message&#39;</code> ：提交暂存区的文件修改到版本库的当前分支。git管理的是文件的修改，add与commit操作的对象都是文件的修改。</p></li><li><p><code>git status</code> ：查看工作区的状态，哪些修改未提交</p><h4 id="比较差异："><a href="#比较差异：" class="headerlink" title="比较差异："></a>比较差异：</h4></li><li><p><code>git diff &lt;file&gt;</code> ：查看工作区与暂存区文件的差异</p></li><li><p><code>git diff --staged &lt;file&gt;</code> ：查看暂存区与版本库当前版本文件的差异</p><h4 id="版本回退："><a href="#版本回退：" class="headerlink" title="版本回退："></a>版本回退：</h4></li><li><p><code>git log</code> ：显示当前分支的版本历史，一个commit就对应了一个版本，也是分支图中的一个节点。<code>git log --graph --oneline --all</code>画出所有分支的分支图。</p></li><li><p><code>git reset --hard &lt;commit_id | HEAD&gt;</code> ：暂存区与工作区的文件都回退到某个版本。HEAD指针指向当前所在的版本；如果使用commit_id，HEAD指针和分支名指针也会改变（即版本库的当前版本变了）。</p></li><li><p><code>git reset &lt;commit_id | HEAD&gt;</code> ：（省略了–mixed）版本库与暂存区的文件回退到某个版本，工作区文件不变保留修改，变为未暂存的状态。如果使用commit_id，HEAD指针和分支名指针也会改变。（如果工作区已经和版本库一致，但上次提交的commit有错误，想要修改又不想产生新的commit，可以用此命令回退版本库，但保留工作区修改，修改工作区后重新提交）</p></li><li><p><code>git reflog</code> ：查看命令历史</p><h4 id="撤销修改："><a href="#撤销修改：" class="headerlink" title="撤销修改："></a>撤销修改：</h4></li><li><p><code>git restore &lt;file&gt;</code> ：使用暂存区的文件内容恢复工作区的文件（即丢弃工作区的修改）</p></li><li><p><code>git restore --staged &lt;file&gt;</code> ：使用版本库当前版本（HEAD）的内容恢复暂存区的内容（即取消暂存，工作区保持不变）</p><img src="https://pub-68498345ab4b4950815fe9ca6cfa90be.r2.dev/picgo/20250105214320883.png" alt="撤销与提交操作" style="zoom:50%;" /></li><li><p><code>git rm &lt;file&gt;</code> ：删除一个文件，并将删除操作添加至暂存区</p><h4 id="连接远程仓库："><a href="#连接远程仓库：" class="headerlink" title="连接远程仓库："></a>连接远程仓库：</h4></li><li><p><code>git remote add origin git@github.com:AquariusLeo/gitlearning.git</code> ：连接GitHub上的远程仓库，origin是这个远程连接的引用的名字，可以随便改</p></li><li><p><code>git remote -v</code> ：查看连接的远程仓库信息</p></li><li><p><code>git remote show &lt;remote-name&gt;</code>：查看所有的远程连接，或查看指定的连接的信息。</p></li><li><p><code>git push [-u] origin main</code> ：把本地的main分支的修改推送到远程库origin中。-u：将本地的main分支关联到远程库的main分支，即追踪tracking&#x2F;upstream。之后推送修改就不需要加-u。</p></li><li><p><code>git pull</code> ：把远程仓库的最新commit抓取到本地的当前分支。抓取前需要建立与远程分支的追踪关系。</p></li><li><p><code>git branch --set-upstream-to=origin/&lt;branch-name&gt; &lt;local-branch-name&gt;</code>：将本地分支与远程分支建立追踪关系。追踪关系可以用<code>git remote show origin</code>查看。在pull或者push之前都要建立追踪关系，或者使用-u选项</p></li><li><p><code>git remote rm &lt;name&gt;</code> ：删除远程库连接</p></li><li><p><code>git clone &lt;url&gt;</code> ：从远程库克隆。url可以使用ssh协议的<a href="mailto:&#103;&#x69;&#116;&#x40;&#x67;&#105;&#116;&#x68;&#x75;&#x62;&#46;&#x63;&#111;&#109;">&#103;&#x69;&#116;&#x40;&#x67;&#105;&#116;&#x68;&#x75;&#x62;&#46;&#x63;&#111;&#109;</a>……  形式，也可以是http协议的<a href="https://github.com/%E2%80%A6%E2%80%A6">https://github.com/……</a>  形式</p><h4 id="分支管理："><a href="#分支管理：" class="headerlink" title="分支管理："></a>分支管理：</h4></li><li><p><code>git branch</code> ：列出所有的已存在分支</p></li><li><p><code>git branch &lt;branchname&gt;</code> ：创建一个新分支，指向当前HEAD的位置。–delete：删除分支，–move：移动&#x2F;重命名分支，–copy：复制分支</p></li><li><p><code>git switch &lt;branchname&gt;</code> ：切换分支。-c：创建后再切换。</p></li><li><p><code>git merge &lt;branchname&gt;</code> ：合并branchname分支到当前分支。当Git无法自动合并分支时，就必须首先解决冲突，把Git合并失败的文件手动编辑为我们希望的内容。解决冲突后，再add、commit，合并完成。–no-ff：禁用Fast forward模式，在merge时必定生成一个commit，这样可避免删除分支后，会丢掉分支信息。</p></li><li><p><code>git stash</code> ：保存当前工作现场（包括工作区未add的修改和暂存区未commit的修改），之后工作区会是干净的，可以放心地创建新分支。主要用于在开发过程中临时去别的分支修复bug。</p></li><li><p><code>git stash list</code> ：查看所有被保存的工作现场。</p></li><li><p><code>git stash pop</code> ：恢复上一个保存的stash，并把它删除。</p></li><li><p><code>git cherry-pick &lt;commit_id&gt;</code> ：复制某个commit的修改到当前分支。常用于复制bug修复。</p></li><li><p><code>git rebase</code> ：（变基）把本地未push的分叉提交历史整理成直线，使得在查看历史提交的变化时更容易</p><h4 id="多人协作的工作模式："><a href="#多人协作的工作模式：" class="headerlink" title="多人协作的工作模式："></a>多人协作的工作模式：</h4></li><li><p>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</p></li><li><p>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</p></li><li><p>如果pull合并有冲突，则解决冲突，并在本地add、commit提交；</p></li><li><p>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</p></li><li><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to=origin/&lt;branch-name&gt; &lt;local-branch-name&gt;</code>。</p><h4 id="标签管理："><a href="#标签管理：" class="headerlink" title="标签管理："></a>标签管理：</h4></li><li><p>标签是版本库的一个快照，唯一确定了打标签时刻的版本，其实就是指向某个commit的指针。使用标签是为了定义简明的版本号，而不是使用很长的commit_id。</p></li><li><p><code>git tag &lt;tagname&gt; [&lt;commit_id&gt;]</code> ：给某个commit打上标签。<code>git tag</code>会列出所有的标签，<code>git show &lt;tagname&gt;</code>查看标签信息。-d：删除标签。</p></li></ul><h2 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h2><ul><li>定义别名：<code>git config --global alias.st &#39;status&#39;</code></li><li>忽略特殊文件：在.gitignore文件中配置</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>版本管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/posts/3eeb.html"/>
    <url>/posts/3eeb.html</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
