<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux笔记-常用命令-文件压缩</title>
    <link href="/posts/ddca.html"/>
    <url>/posts/ddca.html</url>
    
    <content type="html"><![CDATA[<h2 id="文件的压缩"><a href="#文件的压缩" class="headerlink" title="文件的压缩"></a>文件的压缩</h2><h3 id="压缩文件类型"><a href="#压缩文件类型" class="headerlink" title="压缩文件类型"></a>压缩文件类型</h3><ul><li>*.z：compress程序压缩的文件</li><li>*.zip：zip程序压缩的文件</li><li>*.gz：gzip程序压缩的文件</li><li>*.bz2：bzip2程序压缩的文件</li><li>*.xz：xz程序压缩的文件</li><li>*.tar：tar程序打包的文件，并没有压缩过</li><li>*.tar.gz、*.tar.bz2、*.tar.xz：tar程序打包的文件，并且经过压缩</li></ul><h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><p>语法：gzip  [-cdltv#]  file</p><blockquote><p>gzip可向下兼容解压compress、zip的压缩文件 </p></blockquote><h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><ul><li>-c：将结果输出到标准输出，源文件保持不变。可以重定向到文件（gzip默认压缩后会删除源文件。使用-c并重定向到文件可以保留源文件，如gzip -c services &gt; services.gz）</li><li>-d：解压（gzip -d会在解压后删除原压缩文件.gz）</li><li>-l：列出压缩文件的相关信息</li><li>-t：检验压缩文件的完整性</li><li>-#：#为数字，代表压缩等级，-1最快但是压缩比最差，-9最慢但是压缩比最好，默认是-6</li></ul><p>zcat、zmore、zless、zgrep    读取纯文本文件被压缩后的压缩文件或查找关键词</p><h3 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h3><p>语法与选项与gzip相同，多了一个-k可保留源文件</p><p>bzcat、bzmore、bzless、bzgrep</p><h3 id="xz"><a href="#xz" class="headerlink" title="xz"></a>xz</h3><p>语法与选项与gzip相同，多了一个-k可保留源文件。压缩率xz最好，但时间xz最差</p><p>xzcat、xzmore、xzless、xzgrep</p><h3 id="tar-打包及压缩"><a href="#tar-打包及压缩" class="headerlink" title="tar    打包及压缩"></a>tar    打包及压缩</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ul><li>打包：tar  [-z&#x2F;j&#x2F;J]  -cv  -f  打包后的文件名  被打包的文件或目录名</li><li>查询：tar  [-z&#x2F;j&#x2F;J]  -tv  -f  打包后的文件名</li><li>解包：tar  [-z&#x2F;j&#x2F;J]  -xv  -f  打包后的文件名  -C  欲解包到的目录</li></ul><blockquote><p>这里打包后的文件名要符合上面压缩文件命名规范，如*.tar.gz等。由于tar会打包时会把目录结构打进去，因此强烈建议不使用绝对路径，打包前先cd到目标目录，tar命令中使用相对路径，如cd &#x2F;home&#x2F;fly&#x2F;tobetar&#x2F; &amp;&amp; tar -cz -f ${zipfile} .&#x2F;*</p></blockquote><h4 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h4><ul><li>-z：通过gzip解压缩</li><li>-j：通过bzip2解压缩</li><li>-J：通过xz解压缩</li><li>（以上三个选项之间不可共存。不加这三个选项，表示仅作打包，filename要取为*.tar；加这三个选项，表示同时使用压缩技术，filename要取为*.tar.gz、*.tar.bz2、*.tar.xz）</li><li>-c：建立打包文件</li><li>-t：查询打包文件的内容（列出文件名）</li><li>-x：解包文件</li><li>（以上三个选项之间不可共存）</li><li>-v：显示正在处理的文件名（显示提示信息）</li><li>-f：接打包后的文件名，最好单独写一个选项</li><li>-C：在执行任何操作前先cd到特定目录</li><li>-p：保留原本权限与属性，常用于备份</li><li>-P：保留绝对路径，即打包文件中也存在根目录（不常用）</li><li>–exclude&#x3D;file：排除某些文件</li></ul><h4 id="特殊用法"><a href="#特殊用法" class="headerlink" title="特殊用法"></a>特殊用法</h4><ul><li>仅解开单一文件：tar  [-z&#x2F;j&#x2F;J]  -xv  -f  打包后的文件名  要解开的单一文件名（要解开的单一文件名要通过 -t 选项查找到正确的文件名）</li><li>打包某目录，但不包括该目录下某些文件：加上–exclude&#x3D;file选项</li><li>仅备份比某时刻新的文件：加上–newer-mtime&#x3D;’DATE’选项</li><li>备份到磁带（如&#x2F;dev&#x2F;st0）：tar  -cv  -f  &#x2F;dev&#x2F;st0  被打包的目录</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux笔记-常用命令-文件与目录管理</title>
    <link href="/posts/2b60.html"/>
    <url>/posts/2b60.html</url>
    
    <content type="html"><![CDATA[<h2 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="文件与目录管理"></a>文件与目录管理</h2><h3 id="1-文件与目录的基本操作"><a href="#1-文件与目录的基本操作" class="headerlink" title="1. 文件与目录的基本操作"></a>1. 文件与目录的基本操作</h3><h4 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd    切换目录"></a>cd    切换目录</h4><p>语法：cd  [相对路径&#x2F;绝对路径]</p><blockquote><p>路径缺省时代表cd ~</p></blockquote><h5 id="特殊目录"><a href="#特殊目录" class="headerlink" title="特殊目录"></a>特殊目录</h5><ul><li>.  此目录</li><li>..  上一层目录</li><li>-  前一个工作目录</li><li>~  当前使用者的家目录</li><li>~account  指定用户account的家目录</li></ul><h4 id="pwd-显示当前工作目录"><a href="#pwd-显示当前工作目录" class="headerlink" title="pwd    显示当前工作目录"></a>pwd    显示当前工作目录</h4><h5 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h5><ul><li>-P：显示真正路径，而非连接路径</li></ul><h4 id="mkdir-新建目录"><a href="#mkdir-新建目录" class="headerlink" title="mkdir    新建目录"></a>mkdir    新建目录</h4><h5 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h5><ul><li>-m：使用给定的权限，不使用默认权限</li><li>-p：递归地创建上层目录</li></ul><h4 id="rmdir-删除空目录"><a href="#rmdir-删除空目录" class="headerlink" title="rmdir    删除空目录"></a>rmdir    删除空目录</h4><h5 id="选项-2"><a href="#选项-2" class="headerlink" title="选项"></a>选项</h5><p>-p：递归地删除上层的空目录</p><blockquote><p>rmdir<strong>只能删除空目录</strong>，非空目录会报错，非空目录要用rm -r</p></blockquote><h4 id="ls-列出目录中的文件信息"><a href="#ls-列出目录中的文件信息" class="headerlink" title="ls    列出目录中的文件信息"></a>ls    列出目录中的文件信息</h4><p>语法：ls  [-adFhilR]  [–time&#x3D;{atime,ctime}]  file&#x2F;dir</p><h5 id="选项-3"><a href="#选项-3" class="headerlink" title="选项"></a>选项</h5><ul><li>-a：列出<strong>所有文件</strong>，包括隐藏文件（以 . 开头的文件）</li><li>-d：仅列出目录本身信息，而非目录下的文件信息</li><li>-F：在文件名后附加类型信息，如*代表可执行文件；&#x2F;代表目录；&#x3D;代表socket文件；|代表FIFO文件</li><li>-h：将文件容量以<strong>人类较易读的方式</strong>（例如GB、KB等）列出来</li><li>-i：列出inode号码</li><li>-l：列出文件或目录的<strong>详细信息</strong>   可使用别名‘ll’</li><li>-R：递归地列出目录下的所有文件与子目录</li><li>–time&#x3D;{atime,ctime}：显示读取时间atime或状态时间ctime，而非修改时间mtime（mtime、atime、ctime含义见touch）</li></ul><h4 id="cp-复制文件或目录"><a href="#cp-复制文件或目录" class="headerlink" title="cp    复制文件或目录"></a>cp    复制文件或目录</h4><p>语法：cp  [-adfilspru]  sourcefile&#x2F;dir  destinationfile&#x2F;dir</p><h5 id="选项-4"><a href="#选项-4" class="headerlink" title="选项"></a>选项</h5><ul><li><p>-a：等同于-dr  –preserve&#x3D;all，保留所有属性并递归地复制子目录（<strong>常用于备份</strong>）（使用cp -a时只能复制mtime、atime，不能复制ctime）</p></li><li><p>-d：若源文件为链接文件（link file）， 则复制链接文件属性而非文件本身</p></li><li><p>-f：强制（force），若目标文件已经存在且无法开启，则删除后再尝试一次</p></li><li><p>-i：交互模式，覆盖已存在的目标文件前询问是否进行操作</p></li><li><p>-l：建立硬链接文件（hard link），而非复制文件本身</p></li><li><p>-s：建立符号链接文件（symbolic link），而非复制文件本身</p></li><li><p>-p：连同文件的属性（权限、用户、时间）一起复制过去，而非使用默认属性（备份常用）</p><blockquote><p>若无-p选项，复制后目标文件的拥有者通常会变为cp命令的执行者，要注意文件的属性权限</p></blockquote></li><li><p>-r：<strong>递归地复制目录下</strong>的所有文件与子目录，用于目录的复制</p></li><li><p>-u：destination比source旧才更新destination，或destination不存在的情況下才复制</p></li><li><p>–preserve&#x3D;all：除了-p保留的属性外，还会保留SELinux、links、xattr等属性</p></li></ul><h4 id="rm-删除文件或目录"><a href="#rm-删除文件或目录" class="headerlink" title="rm    删除文件或目录"></a>rm    删除文件或目录</h4><p>语法：rm  [-fir]  file&#x2F;dir</p><h5 id="选项-5"><a href="#选项-5" class="headerlink" title="选项"></a>选项</h5><ul><li><p>-f：强制（force），忽略不存在的文件</p></li><li><p>-i：交互模式，在删除前询问是否进行操作（建议设定别名rm&#x3D;’rm -i’）</p></li><li><p>-r：<strong>递归地删除</strong>目录下的所有文件与子目录，用于目录的删除</p><blockquote><p>cp、rm作用于目录都要用-r选项，mv作用于目录不需要</p></blockquote></li></ul><h4 id="mv-移动文件或目录-重命名"><a href="#mv-移动文件或目录-重命名" class="headerlink" title="mv    移动文件或目录&#x2F;重命名"></a>mv    移动文件或目录&#x2F;重命名</h4><p>语法：mv  [-fiu]  sourcefile&#x2F;dir  destinationfile&#x2F;dir</p><h5 id="选项-6"><a href="#选项-6" class="headerlink" title="选项"></a>选项</h5><ul><li>-f：强制（force），若目标文件已经存在，不会询问直接覆盖</li><li>-i：交互模式，覆盖已存在的目标文件前询问是否进行操作</li><li>-u：destination比source旧才更新destination，或destination不存在的情況下才移动</li></ul><h4 id="touch-修改文件时间或创建新文件"><a href="#touch-修改文件时间或创建新文件" class="headerlink" title="touch    修改文件时间或创建新文件"></a>touch    修改文件时间或创建新文件</h4><h5 id="选项-7"><a href="#选项-7" class="headerlink" title="选项"></a>选项</h5><ul><li><p>-a：仅修改atime</p></li><li><p>-m：仅修改mtime</p><blockquote><p>不加选项时同时修改atime和mtime</p></blockquote></li><li><p>-c：仅修改文件的时间，若文件不存在则不会创建新文件</p><blockquote><p>若无-c，touch默认将文件的三个时间更新为当前时间，若文件不存在则创建新文件</p></blockquote></li><li><p>-d  ‘时间’&#x2F;-t  YYYYMMDDhhmm：自定义时间，而非当前时间</p></li></ul><h5 id="文件的三个时间"><a href="#文件的三个时间" class="headerlink" title="文件的三个时间"></a>文件的三个时间</h5><ul><li>mtime：修改时间，最近一次变动文件内容的时间（ls -l显示的是mtime）</li><li>atime：读取时间，最近一次读取文件内容的时间</li><li>ctime：状态时间，最近一次状态变更的时间，如权限与属性的变化</li></ul><h4 id="dirname-basename-获取目录名-文件名"><a href="#dirname-basename-获取目录名-文件名" class="headerlink" title="dirname&#x2F;basename    获取目录名&#x2F;文件名"></a>dirname&#x2F;basename    获取目录名&#x2F;文件名</h4><p>语法：dirname&#x2F;basename  [路径]  </p><p>拆分文件所在目录路径与文件名</p><h4 id="PATH"><a href="#PATH" class="headerlink" title="PATH"></a>PATH</h4><p>环境变量，定义了执行命令时查找可执行文件的目录。不同用户有不同的PATH</p><p>显示环境变量：echo  $PATH</p><p>修改环境变量：PATH&#x3D;”${PATH}:目录”</p><h3 id="2-文件内容读取"><a href="#2-文件内容读取" class="headerlink" title="2. 文件内容读取"></a>2. 文件内容读取</h3><h4 id="cat-将文件内容打印在屏幕上"><a href="#cat-将文件内容打印在屏幕上" class="headerlink" title="cat    将文件内容打印在屏幕上"></a>cat    将文件内容打印在屏幕上</h4><h5 id="选项-8"><a href="#选项-8" class="headerlink" title="选项"></a>选项</h5><ul><li>-n：打印行号，包括空白行</li><li>-b：打印行号，不包括空白行</li><li>-A：显示出特殊字符</li></ul><h4 id="tac-将文件反向打印在屏幕上"><a href="#tac-将文件反向打印在屏幕上" class="headerlink" title="tac    将文件反向打印在屏幕上"></a>tac    将文件反向打印在屏幕上</h4><h4 id="nl-添加行号打印文件"><a href="#nl-添加行号打印文件" class="headerlink" title="nl    添加行号打印文件"></a>nl    添加行号打印文件</h4><ul><li>等价于cat -b</li></ul><h4 id="more-less-翻页查看文件内容"><a href="#more-less-翻页查看文件内容" class="headerlink" title="more&#x2F;less    翻页查看文件内容"></a>more&#x2F;less    翻页查看文件内容</h4><h5 id="可执行命令"><a href="#可执行命令" class="headerlink" title="可执行命令"></a>可执行命令</h5><ul><li>[Space]&#x2F;[PageDown]：向下翻一页</li><li>[PageUp]：向上翻一页（more不支持PageDown&#x2F;UP，less功能更全）</li><li>[Home]：去到第一页</li><li>[End]：去到最后一页</li><li>&#x2F;string：向下查找string这个字符串</li><li>?string：向上查找string这个字符串</li><li>n,N：利用&#x2F;或?来查找字符串时，可用n来继续下一个查找，用N来进行反向查找</li><li>:f：显示文件名及当前显示的行数</li><li>q：离开查看</li></ul><h4 id="head-截取前面几行显示"><a href="#head-截取前面几行显示" class="headerlink" title="head    截取前面几行显示"></a>head    截取前面几行显示</h4><h5 id="选项-9"><a href="#选项-9" class="headerlink" title="选项"></a>选项</h5><ul><li>-n number：指定截取的行数</li></ul><h4 id="tail-截取后面几行显示"><a href="#tail-截取后面几行显示" class="headerlink" title="tail    截取后面几行显示"></a>tail    截取后面几行显示</h4><h5 id="选项-10"><a href="#选项-10" class="headerlink" title="选项"></a>选项</h5><ul><li>-n number：指定截取的行数</li><li>-f：持续刷新显示内容，按下[Ctrl+C]停止，如&#x2F;var&#x2F;log&#x2F;messages</li></ul><blockquote><p>可用<strong>管道组合head与tail</strong>，打印文件部分行。如打印文件第11~20行，可使用head -n 20 tmp.txt | tail -n 10</p></blockquote><h4 id="od-读取非纯文本文件"><a href="#od-读取非纯文本文件" class="headerlink" title="od    读取非纯文本文件"></a>od    读取非纯文本文件</h4><p>详见私房菜P191</p><h4 id="file-观察文件类型"><a href="#file-观察文件类型" class="headerlink" title="file    观察文件类型"></a>file    观察文件类型</h4><h3 id="3-命令与文件的查找"><a href="#3-命令与文件的查找" class="headerlink" title="3. 命令与文件的查找"></a>3. 命令与文件的查找</h3><div class="note note-info">            <p>一般查找文件优先使用locate file，速度快，找不到再使用find path -name file。查找命令用which或where。</p>          </div><h4 id="which-查找可执行文件"><a href="#which-查找可执行文件" class="headerlink" title="which    查找可执行文件"></a>which    查找可执行文件</h4><p>语法：which  [-a]  command  （在PATH中查找命令的可执行文件）</p><h5 id="选项-11"><a href="#选项-11" class="headerlink" title="选项"></a>选项</h5><ul><li>-a：显示所有找到的命令</li></ul><h4 id="whereis-在部分特定目录中查找文件"><a href="#whereis-在部分特定目录中查找文件" class="headerlink" title="whereis    在部分特定目录中查找文件"></a>whereis    在部分特定目录中查找文件</h4><blockquote><p>whereis只查找与可执行文件、说明文件、源文件相关的特定目录</p></blockquote><h5 id="选项-12"><a href="#选项-12" class="headerlink" title="选项"></a>选项</h5><ul><li>-l：列出whereis会查询的所有目录</li><li>-b：只找binary可执行文件</li><li>-m：只找manual说明文件</li><li>-s：只找source源文件</li><li>-u：查找不属于上述三类的文件</li></ul><h4 id="locate-在数据库中查找文件"><a href="#locate-在数据库中查找文件" class="headerlink" title="locate    在数据库中查找文件"></a>locate    在数据库中查找文件</h4><blockquote><p>locate是在已建立的数据库中查找，不用直接读磁盘，速度很快。数据库默认每天更新一次，可用sudo updatedb命令手动更新数据库。</p></blockquote><h5 id="选项-13"><a href="#选项-13" class="headerlink" title="选项"></a>选项</h5><ul><li>-i：忽略大小写的差异</li><li>-c：不输出文件名，仅计算找到的文件数量</li><li>-l：仅输出前几行的意思，例如输出五行则是-l 5</li><li>-r：后面可接<strong>正则表达式</strong></li></ul><h4 id="find-在文件系统中查找"><a href="#find-在文件系统中查找" class="headerlink" title="find    在文件系统中查找"></a>find    在文件系统中查找</h4><blockquote><p>直接磁盘中的path路径下寻找文件，速度较慢</p></blockquote><p>语法：find  [path…]  [option]  [action]</p><h5 id="选项option"><a href="#选项option" class="headerlink" title="选项option"></a>选项option</h5><ul><li>-mtime&#x2F;-atime&#x2F;-ctime  n&#x2F;+n&#x2F;-n：筛选时间，n：n天之前的一天之内，+n：n天之前（不含n天），-n：n天之内（不含n天）</li><li>-newer  file：比file还要新的文件</li><li>-user  name：筛选拥有者</li><li>-group  name：筛选用户组</li><li>-name  filename：匹配<strong>文件名</strong>。可用通配符（要加引号 ‘’ ）</li><li>-regex  pattern：使用<strong>正则表达式</strong>匹配文件名（-iregex  忽略大小写的正则）</li><li>-size  [+-]SIZE：查找比SIZE还要大&#x2F;小的文件</li><li>-type  TYPE：查找TYPE<strong>类型</strong>的文件，TYPE：一般文件f，设备文件b&#x2F;c，目录d，链接l，管道p</li><li>-maxdepth levels：从path路径向下递归查找的<strong>最大目录层数</strong>，levels&#x3D;0时表示只在path们自身中寻找</li><li>-mindepth levels：<strong>至少从该层数</strong>开始向下递归查找，levels&#x3D;1时表示不查找path们自身，而是其所有下层</li><li>-perm  MODE：查找权限为MODE的文件，MODE可以是664、4755等</li><li>多个以上表达式可以用<strong>运算符</strong>连接起来，包括-a 且  -o 或  ! 非  。如：<code>find ~ -name Customized* -o -name RPC*</code>   会匹配~目录下这两个字符串开头的文件</li></ul><h5 id="操作action"><a href="#操作action" class="headerlink" title="操作action"></a>操作action</h5><ul><li>-exec  command：查找完成后，对找到的文件执行command命令，如：<code>find  ~  -name  test  -exec  ls  -l  &#123;&#125;  \;  </code>   其中ls  -l  {}代表查找后要执行的命令，{} （花括号）替换为查找结果，; （反斜杠加分号）为结束标志（command不支持别名）</li></ul><h2 id="文件权限管理"><a href="#文件权限管理" class="headerlink" title="文件权限管理"></a>文件权限管理</h2><h3 id="1-修改文件属性与权限"><a href="#1-修改文件属性与权限" class="headerlink" title="1. 修改文件属性与权限"></a>1. 修改文件属性与权限</h3><h4 id="chown-修改拥有者"><a href="#chown-修改拥有者" class="headerlink" title="chown    修改拥有者"></a>chown    修改拥有者</h4><p>语法：chown  [-R]  owner[:group]  file&#x2F;dir</p><h5 id="选项-14"><a href="#选项-14" class="headerlink" title="选项"></a>选项</h5><ul><li>-R：递归地修改目录下的所有文件与子目录</li></ul><h4 id="chgrp-修改所属用户组"><a href="#chgrp-修改所属用户组" class="headerlink" title="chgrp    修改所属用户组"></a>chgrp    修改所属用户组</h4><p>语法：chgrp  [-R]  group  file&#x2F;dir</p><h5 id="选项-15"><a href="#选项-15" class="headerlink" title="选项"></a>选项</h5><ul><li>-R：递归地修改目录下的所有文件与子目录</li></ul><h4 id="chmod-修改权限"><a href="#chmod-修改权限" class="headerlink" title="chmod    修改权限"></a>chmod    修改权限</h4><p>语法：chmod  [-R]  mode  file&#x2F;dir</p><h5 id="选项-16"><a href="#选项-16" class="headerlink" title="选项"></a>选项</h5><ul><li>-R：递归地修改目录下的所有文件与子目录</li><li>mode<ul><li>数字类型：r&#x3D;4，w&#x3D;2，x&#x3D;1，如770代表-rwxrwx—</li><li>符号类型：u&#x3D;user，g&#x3D;group，o&#x3D;others，a&#x3D;all，如u&#x3D;rwx，a+w，a-w</li></ul></li></ul><h5 id="权限对文件与目录有不同的含义"><a href="#权限对文件与目录有不同的含义" class="headerlink" title="权限对文件与目录有不同的含义"></a>权限对文件与目录有不同的含义</h5><p><img src="/../../img/588.png"></p><h5 id="ls-l所列出的第一位含义"><a href="#ls-l所列出的第一位含义" class="headerlink" title="ls -l所列出的第一位含义"></a>ls -l所列出的第一位含义</h5><ul><li>-：常规文件，分为纯文本文件、二进制文件、数据文件</li><li>d：目录</li><li>l：符号链接文件（硬链接文件类型为-）</li><li>b：区块设备文件，以区块读写的设备，如磁盘软盘</li><li>c：字符设备文件，串行端口的设备，如键盘鼠标</li><li>s：接口数据文件，用于网络的数据交换</li><li>p：管道文件，先进先出的特殊文件类型</li></ul><h3 id="2-文件默认权限"><a href="#2-文件默认权限" class="headerlink" title="2. 文件默认权限"></a>2. 文件默认权限</h3><h4 id="umask-默认值需要减去的权限"><a href="#umask-默认值需要减去的权限" class="headerlink" title="umask    默认值需要减去的权限"></a>umask    默认值需要减去的权限</h4><ul><li>默认值-umask值&#x3D;建立文件目录时的默认权限（默认值：文件：-rw-rw-rw-  666  目录：drwxrwxrwx  777）</li><li>建议计算时用符号法计算，以免出错</li><li>root的umask值一般为022，一般用户为002</li></ul><h3 id="3-文件隐藏属性"><a href="#3-文件隐藏属性" class="headerlink" title="3. 文件隐藏属性"></a>3. 文件隐藏属性</h3><h4 id="lsattr-显示文件隐藏属性"><a href="#lsattr-显示文件隐藏属性" class="headerlink" title="lsattr    显示文件隐藏属性"></a>lsattr    显示文件隐藏属性</h4><p>选项：-adR  含义同ls中选项含义</p><h4 id="chattr-修改文件隐藏属性"><a href="#chattr-修改文件隐藏属性" class="headerlink" title="chattr    修改文件隐藏属性"></a>chattr    修改文件隐藏属性</h4><p>语法：chattr  [+-&#x3D;][aiS…]  file&#x2F;dir</p><h5 id="选项-17"><a href="#选项-17" class="headerlink" title="选项"></a>选项</h5><ul><li>a：文件只能增加数据，不能删除或修改数据（只有root可设置）</li><li>i：文件不能被删除、改名、修改、设置链接（只有root可设置）</li><li>S：对文件的修改会同步写入磁盘（无需sync）</li><li>xfs文件系统只支持AadiS属性，ext系列支持更多</li></ul><h3 id="4-文件特殊权限"><a href="#4-文件特殊权限" class="headerlink" title="4. 文件特殊权限"></a>4. 文件特殊权限</h3><h4 id="SUID"><a href="#SUID" class="headerlink" title="SUID"></a>SUID</h4><ul><li>s出现在拥有者的x位上，如-rwsr-xr-x</li><li>SUID权限仅对二进制程序（binary）有效，执行者对于该程序要有x的可执行权限，执行者将在执行该程序的过程中暂时具有该程序拥有者（owner）的权限</li><li>如一般用户执行passwd时，将暂时拥有root的权限，从而可修改&#x2F;etc&#x2F;shadow（只有root有w权限）中的密码</li></ul><h4 id="SGID"><a href="#SGID" class="headerlink" title="SGID"></a>SGID</h4><ul><li>s出现在用户组的x位上，如-rwx–s–x</li><li>对于二进制程序：执行者对于该程序要有x的可执行权限，执行者将在执行该程序的过程中暂时具有该程序所属用户组（group）的权限，如locate命令</li><li>对于目录：若用户在此目录下具有w权限（可新建文件），则用户所建立的新文件，该新文件的用户组与此目录的用户组相同</li><li>项目开发中有重要意义，如私房菜P208例子</li></ul><h4 id="SBIT"><a href="#SBIT" class="headerlink" title="SBIT"></a>SBIT</h4><ul><li>t出现在其他人的x位上，如drwxrwxrwt</li><li>SBIT仅对目录有效，用户对此目录有w、x权限，可新建文件或目录；当用户在该目录下建立文件或目录时，仅有自己与root才有权力删除该文件</li><li>如&#x2F;tmp权限为drwxrwxrwt，当甲在&#x2F;tmp下建立文件时只有甲与root可修改此文件</li></ul><h4 id="修改方式"><a href="#修改方式" class="headerlink" title="修改方式"></a>修改方式</h4><ul><li>4&#x3D;SUID，2&#x3D;SGID，1&#x3D;SBIT，如chmod  6755  test  加入SUID、SGID的权限</li><li>u+s&#x3D;SUID，g+s&#x3D;SGID，o+t&#x3D;SBIT，如chmod  u+s,g+s  test</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux笔记-常用命令-磁盘与文件系统管理</title>
    <link href="/posts/d21e.html"/>
    <url>/posts/d21e.html</url>
    
    <content type="html"><![CDATA[<h1 id="磁盘与文件系统管理"><a href="#磁盘与文件系统管理" class="headerlink" title="磁盘与文件系统管理"></a>磁盘与文件系统管理</h1><h2 id="1-文件系统管理"><a href="#1-文件系统管理" class="headerlink" title="1. 文件系统管理"></a>1. 文件系统管理</h2><h4 id="dumpe2fs-查看ext系列文件系统超级块信息"><a href="#dumpe2fs-查看ext系列文件系统超级块信息" class="headerlink" title="dumpe2fs    查看ext系列文件系统超级块信息"></a>dumpe2fs    查看ext系列文件系统超级块信息</h4><p>语法：dumpe2fs  [-h]  设备文件名</p><h5 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h5><ul><li>-h：仅列出超级块信息，不列出区块群组信息</li></ul><blockquote><p>Linux的文件系统通常分为数据存放区域（包括inode表和数据区块）和元数据区（包括超级区块、inode对照表、区块对照表）。ext2为传统文件系统，ext3&#x2F;4、xfs为日志式文件系统，能解决系统中止造成的元数据与数据存放区域不一致问题。</p></blockquote><h4 id="xfs-info-查看xfs文件系统信息"><a href="#xfs-info-查看xfs文件系统信息" class="headerlink" title="xfs_info    查看xfs文件系统信息"></a>xfs_info    查看xfs文件系统信息</h4><p>语法：xfs_info  设备文件名</p><h4 id="df-查看文件系统的空间使用情况"><a href="#df-查看文件系统的空间使用情况" class="headerlink" title="df    查看文件系统的空间使用情况"></a>df    查看文件系统的空间使用情况</h4><p>语法：df  [-ahiT]  file&#x2F;dir&#x2F;设备文件名（最后参数为文件&#x2F;目录时，显示该文件&#x2F;目录所在文件系统的使用情况）</p><h5 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h5><ul><li>-a：列出所有的文件系统，包括&#x2F;proc等</li><li>-h：将容量以人类较易读的方式显示</li><li>-i：不用磁盘容量，而以inode数量来显示</li><li>-T：显示文件系统的类型</li></ul><p>常用于查看文件系统（分区）的使用情况</p><h4 id="du-查看目录-文件的空间占用情况"><a href="#du-查看目录-文件的空间占用情况" class="headerlink" title="du    查看目录&#x2F;文件的空间占用情况"></a>du    查看目录&#x2F;文件的空间占用情况</h4><p>语法：du  [-ahsS]  file&#x2F;dir</p><h5 id="选项-2"><a href="#选项-2" class="headerlink" title="选项"></a>选项</h5><ul><li>-a：不仅列出所有子孙目录、该目录的大小，还列出所有文件的大小</li><li>-h：将容量以人类较易读的方式显示</li><li>-s：只列出该目录的大小总计，不列出文件与子目录</li><li>-S：对于所列出的每一个目录大小，只计算目录下的文件总计，不计算子目录大小</li></ul><p><strong>常用 [du  -sh  目录名] 查看单个目录大小</strong>，可以用  目录名&#x2F;*  查看一个目录下所有子目录的大小</p><blockquote><p>不加任何选项时，du只列出该目录下每个子目录（以及递归的所有子孙目录）与该目录的大小，不列出该目录下文件的大小。默认以1K为单位。</p></blockquote><p><img src="/../../img/1082.png"></p><h4 id="ln-建立链接文件"><a href="#ln-建立链接文件" class="headerlink" title="ln    建立链接文件"></a>ln    建立链接文件</h4><p>语法：ln  [-sf]  sourcefile  destinationfile</p><h5 id="选项-3"><a href="#选项-3" class="headerlink" title="选项"></a>选项</h5><ul><li>-s：建立符号链接，而非硬链接（不加-s，默认建立硬链接）</li><li>-f：强制，若目标文件已存在，主动将目标文件删除后再建立</li></ul><p><strong>硬链接</strong>（hard link）：多个文件名对应到同一个inode，即某个目录下新增一条文件名链接到inode号码的关联记录。占用磁盘空间和inode数都不会增加。源文件删除后链接仍可读取。但不能跨文件系统、链接目录。</p><p><strong>符号链接</strong>（symbolic link）：建立一个新文件，指向源文件的文件名。会增加磁盘空间和inode的占用。符号链接的大小（B）就是源文件名的字符数。源文件删除后链接不可读取。符号链接用途较广，可链接目录。</p><h2 id="2-磁盘管理"><a href="#2-磁盘管理" class="headerlink" title="2. 磁盘管理"></a>2. 磁盘管理</h2><h4 id="a-观察磁盘分区状态"><a href="#a-观察磁盘分区状态" class="headerlink" title="a. 观察磁盘分区状态"></a>a. 观察磁盘分区状态</h4><h5 id="lsblk-列出系统上所有的区块设备（常为磁盘）"><a href="#lsblk-列出系统上所有的区块设备（常为磁盘）" class="headerlink" title="lsblk    列出系统上所有的区块设备（常为磁盘）"></a>lsblk    列出系统上所有的区块设备（常为磁盘）</h5><p>lsblk与blkid输出区别见附图</p><p><img src="/../../img/lsblk_blkid.png" alt="img"></p><h5 id="blkid-列出区块设备的UUID、文件系统类型"><a href="#blkid-列出区块设备的UUID、文件系统类型" class="headerlink" title="blkid    列出区块设备的UUID、文件系统类型"></a>blkid    列出区块设备的UUID、文件系统类型</h5><h5 id="parted-设备文件名-print-列出磁盘的分区表类型（MBR-GPT）和分区信息"><a href="#parted-设备文件名-print-列出磁盘的分区表类型（MBR-GPT）和分区信息" class="headerlink" title="parted  设备文件名  print    列出磁盘的分区表类型（MBR&#x2F;GPT）和分区信息"></a>parted  设备文件名  print    列出磁盘的分区表类型（MBR&#x2F;GPT）和分区信息</h5><div class="note note-info">            <p><strong>对磁盘进行分区</strong>的步骤通常为：用lsblk或blkid找到磁盘，用parted print查看分区表类型，再根据类型选择gdisk或fdisk进行分区，partprobe更新内核信息，再用mkfs进行格式化，最后用mount进行挂载，写入&#x2F;etc&#x2F;fstab的相关行</p>          </div><div class="note note-info">            <p><strong>删除磁盘分区</strong>的步骤为：用umount卸载分区，删除&#x2F;etc&#x2F;fstab的相关行，用gdisk删除分区，partprobe更新内核信息</p>          </div><h4 id="b-进行磁盘分区"><a href="#b-进行磁盘分区" class="headerlink" title="b. 进行磁盘分区"></a>b. 进行磁盘分区</h4><h5 id="gdisk-对GPT分区表进行分区"><a href="#gdisk-对GPT分区表进行分区" class="headerlink" title="gdisk    对GPT分区表进行分区"></a>gdisk    对GPT分区表进行分区</h5><p>语法：gdisk  设备文件名</p><p>根据提示进行新增、删除、查看分区</p><blockquote><p>这里设备文件名不能加数字，分区是针对整个磁盘设备（如&#x2F;dev&#x2F;sda）而非某个分区或者说文件系统（如&#x2F;dev&#x2F;sda1）</p></blockquote><h5 id="partprobe-更新Linux内核的分区表信息"><a href="#partprobe-更新Linux内核的分区表信息" class="headerlink" title="partprobe    更新Linux内核的分区表信息"></a>partprobe    更新Linux内核的分区表信息</h5><p>进行分区或删除分区后要用partprobe更新分区表信息</p><h5 id="fdisk-对MBR分区表进行分区"><a href="#fdisk-对MBR分区表进行分区" class="headerlink" title="fdisk    对MBR分区表进行分区"></a>fdisk    对MBR分区表进行分区</h5><p>用法与gdisk相同</p><blockquote><p>注意GPT分区表要用gdisk，MBR分区表要用fdisk，不能搞错。处理分区时要先将文件系统卸载。</p></blockquote><h5 id="parted-同时支持GPT与MBR的分区"><a href="#parted-同时支持GPT与MBR的分区" class="headerlink" title="parted    同时支持GPT与MBR的分区"></a>parted    同时支持GPT与MBR的分区</h5><p>相比gdisk、fdisk，不必进行交互式操作，可用于脚本等，详见私房菜P256</p><h4 id="c-磁盘格式化（创建fs）"><a href="#c-磁盘格式化（创建fs）" class="headerlink" title="c. 磁盘格式化（创建fs）"></a>c. 磁盘格式化（创建fs）</h4><h5 id="mkfs-xfs-格式化为xfs文件系统"><a href="#mkfs-xfs-格式化为xfs文件系统" class="headerlink" title="mkfs.xfs    格式化为xfs文件系统"></a>mkfs.xfs    格式化为xfs文件系统</h5><p>语法：mkfs.xfs  设备文件名</p><p>具体选项见man，常用默认参数</p><blockquote><p>这里设备文件名要加数字，格式化是对一个分区（如&#x2F;dev&#x2F;sda1）进行格式化，创建文件系统</p></blockquote><h5 id="mkfs-ext4-格式化为ext4文件系统"><a href="#mkfs-ext4-格式化为ext4文件系统" class="headerlink" title="mkfs.ext4    格式化为ext4文件系统"></a>mkfs.ext4    格式化为ext4文件系统</h5><h4 id="d-文件系统检验"><a href="#d-文件系统检验" class="headerlink" title="d. 文件系统检验"></a>d. 文件系统检验</h4><h5 id="xfs-repair-检查与修复xfs文件系统"><a href="#xfs-repair-检查与修复xfs文件系统" class="headerlink" title="xfs_repair    检查与修复xfs文件系统"></a>xfs_repair    检查与修复xfs文件系统</h5><p>选项略</p><h5 id="fsck-ext4-检查与修复ext4文件系统"><a href="#fsck-ext4-检查与修复ext4文件系统" class="headerlink" title="fsck.ext4    检查与修复ext4文件系统"></a>fsck.ext4    检查与修复ext4文件系统</h5><h4 id="e-文件系统挂载与卸载"><a href="#e-文件系统挂载与卸载" class="headerlink" title="e. 文件系统挂载与卸载"></a>e. 文件系统挂载与卸载</h4><h5 id="mount-挂载文件系统"><a href="#mount-挂载文件系统" class="headerlink" title="mount    挂载文件系统"></a>mount    挂载文件系统</h5><p>语法：mount  [-al] 或 mount  [-o]  设备文件名&#x2F;UUID&#x3D;’  ‘  挂载点</p><h6 id="选项-4"><a href="#选项-4" class="headerlink" title="选项"></a>选项</h6><ul><li>-a：依照配置文件&#x2F;etc&#x2F;fstab的数据将所有未挂载的磁盘都挂载上来</li><li>-l：单纯的输入mount会显示目前挂载的信息，加上-l可增列Label名称</li><li>-o：后面可以接一些挂载时额外加上的参数，比方说账号、密码、读写权限等，参数见私房菜P243</li></ul><blockquote><p>一个<strong>文件系统</strong>（设备文件名&#x2F;分区）与一个<strong>挂载点</strong>（目录）应该一一对应。如果原目录非空，挂载后原文件会被暂时隐藏。一个磁盘（&#x2F;dev&#x2F;sda）进行分区后就分成了各分区（partition），各分区对应Linux中一个设备文件（&#x2F;dev&#x2F;sda1），对分区进行格式化后就成了文件系统（filesystem），最后将文件系统挂载（mount）在一个挂载点（目录）上，即可使用。</p></blockquote><blockquote><p>这里设备文件名要加数字，挂载是对文件系统&#x2F;分区而言。推荐使用UUID进行挂载，避免更换设备导致设备文件名不一致。</p></blockquote><h5 id="umount-卸载文件系统"><a href="#umount-卸载文件系统" class="headerlink" title="umount    卸载文件系统"></a>umount    卸载文件系统</h5><p>语法：umount  设备文件名&#x2F;挂载点</p><blockquote><p>要将工作目录退出文件系统后才能卸载该文件系统</p></blockquote><h5 id="特殊挂载"><a href="#特殊挂载" class="headerlink" title="特殊挂载"></a>特殊挂载</h5><h6 id="挂载CD-DVD"><a href="#挂载CD-DVD" class="headerlink" title="挂载CD&#x2F;DVD"></a>挂载CD&#x2F;DVD</h6><ul><li><p>mount  &#x2F;dev&#x2F;sr0  &#x2F;mnt&#x2F;cdrom</p></li><li><p>卸载光盘后才能退出光盘</p></li></ul><h6 id="挂载U盘（vfat）"><a href="#挂载U盘（vfat）" class="headerlink" title="挂载U盘（vfat）"></a>挂载U盘（vfat）</h6><ul><li><p>mount  -o  codepage&#x3D;950,iocharset&#x3D;utf8  UUID&#x3D;35BC-6D6B  &#x2F;mnt&#x2F;usb</p></li><li><p>其中的参数用于指定使用的语系</p></li></ul><h6 id="挂载CD-DVD镜像文件"><a href="#挂载CD-DVD镜像文件" class="headerlink" title="挂载CD&#x2F;DVD镜像文件"></a>挂载CD&#x2F;DVD镜像文件</h6><ul><li><p>mount  -o  loop  &#x2F;tmp&#x2F;xxx.iso   &#x2F;mnt&#x2F;iso</p></li><li><p>其中-o  loop参数表明挂载一个loop回环设备，详见私房菜P251</p></li></ul><h6 id="挂载loop设备文件"><a href="#挂载loop设备文件" class="headerlink" title="挂载loop设备文件"></a>挂载loop设备文件</h6><ul><li>效果：在原分区下，用一个大文件模拟划分出一个新分区</li><li>制作大型文件：dd  if&#x3D;&#x2F;dev&#x2F;zero  of&#x3D;&#x2F;tmp&#x2F;loopdev  bs&#x3D;1M  count&#x3D;512</li><li>格式化大型文件：mkfs.xfs  -f  &#x2F;tmp&#x2F;loopdev</li><li>挂载：mount  -o  loop  &#x2F;tmp&#x2F;loopdev  &#x2F;mnt&#x2F;loopdev</li></ul><blockquote><p>回环设备的用途：在原分区中划分出一个新分区、用文件模拟创建swap分区</p></blockquote><h6 id="重新挂载根目录"><a href="#重新挂载根目录" class="headerlink" title="重新挂载根目录"></a>重新挂载根目录</h6><ul><li><p>mount  -o  remount,rw,auto  &#x2F;</p></li><li><p>根目录不能被卸载。当你进入单人维护模式时，你的根目录常会被系统挂载为只读，这个时候这个命令就太重要了</p></li></ul><h5 id="启动挂载"><a href="#启动挂载" class="headerlink" title="启动挂载"></a>启动挂载</h5><p>若要设置系统启动时自动挂载文件系统，需修改配置文件&#x2F;etc&#x2F;fstab，详见私房菜P249</p><h4 id="f-参数自定义"><a href="#f-参数自定义" class="headerlink" title="f. 参数自定义"></a>f. 参数自定义</h4><h5 id="mknod-手动创建设备文件"><a href="#mknod-手动创建设备文件" class="headerlink" title="mknod    手动创建设备文件"></a>mknod    手动创建设备文件</h5><p>语法：mknod  设备文件名  [bcp]  [major]  [minor]</p><h6 id="选项-5"><a href="#选项-5" class="headerlink" title="选项"></a>选项</h6><ul><li><p>b：设置设备名称成为一个区块设备文件，例如磁盘等</p></li><li><p>c：设置设备名称成为一个字符设备文件，例如鼠标&#x2F;键盘等</p></li><li><p>p：设置设备名称成为一个管道文件</p></li><li><p>major：主要设备代码</p></li><li><p>minor：次要设备代码</p></li></ul><h5 id="xfs-admin-修改xfs文件系统的UUID与Label-name"><a href="#xfs-admin-修改xfs文件系统的UUID与Label-name" class="headerlink" title="xfs_admin    修改xfs文件系统的UUID与Label name"></a>xfs_admin    修改xfs文件系统的UUID与Label name</h5><p>语法：xfs_ admin  [-lu]  [-L label]  [-U uuid]  设备文件名</p><h6 id="选项-6"><a href="#选项-6" class="headerlink" title="选项"></a>选项</h6><ul><li><p>-l：列出这个设备的label name</p></li><li><p>-u：列出这个设备的UUID</p></li><li><p>-L：设置这个设备的Label name</p></li><li><p>-U：设置这个设备的UUID（UUID可用uuidgen命令生成）</p></li></ul><h5 id="tune2fs-修改ext4文件系统的UUID与Label-name"><a href="#tune2fs-修改ext4文件系统的UUID与Label-name" class="headerlink" title="tune2fs    修改ext4文件系统的UUID与Label name"></a>tune2fs    修改ext4文件系统的UUID与Label name</h5><p>用法与xfs_admin相同</p><h4 id="g-创建swap分区"><a href="#g-创建swap分区" class="headerlink" title="g. 创建swap分区"></a>g. 创建swap分区</h4><p>内存交换分区，用于内存不足时的暂存。不需要挂载到目录。</p><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul><li>1、分区：利用gdisk划分出一个swap分区，注意GUID设为8200</li><li>2、格式化：利用[mkswap  设备文件名]命令格式化为swap分区</li><li>3、启动：利用[swapon  设备文件名]命令启动swap分区</li><li>4、查看：利用free或swapon  -s命令观察内存使用情况</li><li>5、写入配置文件：&#x2F;etc&#x2F;fstab，挂载点写swap</li></ul><h5 id="用文件模拟创建swap分区"><a href="#用文件模拟创建swap分区" class="headerlink" title="用文件模拟创建swap分区"></a>用文件模拟创建swap分区</h5><p>利用回环设备，详见私房菜P254</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux笔记-常用命令</title>
    <link href="/posts/ee18.html"/>
    <url>/posts/ee18.html</url>
    
    <content type="html"><![CDATA[<p>（未编辑完整）</p><h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="startx-命令行下启动图形界面"><a href="#startx-命令行下启动图形界面" class="headerlink" title="startx    命令行下启动图形界面"></a>startx    命令行下启动图形界面</h3><h3 id="date-显示日期时间"><a href="#date-显示日期时间" class="headerlink" title="date    显示日期时间"></a>date    显示日期时间</h3><ul><li>格式化输出：如：date  +’%Y&#x2F;%m&#x2F;%d  %H:%M’     输出：2020&#x2F;07&#x2F;14 21:27</li></ul><h3 id="cal-显示日历"><a href="#cal-显示日历" class="headerlink" title="cal    显示日历"></a>cal    显示日历</h3><ul><li>语法：cal  [month]  [year]</li></ul><h3 id="bc-计算器"><a href="#bc-计算器" class="headerlink" title="bc    计算器"></a>bc    计算器</h3><ul><li><p>输入scale&#x3D;number设置小数点后保留位数   默认输出整数</p></li><li><p>输入quit退出计算器</p></li></ul><h2 id="在线求助命令"><a href="#在线求助命令" class="headerlink" title="在线求助命令"></a>在线求助命令</h2><h3 id="–help-显示简单的选项与参数说明"><a href="#–help-显示简单的选项与参数说明" class="headerlink" title="–help    显示简单的选项与参数说明"></a>–help    显示简单的选项与参数说明</h3><p>语法：命令  –help  如：date –help</p><h3 id="man-显示在线帮助手册"><a href="#man-显示在线帮助手册" class="headerlink" title="man    显示在线帮助手册"></a>man    显示在线帮助手册</h3><h4 id="手册中的几个重要部分"><a href="#手册中的几个重要部分" class="headerlink" title="手册中的几个重要部分"></a>手册中的几个重要部分</h4><ul><li>SYNOPSIS：命令的基本语法</li><li>DESCRIPTION：对命令的详细说明</li><li>OPTIONS：针对SYNOPSIS部分中，有列举的所有可用的选项说明</li><li>COMMANDS：当这个程序在执行的时候，可以在此程序中执行的命令</li><li>EXAMPLES：范例</li></ul><h4 id="首行代号含义"><a href="#首行代号含义" class="headerlink" title="首行代号含义"></a>首行代号含义</h4><ul><li>1：用户在shell环境中可以操作的命令或可执行文件</li><li>3：libc库中的函数</li><li>5：配置文件或是某些文件的格式</li><li>8：系统管理员可用的管理命令</li></ul><h4 id="可执行的命令"><a href="#可执行的命令" class="headerlink" title="可执行的命令"></a>可执行的命令</h4><ul><li>[Space]&#x2F;[PageDown]：向下翻一页</li><li>[PageUp]：向上翻一页</li><li>[Home]：去到第一页</li><li>[End]：去到最后一页</li><li>&#x2F;string：向下查找string这个字符串</li><li>?string：向上查找string这个字符串</li><li>n,N：利用&#x2F;或?来查找字符串时，可用n来继续下一个查找，用N来进行反向查找</li><li>q：离开man page</li></ul><p>还可以到&#x2F;usr&#x2F;share&#x2F;doc目录下查找某些软件的说明文件</p><h3 id="info-显示超链接式的手册"><a href="#info-显示超链接式的手册" class="headerlink" title="info    显示超链接式的手册"></a>info    显示超链接式的手册</h3><p>详见私房菜P139</p><h2 id="关机命令"><a href="#关机命令" class="headerlink" title="关机命令"></a>关机命令</h2><h3 id="sync-数据同步写入磁盘"><a href="#sync-数据同步写入磁盘" class="headerlink" title="sync    数据同步写入磁盘"></a>sync    数据同步写入磁盘</h3><p>将内存中尚未写入磁盘的数据写入磁盘</p><p>shutdown、reboot、halt等命令已默认在关机前执行sync</p><h3 id="shutdown-关机"><a href="#shutdown-关机" class="headerlink" title="shutdown    关机"></a>shutdown    关机</h3><p>语法：shutdown  [-krhc]  [时间]  [警告信息]</p><blockquote><p>时间参数可为：now、+分钟数、时：分</p><p>若不加时间参数，默认1分钟后执行操作</p></blockquote><h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><ul><li>-k：不关机，仅发送警告信息</li><li>-r：重新启动</li><li>-h：关机   <strong>关机操作必须由root执行</strong></li><li>-c：取消正在倒计时的shutdown计划</li></ul><h3 id="reboot-重启"><a href="#reboot-重启" class="headerlink" title="reboot    重启"></a>reboot    重启</h3><h3 id="halt-关机，停止系统"><a href="#halt-关机，停止系统" class="headerlink" title="halt    关机，停止系统"></a>halt    关机，停止系统</h3><h3 id="poweroff-关机，切断电源"><a href="#poweroff-关机，切断电源" class="headerlink" title="poweroff    关机，切断电源"></a>poweroff    关机，切断电源</h3><h3 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h3><h2 id="XFS文件系统备份与还原"><a href="#XFS文件系统备份与还原" class="headerlink" title="XFS文件系统备份与还原"></a>XFS文件系统备份与还原</h2><h3 id="xfsdump-备份xfs文件系统，可增量备份"><a href="#xfsdump-备份xfs文件系统，可增量备份" class="headerlink" title="xfsdump    备份xfs文件系统，可增量备份"></a>xfsdump    备份xfs文件系统，可增量备份</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><h5 id="xfsdump-l-L-S-label-M-M-label-f-备份后的文件名-待备份的文件系统目录名"><a href="#xfsdump-l-L-S-label-M-M-label-f-备份后的文件名-待备份的文件系统目录名" class="headerlink" title="xfsdump  -l  #  [-L  S_label]  [-M  M_label]  -f  备份后的文件名  待备份的文件系统目录名"></a>xfsdump  -l  #  [-L  S_label]  [-M  M_label]  -f  备份后的文件名  待备份的文件系统目录名</h5><h5 id="xfsdump-I"><a href="#xfsdump-I" class="headerlink" title="xfsdump  -I"></a>xfsdump  -I</h5><h4 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h4><h5 id="L：设置备份的session会话标头"><a href="#L：设置备份的session会话标头" class="headerlink" title="-L：设置备份的session会话标头"></a>-L：设置备份的session会话标头</h5><h5 id="M：设置备份的存储媒介标头"><a href="#M：设置备份的存储媒介标头" class="headerlink" title="-M：设置备份的存储媒介标头"></a>-M：设置备份的存储媒介标头</h5><h5 id="l：小写L，后接数字，指定备份等级（0-9），默认为0"><a href="#l：小写L，后接数字，指定备份等级（0-9），默认为0" class="headerlink" title="-l：小写L，后接数字，指定备份等级（0~9），默认为0"></a>-l：小写L，后接数字，指定备份等级（0~9），默认为0</h5><h5 id="f：接备份后的文件名"><a href="#f：接备份后的文件名" class="headerlink" title="-f：接备份后的文件名"></a>-f：接备份后的文件名</h5><h5 id="I：大写i，从-var-lib-xfsdump-inventory列出目前备份的信息状态"><a href="#I：大写i，从-var-lib-xfsdump-inventory列出目前备份的信息状态" class="headerlink" title="-I：大写i，从&#x2F;var&#x2F;lib&#x2F;xfsdump&#x2F;inventory列出目前备份的信息状态"></a>-I：大写i，从&#x2F;var&#x2F;lib&#x2F;xfsdump&#x2F;inventory列出目前备份的信息状态</h5><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="level-0完整备份-boot：xfsdump-l-0-L-boot-all-S-boot-all-f-srv-boot-dump-boot"><a href="#level-0完整备份-boot：xfsdump-l-0-L-boot-all-S-boot-all-f-srv-boot-dump-boot" class="headerlink" title="level 0完整备份&#x2F;boot：xfsdump  -l  0  -L  boot_all  -S  boot_all  -f  &#x2F;srv&#x2F;boot.dump  &#x2F;boot"></a>level 0完整备份&#x2F;boot：xfsdump  -l  0  -L  boot_all  -S  boot_all  -f  &#x2F;srv&#x2F;boot.dump  &#x2F;boot</h5><h5 id="level-1增量备份-boot：xfsdump-l-1-L-boot-2-S-boot-2-f-srv-boot-dump1-boot"><a href="#level-1增量备份-boot：xfsdump-l-1-L-boot-2-S-boot-2-f-srv-boot-dump1-boot" class="headerlink" title="level 1增量备份&#x2F;boot：xfsdump  -l  1  -L  boot_2  -S  boot_2  -f  &#x2F;srv&#x2F;boot.dump1   &#x2F;boot"></a>level 1增量备份&#x2F;boot：xfsdump  -l  1  -L  boot_2  -S  boot_2  -f  &#x2F;srv&#x2F;boot.dump1   &#x2F;boot</h5><h5 id="查看备份信息：xfsdump-I"><a href="#查看备份信息：xfsdump-I" class="headerlink" title="查看备份信息：xfsdump  -I"></a>查看备份信息：xfsdump  -I</h5><h3 id="xfsrestore-恢复dump备份"><a href="#xfsrestore-恢复dump备份" class="headerlink" title="xfsrestore    恢复dump备份"></a>xfsrestore    恢复dump备份</h3><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><h5 id="xfsrestore-I"><a href="#xfsrestore-I" class="headerlink" title="xfsrestore  -I"></a>xfsrestore  -I</h5><h5 id="xfsrestore-f-备份后的文件名-L-S-label-s-file-dir-待恢复目录"><a href="#xfsrestore-f-备份后的文件名-L-S-label-s-file-dir-待恢复目录" class="headerlink" title="xfsrestore  -f  备份后的文件名   [-L  S_label]   [-s  file&#x2F;dir]   待恢复目录"></a>xfsrestore  -f  备份后的文件名   [-L  S_label]   [-s  file&#x2F;dir]   待恢复目录</h5><h4 id="选项-2"><a href="#选项-2" class="headerlink" title="选项"></a>选项</h4><h5 id="I：大写i，从-var-lib-xfsdump-inventory列出目前备份的信息状态-1"><a href="#I：大写i，从-var-lib-xfsdump-inventory列出目前备份的信息状态-1" class="headerlink" title="-I：大写i，从&#x2F;var&#x2F;lib&#x2F;xfsdump&#x2F;inventory列出目前备份的信息状态"></a>-I：大写i，从&#x2F;var&#x2F;lib&#x2F;xfsdump&#x2F;inventory列出目前备份的信息状态</h5><h5 id="f：接备份后的文件名-1"><a href="#f：接备份后的文件名-1" class="headerlink" title="-f：接备份后的文件名"></a>-f：接备份后的文件名</h5><h5 id="L：选择备份的session会话标头"><a href="#L：选择备份的session会话标头" class="headerlink" title="-L：选择备份的session会话标头"></a>-L：选择备份的session会话标头</h5><h5 id="s：接某个目录或文件，仅恢复某个目录或文件"><a href="#s：接某个目录或文件，仅恢复某个目录或文件" class="headerlink" title="-s：接某个目录或文件，仅恢复某个目录或文件"></a>-s：接某个目录或文件，仅恢复某个目录或文件</h5><h5 id="i：进入交互模式"><a href="#i：进入交互模式" class="headerlink" title="-i：进入交互模式"></a>-i：进入交互模式</h5><h3 id="mkisofs-建立镜像文件"><a href="#mkisofs-建立镜像文件" class="headerlink" title="mkisofs    建立镜像文件"></a>mkisofs    建立镜像文件</h3><h3 id="cdrecord-光盘刻录工具"><a href="#cdrecord-光盘刻录工具" class="headerlink" title="cdrecord    光盘刻录工具"></a>cdrecord    光盘刻录工具</h3><h3 id="dd-按块复制-备份文件"><a href="#dd-按块复制-备份文件" class="headerlink" title="dd    按块复制&#x2F;备份文件"></a>dd    按块复制&#x2F;备份文件</h3><h4 id="语法：dd-if-inputfile-of-outputfile-bs-block-size-count-number"><a href="#语法：dd-if-inputfile-of-outputfile-bs-block-size-count-number" class="headerlink" title="语法：dd  if&#x3D;inputfile  of&#x3D;outputfile  [bs&#x3D;block_size]  [count&#x3D;number]"></a>语法：dd  if&#x3D;inputfile  of&#x3D;outputfile  [bs&#x3D;block_size]  [count&#x3D;number]</h4><h4 id="选项-3"><a href="#选项-3" class="headerlink" title="选项"></a>选项</h4><h5 id="if：输入文件"><a href="#if：输入文件" class="headerlink" title="if：输入文件"></a>if：输入文件</h5><h5 id="of：输出文件"><a href="#of：输出文件" class="headerlink" title="of：输出文件"></a>of：输出文件</h5><h5 id="bs：block大小，默认512B"><a href="#bs：block大小，默认512B" class="headerlink" title="bs：block大小，默认512B"></a>bs：block大小，默认512B</h5><h5 id="count：block的数量"><a href="#count：block的数量" class="headerlink" title="count：block的数量"></a>count：block的数量</h5><h4 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h4><h5 id="制作loop回环设备文件：dd-if-dev-zero-of-tmp-loopdev-bs-1M-count-512"><a href="#制作loop回环设备文件：dd-if-dev-zero-of-tmp-loopdev-bs-1M-count-512" class="headerlink" title="制作loop回环设备文件：dd  if&#x3D;&#x2F;dev&#x2F;zero  of&#x3D;&#x2F;tmp&#x2F;loopdev  bs&#x3D;1M  count&#x3D;512"></a>制作loop回环设备文件：dd  if&#x3D;&#x2F;dev&#x2F;zero  of&#x3D;&#x2F;tmp&#x2F;loopdev  bs&#x3D;1M  count&#x3D;512</h5><h5 id="完整备份一个磁盘（或分区）到另一个磁盘：dd-if-dev-sda1-of-dev-vda2（详见私房菜P283）"><a href="#完整备份一个磁盘（或分区）到另一个磁盘：dd-if-dev-sda1-of-dev-vda2（详见私房菜P283）" class="headerlink" title="完整备份一个磁盘（或分区）到另一个磁盘：dd  if&#x3D;&#x2F;dev&#x2F;sda1  of&#x3D;&#x2F;dev&#x2F;vda2（详见私房菜P283）"></a>完整备份一个磁盘（或分区）到另一个磁盘：dd  if&#x3D;&#x2F;dev&#x2F;sda1  of&#x3D;&#x2F;dev&#x2F;vda2（详见私房菜P283）</h5><h5 id="将磁盘-光盘-u盘备份到文件：dd-if-dev-sr0-of-tmp-backup-iso"><a href="#将磁盘-光盘-u盘备份到文件：dd-if-dev-sr0-of-tmp-backup-iso" class="headerlink" title="将磁盘&#x2F;光盘&#x2F;u盘备份到文件：dd  if&#x3D;&#x2F;dev&#x2F;sr0  of&#x3D;&#x2F;tmp&#x2F;backup.iso"></a>将磁盘&#x2F;光盘&#x2F;u盘备份到文件：dd  if&#x3D;&#x2F;dev&#x2F;sr0  of&#x3D;&#x2F;tmp&#x2F;backup.iso</h5><h5 id="测试磁盘速度：dd-if-dev-zero-of-tmp-1GB-file-bs-1024-count-1000000"><a href="#测试磁盘速度：dd-if-dev-zero-of-tmp-1GB-file-bs-1024-count-1000000" class="headerlink" title="测试磁盘速度：dd  if&#x3D;&#x2F;dev&#x2F;zero  of&#x3D;&#x2F;tmp&#x2F;1GB.file  bs&#x3D;1024  count&#x3D;1000000"></a>测试磁盘速度：dd  if&#x3D;&#x2F;dev&#x2F;zero  of&#x3D;&#x2F;tmp&#x2F;1GB.file  bs&#x3D;1024  count&#x3D;1000000</h5><h3 id="cpio-备份任何文件，包括设备文件"><a href="#cpio-备份任何文件，包括设备文件" class="headerlink" title="cpio    备份任何文件，包括设备文件"></a>cpio    备份任何文件，包括设备文件</h3><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><h5 id="备份：find-待备份目录-cpio-ocvB-备份后文件-设备文件名"><a href="#备份：find-待备份目录-cpio-ocvB-备份后文件-设备文件名" class="headerlink" title="备份：find  待备份目录  |  cpio  -ocvB  &gt;  备份后文件&#x2F;设备文件名"></a>备份：find  待备份目录  |  cpio  -ocvB  &gt;  备份后文件&#x2F;设备文件名</h5><h5 id="还原：cpio-idvc-备份后文件-设备文件名"><a href="#还原：cpio-idvc-备份后文件-设备文件名" class="headerlink" title="还原：cpio  -idvc  &lt;  备份后文件&#x2F;设备文件名"></a>还原：cpio  -idvc  &lt;  备份后文件&#x2F;设备文件名</h5><h2 id="Bash-shell"><a href="#Bash-shell" class="headerlink" title="Bash shell"></a>Bash shell</h2><h3 id="type-查询命令是否为shell的内置命令"><a href="#type-查询命令是否为shell的内置命令" class="headerlink" title="type    查询命令是否为shell的内置命令"></a>type    查询命令是否为shell的内置命令</h3><h3 id="ulimit-限制用户可用的系统资源"><a href="#ulimit-限制用户可用的系统资源" class="headerlink" title="ulimit    限制用户可用的系统资源"></a>ulimit    限制用户可用的系统资源</h3><h4 id="详见私房菜P329"><a href="#详见私房菜P329" class="headerlink" title="详见私房菜P329"></a>详见私房菜P329</h4><h3 id="alias-设置命令别名"><a href="#alias-设置命令别名" class="headerlink" title="alias    设置命令别名"></a>alias    设置命令别名</h3><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><h5 id="设置别名：alias-别名-’命令’"><a href="#设置别名：alias-别名-’命令’" class="headerlink" title="设置别名：alias  别名&#x3D;’命令’"></a>设置别名：alias  别名&#x3D;’命令’</h5><h5 id="显示所有已设置的别名：alias"><a href="#显示所有已设置的别名：alias" class="headerlink" title="显示所有已设置的别名：alias"></a>显示所有已设置的别名：alias</h5><h4 id="删除别名：unalias"><a href="#删除别名：unalias" class="headerlink" title="删除别名：unalias"></a>删除别名：unalias</h4><h3 id="history-命令历史"><a href="#history-命令历史" class="headerlink" title="history    命令历史"></a>history    命令历史</h3><h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><h5 id="显示缓存中的历史：history"><a href="#显示缓存中的历史：history" class="headerlink" title="显示缓存中的历史：history"></a>显示缓存中的历史：history</h5><h5 id="列出最近的n条历史：history-n"><a href="#列出最近的n条历史：history-n" class="headerlink" title="列出最近的n条历史：history  n"></a>列出最近的n条历史：history  n</h5><h5 id="执行第n条历史：-n"><a href="#执行第n条历史：-n" class="headerlink" title="执行第n条历史：!n"></a>执行第n条历史：!n</h5><h5 id="执行上一条命令："><a href="#执行上一条命令：" class="headerlink" title="执行上一条命令：!!"></a>执行上一条命令：!!</h5><h5 id="由最近历史向前查找以command开头的命令，并执行：-command"><a href="#由最近历史向前查找以command开头的命令，并执行：-command" class="headerlink" title="由最近历史向前查找以command开头的命令，并执行：!command"></a>由最近历史向前查找以command开头的命令，并执行：!command</h5><h3 id="source-读取配置文件"><a href="#source-读取配置文件" class="headerlink" title="source    读取配置文件"></a>source    读取配置文件</h3><h4 id="语法：source-配置文件（也可用小数点-来代替source，如-bashrc，中间有空格）"><a href="#语法：source-配置文件（也可用小数点-来代替source，如-bashrc，中间有空格）" class="headerlink" title="语法：source  配置文件（也可用小数点 . 来代替source，如 .  ~&#x2F;.bashrc，中间有空格）"></a>语法：source  配置文件（也可用小数点 . 来代替source，如 .  ~&#x2F;.bashrc，中间有空格）</h4><h4 id="为所有用户配置bash：在-etc-profile-d-目录下建立-sh文件，写入要配置的别名、变量、环境变量（要用export转为环境变量）、配置等"><a href="#为所有用户配置bash：在-etc-profile-d-目录下建立-sh文件，写入要配置的别名、变量、环境变量（要用export转为环境变量）、配置等" class="headerlink" title="为所有用户配置bash：在&#x2F;etc&#x2F;profile.d&#x2F;目录下建立*.sh文件，写入要配置的别名、变量、环境变量（要用export转为环境变量）、配置等"></a>为所有用户配置bash：在&#x2F;etc&#x2F;profile.d&#x2F;目录下建立*.sh文件，写入要配置的别名、变量、环境变量（要用export转为环境变量）、配置等</h4><h4 id="为个别用户配置bash：修改-bashrc文件"><a href="#为个别用户配置bash：修改-bashrc文件" class="headerlink" title="为个别用户配置bash：修改~&#x2F;.bashrc文件"></a>为个别用户配置bash：修改~&#x2F;.bashrc文件</h4><h3 id="变量相关"><a href="#变量相关" class="headerlink" title="变量相关"></a>变量相关</h3><h4 id="echo-输出变量"><a href="#echo-输出变量" class="headerlink" title="echo    输出变量"></a>echo    输出变量</h4><h5 id="语法：echo-PATH-或-echo-PATH"><a href="#语法：echo-PATH-或-echo-PATH" class="headerlink" title="语法：echo  $PATH 或 echo  ${PATH}"></a>语法：echo  $PATH 或 echo  ${PATH}</h5><h5 id="echo-e-可以使用反斜杠的特殊字符，如-n、-t"><a href="#echo-e-可以使用反斜杠的特殊字符，如-n、-t" class="headerlink" title="echo  -e 可以使用反斜杠的特殊字符，如\n、\t"></a>echo  -e 可以使用反斜杠的特殊字符，如\n、\t</h5><h5 id="变量设置规则"><a href="#变量设置规则" class="headerlink" title="变量设置规则"></a>变量设置规则</h5><h6 id="设置变量时用等号连接，如：myname-vbird"><a href="#设置变量时用等号连接，如：myname-vbird" class="headerlink" title="设置变量时用等号连接，如：myname&#x3D;vbird"></a>设置变量时用等号连接，如：myname&#x3D;vbird</h6><h6 id="变量名不能以数字开头"><a href="#变量名不能以数字开头" class="headerlink" title="变量名不能以数字开头"></a>变量名不能以数字开头</h6><h6 id="等号两边不能直接出现空格，如：myname-vbird-as是错的"><a href="#等号两边不能直接出现空格，如：myname-vbird-as是错的" class="headerlink" title="等号两边不能直接出现空格，如：myname&#x3D;vbird as是错的"></a>等号两边不能直接出现空格，如：myname&#x3D;vbird as是错的</h6><h6 id="变量内容若有空格可用单引号或双引号，双引号中的特殊字符保留原本功能，单引号中的特殊字符仅为一般字符，如var-”lang-is-LANG”，-LANG替换为变量内容"><a href="#变量内容若有空格可用单引号或双引号，双引号中的特殊字符保留原本功能，单引号中的特殊字符仅为一般字符，如var-”lang-is-LANG”，-LANG替换为变量内容" class="headerlink" title="变量内容若有空格可用单引号或双引号，双引号中的特殊字符保留原本功能，单引号中的特殊字符仅为一般字符，如var&#x3D;”lang is $LANG”，$LANG替换为变量内容"></a>变量内容若有空格可用单引号或双引号，双引号中的特殊字符保留原本功能，单引号中的特殊字符仅为一般字符，如var&#x3D;”lang is $LANG”，$LANG替换为变量内容</h6><h6 id="可用反斜杠-将特殊字符-Enter-、-、-、空格、’-转义为一般字符，如：myname-vbird-tsai"><a href="#可用反斜杠-将特殊字符-Enter-、-、-、空格、’-转义为一般字符，如：myname-vbird-tsai" class="headerlink" title="可用反斜杠\将特殊字符( [Enter]、$、\、空格、’ )转义为一般字符，如：myname&#x3D;vbird\  tsai"></a>可用反斜杠\将特殊字符( [Enter]、$、\、空格、’ )转义为一般字符，如：myname&#x3D;vbird\  tsai</h6><h6 id="若要扩增变量内容，可以如：PATH-”-PATH”-home-bin-或-PATH-PATH-home-bin"><a href="#若要扩增变量内容，可以如：PATH-”-PATH”-home-bin-或-PATH-PATH-home-bin" class="headerlink" title="若要扩增变量内容，可以如：PATH&#x3D;”$PATH”:&#x2F;home&#x2F;bin 或 PATH&#x3D;${PATH}:&#x2F;home&#x2F;bin"></a>若要扩增变量内容，可以如：PATH&#x3D;”$PATH”:&#x2F;home&#x2F;bin 或 PATH&#x3D;${PATH}:&#x2F;home&#x2F;bin</h6><h6 id="若要获得额外的命令所提供的信息时，可用-命令-，如：version-uname-r"><a href="#若要获得额外的命令所提供的信息时，可用-命令-，如：version-uname-r" class="headerlink" title="若要获得额外的命令所提供的信息时，可用 $(命令) ，如：version&#x3D;$(uname -r)"></a>若要获得额外的命令所提供的信息时，可用 $(命令) ，如：version&#x3D;$(uname -r)</h6><h6 id="可使用unset取消变量，如：unset-myname"><a href="#可使用unset取消变量，如：unset-myname" class="headerlink" title="可使用unset取消变量，如：unset  myname"></a>可使用unset取消变量，如：unset  myname</h6><h6 id="变量的数值计算，用-运算式-，如-total-firstnu-secnu-，但bash中数值计算最多只能到整数"><a href="#变量的数值计算，用-运算式-，如-total-firstnu-secnu-，但bash中数值计算最多只能到整数" class="headerlink" title="变量的数值计算，用$((运算式))，如 total&#x3D;$((  ${firstnu}*${ secnu}  ))，但bash中数值计算最多只能到整数"></a>变量的数值计算，用$((运算式))，如 total&#x3D;$((  ${firstnu}*${ secnu}  ))，但bash中数值计算最多只能到整数</h6><h4 id="env-显示所有环境变量"><a href="#env-显示所有环境变量" class="headerlink" title="env    显示所有环境变量"></a>env    显示所有环境变量</h4><h5 id="bash中一些特殊的变量，详见私房菜P322-324"><a href="#bash中一些特殊的变量，详见私房菜P322-324" class="headerlink" title="bash中一些特殊的变量，详见私房菜P322-324"></a>bash中一些特殊的变量，详见私房菜P322-324</h5><h4 id="set-显示所有环境变量与自定义变量"><a href="#set-显示所有环境变量与自定义变量" class="headerlink" title="set    显示所有环境变量与自定义变量"></a>set    显示所有环境变量与自定义变量</h4><h4 id="export-自定义变量转成环境变量"><a href="#export-自定义变量转成环境变量" class="headerlink" title="export    自定义变量转成环境变量"></a>export    自定义变量转成环境变量</h4><h5 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h5><h6 id="export-myname"><a href="#export-myname" class="headerlink" title="export  myname"></a>export  myname</h6><h6 id="显示所有环境变量：export"><a href="#显示所有环境变量：export" class="headerlink" title="显示所有环境变量：export"></a>显示所有环境变量：export</h6><h4 id="locale-显示当前的语系变量的设置"><a href="#locale-显示当前的语系变量的设置" class="headerlink" title="locale    显示当前的语系变量的设置"></a>locale    显示当前的语系变量的设置</h4><h5 id="locale-a-显示系统支持的所有语系"><a href="#locale-a-显示系统支持的所有语系" class="headerlink" title="locale  -a 显示系统支持的所有语系"></a>locale  -a 显示系统支持的所有语系</h5><h5 id="出现乱码问题，通常需要修改语系，只需修改LANG和LC-ALL这两个环境变量，其他语系变量就会被覆盖，例：LANG-en-US-UTF-8-；-export-LC-ALL-en-US-UTF-8"><a href="#出现乱码问题，通常需要修改语系，只需修改LANG和LC-ALL这两个环境变量，其他语系变量就会被覆盖，例：LANG-en-US-UTF-8-；-export-LC-ALL-en-US-UTF-8" class="headerlink" title="出现乱码问题，通常需要修改语系，只需修改LANG和LC_ALL这两个环境变量，其他语系变量就会被覆盖，例：LANG&#x3D;en_US.UTF-8 ； export  LC_ALL&#x3D;en_US.UTF-8"></a>出现乱码问题，通常需要修改语系，只需修改LANG和LC_ALL这两个环境变量，其他语系变量就会被覆盖，例：LANG&#x3D;en_US.UTF-8 ； export  LC_ALL&#x3D;en_US.UTF-8</h5><h5 id="常用语系：中文：zh-CN-GB2312、zh-CN-UTF-8、英文：en-US-UTF-8"><a href="#常用语系：中文：zh-CN-GB2312、zh-CN-UTF-8、英文：en-US-UTF-8" class="headerlink" title="常用语系：中文：zh_CN.GB2312、zh_CN.UTF-8、英文：en_US.UTF-8"></a>常用语系：中文：zh_CN.GB2312、zh_CN.UTF-8、英文：en_US.UTF-8</h5><h4 id="read-读取来自键盘输入的变量"><a href="#read-读取来自键盘输入的变量" class="headerlink" title="read   读取来自键盘输入的变量"></a>read   读取来自键盘输入的变量</h4><h5 id="语法：read-pt-变量"><a href="#语法：read-pt-变量" class="headerlink" title="语法：read  [-pt]  变量"></a>语法：read  [-pt]  变量</h5><h5 id="选项-4"><a href="#选项-4" class="headerlink" title="选项"></a>选项</h5><h6 id="p：后接提示字符"><a href="#p：后接提示字符" class="headerlink" title="-p：后接提示字符"></a>-p：后接提示字符</h6><h6 id="t：后接等待的秒数"><a href="#t：后接等待的秒数" class="headerlink" title="-t：后接等待的秒数"></a>-t：后接等待的秒数</h6><h4 id="declare-声明变量的类型"><a href="#declare-声明变量的类型" class="headerlink" title="declare    声明变量的类型"></a>declare    声明变量的类型</h4><h5 id="语法：declare-aixr-变量"><a href="#语法：declare-aixr-变量" class="headerlink" title="语法：declare  [-aixr]  变量"></a>语法：declare  [-aixr]  变量</h5><h5 id="选项-5"><a href="#选项-5" class="headerlink" title="选项"></a>选项</h5><h6 id="a：声明为数组类型"><a href="#a：声明为数组类型" class="headerlink" title="-a：声明为数组类型"></a>-a：声明为数组类型</h6><h6 id="i：声明为整数类型"><a href="#i：声明为整数类型" class="headerlink" title="-i：声明为整数类型"></a>-i：声明为整数类型</h6><h6 id="x：声明为环境变量"><a href="#x：声明为环境变量" class="headerlink" title="-x：声明为环境变量"></a>-x：声明为环境变量</h6><h6 id="r：设置为只读类型，不可修改和unset"><a href="#r：设置为只读类型，不可修改和unset" class="headerlink" title="-r：设置为只读类型，不可修改和unset"></a>-r：设置为只读类型，不可修改和unset</h6><h5 id="环境变量转为自定义变量：declare-x-变量"><a href="#环境变量转为自定义变量：declare-x-变量" class="headerlink" title="环境变量转为自定义变量：declare  +x  变量"></a>环境变量转为自定义变量：declare  +x  变量</h5><h5 id="与typeset用法相同"><a href="#与typeset用法相同" class="headerlink" title="与typeset用法相同"></a>与typeset用法相同</h5><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><h4 id="：匹配任意0到无穷多个字符"><a href="#：匹配任意0到无穷多个字符" class="headerlink" title="*：匹配任意0到无穷多个字符"></a>*：匹配任意0到无穷多个字符</h4><h4 id="？：匹配1个字符"><a href="#？：匹配1个字符" class="headerlink" title="？：匹配1个字符"></a>？：匹配1个字符</h4><h4 id="：匹配指定字符范围内的任意个字符，如-abcd"><a href="#：匹配指定字符范围内的任意个字符，如-abcd" class="headerlink" title="[ ]：匹配指定字符范围内的任意个字符，如[abcd]"></a>[ ]：匹配指定字符范围内的任意个字符，如[abcd]</h4><h4 id="：匹配在编码顺序内的所有字符，如-0-9"><a href="#：匹配在编码顺序内的所有字符，如-0-9" class="headerlink" title="[  -  ]：匹配在编码顺序内的所有字符，如[0-9]"></a>[  -  ]：匹配在编码顺序内的所有字符，如[0-9]</h4><h4 id="：表示反向选择，如-abc-表示非a、b、c的其他字符"><a href="#：表示反向选择，如-abc-表示非a、b、c的其他字符" class="headerlink" title="[^   ]：表示反向选择，如[^abc]表示非a、b、c的其他字符"></a>[^   ]：表示反向选择，如[^abc]表示非a、b、c的其他字符</h4><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><h4 id="：注释符号，shell脚本中同"><a href="#：注释符号，shell脚本中同" class="headerlink" title="#：注释符号，shell脚本中同"></a>#：注释符号，shell脚本中同</h4><h4 id="：转义符，将通配符或特殊字符转为一般字符"><a href="#：转义符，将通配符或特殊字符转为一般字符" class="headerlink" title="\：转义符，将通配符或特殊字符转为一般字符"></a>\：转义符，将通配符或特殊字符转为一般字符</h4><h4 id="：管道符"><a href="#：管道符" class="headerlink" title="| ：管道符"></a>| ：管道符</h4><h4 id="；：连续命令执行符"><a href="#；：连续命令执行符" class="headerlink" title="；：连续命令执行符"></a>；：连续命令执行符</h4><h4 id="与-：具有相关性的命令执行的判断"><a href="#与-：具有相关性的命令执行的判断" class="headerlink" title="&amp;&amp;与 || ：具有相关性的命令执行的判断"></a>&amp;&amp;与 || ：具有相关性的命令执行的判断</h4><h4 id="：用户家目录"><a href="#：用户家目录" class="headerlink" title="~：用户家目录"></a>~：用户家目录</h4><h4 id="：变量前导符"><a href="#：变量前导符" class="headerlink" title="$：变量前导符"></a>$：变量前导符</h4><h4 id="：任务管理"><a href="#：任务管理" class="headerlink" title="&amp;：任务管理"></a>&amp;：任务管理</h4><h4 id="！：逻辑运算的非"><a href="#！：逻辑运算的非" class="headerlink" title="！：逻辑运算的非"></a>！：逻辑运算的非</h4><h4 id="：路径分隔符号"><a href="#：路径分隔符号" class="headerlink" title="&#x2F;  ：路径分隔符号"></a>&#x2F;  ：路径分隔符号</h4><h4 id="与-与"><a href="#与-与" class="headerlink" title="&gt;与&gt;&gt;与&lt;与&lt;&lt;：数据流重定向"></a>&gt;与&gt;&gt;与&lt;与&lt;&lt;：数据流重定向</h4><h4 id="‘’-：单引号，其中的特殊字符仅为一般字符，如-PATH不会进行替换"><a href="#‘’-：单引号，其中的特殊字符仅为一般字符，如-PATH不会进行替换" class="headerlink" title="‘’ ：单引号，其中的特殊字符仅为一般字符，如$PATH不会进行替换"></a>‘’ ：单引号，其中的特殊字符仅为一般字符，如$PATH不会进行替换</h4><h4 id="“”：双引号，其中的特殊字符保留原本功能，如-PATH会进行替换，若单纯要输入-要用转义符"><a href="#“”：双引号，其中的特殊字符保留原本功能，如-PATH会进行替换，若单纯要输入-要用转义符" class="headerlink" title="“”：双引号，其中的特殊字符保留原本功能，如$PATH会进行替换，若单纯要输入$要用转义符"></a>“”：双引号，其中的特殊字符保留原本功能，如$PATH会进行替换，若单纯要输入$要用转义符</h4><h4 id="：子shell的起始与结束"><a href="#：子shell的起始与结束" class="headerlink" title="( )：子shell的起始与结束"></a>( )：子shell的起始与结束</h4><h4 id="：引用额外命令提供的信息进行替换"><a href="#：引用额外命令提供的信息进行替换" class="headerlink" title="$()：引用额外命令提供的信息进行替换"></a>$()：引用额外命令提供的信息进行替换</h4><h4 id="：用于一串命令执行时，-中的命令会在当前shell中执行，也可以用于变量变形与替换"><a href="#：用于一串命令执行时，-中的命令会在当前shell中执行，也可以用于变量变形与替换" class="headerlink" title="{ }：用于一串命令执行时，{}中的命令会在当前shell中执行，也可以用于变量变形与替换"></a>{ }：用于一串命令执行时，{}中的命令会在当前shell中执行，也可以用于变量变形与替换</h4><h3 id="数据流重定向"><a href="#数据流重定向" class="headerlink" title="数据流重定向"></a>数据流重定向</h3><h4 id="：覆盖地重定向标准输出到文件"><a href="#：覆盖地重定向标准输出到文件" class="headerlink" title="&gt;：覆盖地重定向标准输出到文件"></a>&gt;：覆盖地重定向标准输出到文件</h4><h4 id="：累加地重定向标准输出到文件"><a href="#：累加地重定向标准输出到文件" class="headerlink" title="&gt;&gt;：累加地重定向标准输出到文件"></a>&gt;&gt;：累加地重定向标准输出到文件</h4><h4 id="2-：覆盖地重定向标准错误输出到文件"><a href="#2-：覆盖地重定向标准错误输出到文件" class="headerlink" title="2&gt;：覆盖地重定向标准错误输出到文件"></a>2&gt;：覆盖地重定向标准错误输出到文件</h4><h4 id="2-：累加地重定向标准错误输出到文件"><a href="#2-：累加地重定向标准错误输出到文件" class="headerlink" title="2&gt;&gt;：累加地重定向标准错误输出到文件"></a>2&gt;&gt;：累加地重定向标准错误输出到文件</h4><h4 id=""><a href="#" class="headerlink" title="&lt;：由键盘输入的数据，改由文件输入"></a>&lt;：由键盘输入的数据，改由文件输入</h4><h4 id="-1"><a href="#-1" class="headerlink" title="&lt;&lt;：设置结束的输入字符"></a>&lt;&lt;：设置结束的输入字符</h4><h4 id="dev-null：黑洞设备，丢弃任何导向这个设备的数据"><a href="#dev-null：黑洞设备，丢弃任何导向这个设备的数据" class="headerlink" title="&#x2F;dev&#x2F;null：黑洞设备，丢弃任何导向这个设备的数据"></a>&#x2F;dev&#x2F;null：黑洞设备，丢弃任何导向这个设备的数据</h4><h4 id="若要将标准输出与错误输出写到同一个文件，可以用-list-2-1"><a href="#若要将标准输出与错误输出写到同一个文件，可以用-list-2-1" class="headerlink" title="若要将标准输出与错误输出写到同一个文件，可以用  &gt;  list   2&gt;&amp;1"></a>若要将标准输出与错误输出写到同一个文件，可以用  &gt;  list   2&gt;&amp;1</h4><h3 id="命令执行的判断依据"><a href="#命令执行的判断依据" class="headerlink" title="命令执行的判断依据"></a>命令执行的判断依据</h3><h4 id="cmd1-cmd2：不考虑相关性，连续地执行命令"><a href="#cmd1-cmd2：不考虑相关性，连续地执行命令" class="headerlink" title="cmd1 ; cmd2：不考虑相关性，连续地执行命令"></a>cmd1 ; cmd2：不考虑相关性，连续地执行命令</h4><h4 id="cmd1-cmd2：若cmd1执行完毕且正确，则执行cmd2，反之不执行"><a href="#cmd1-cmd2：若cmd1执行完毕且正确，则执行cmd2，反之不执行" class="headerlink" title="cmd1 &amp;&amp; cmd2：若cmd1执行完毕且正确，则执行cmd2，反之不执行"></a>cmd1 &amp;&amp; cmd2：若cmd1执行完毕且正确，则执行cmd2，反之不执行</h4><h4 id="cmd1-cmd2：若cmd1执行完毕且错误，则执行cmd2，反之不执行"><a href="#cmd1-cmd2：若cmd1执行完毕且错误，则执行cmd2，反之不执行" class="headerlink" title="cmd1   ||   cmd2：若cmd1执行完毕且错误，则执行cmd2，反之不执行"></a>cmd1   ||   cmd2：若cmd1执行完毕且错误，则执行cmd2，反之不执行</h4><h4 id="例：ls-tmp-abc-mkdir-tmp-abc-touch-tmp-abc-hehe"><a href="#例：ls-tmp-abc-mkdir-tmp-abc-touch-tmp-abc-hehe" class="headerlink" title="例：ls  &#x2F;tmp&#x2F;abc  ||  mkdir  &#x2F;tmp&#x2F;abc  &amp;&amp;  touch  &#x2F;tmp&#x2F;abc&#x2F;hehe"></a>例：ls  &#x2F;tmp&#x2F;abc  ||  mkdir  &#x2F;tmp&#x2F;abc  &amp;&amp;  touch  &#x2F;tmp&#x2F;abc&#x2F;hehe</h4><pre><code class="hljs">   ls  /tmp/abc  $$  echo  &quot;exist&quot;  ||  echo  &quot;not exist&quot;</code></pre><h3 id="管道命令"><a href="#管道命令" class="headerlink" title="管道命令"></a>管道命令</h3><h4 id="管道命令用竖线-分隔，将前一个命令的stdout作为stdin输入到下一个命令"><a href="#管道命令用竖线-分隔，将前一个命令的stdout作为stdin输入到下一个命令" class="headerlink" title="管道命令用竖线 | 分隔，将前一个命令的stdout作为stdin输入到下一个命令"></a>管道命令用竖线 | 分隔，将前一个命令的stdout作为stdin输入到下一个命令</h4><h4 id="支持管道的命令指既可以从文件读取，也可以从标准输入读取：cat、less、more、head、tail、cut、grep、sort、wc、uniq、tee、tr、col、join、paste、expand、split、xargs、sed、awk"><a href="#支持管道的命令指既可以从文件读取，也可以从标准输入读取：cat、less、more、head、tail、cut、grep、sort、wc、uniq、tee、tr、col、join、paste、expand、split、xargs、sed、awk" class="headerlink" title="支持管道的命令指既可以从文件读取，也可以从标准输入读取：cat、less、more、head、tail、cut、grep、sort、wc、uniq、tee、tr、col、join、paste、expand、split、xargs、sed、awk"></a>支持管道的命令指既可以从文件读取，也可以从标准输入读取：cat、less、more、head、tail、cut、grep、sort、wc、uniq、tee、tr、col、join、paste、expand、split、xargs、sed、awk</h4><h4 id="cut-以行为单位，切出数据的某一段，用于具有格式的数据，如last的输出"><a href="#cut-以行为单位，切出数据的某一段，用于具有格式的数据，如last的输出" class="headerlink" title="cut    以行为单位，切出数据的某一段，用于具有格式的数据，如last的输出"></a>cut    以行为单位，切出数据的某一段，用于具有格式的数据，如last的输出</h4><h5 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h5><h6 id="cut-d-‘分割字符’-f-n-filename"><a href="#cut-d-‘分割字符’-f-n-filename" class="headerlink" title="cut  -d  ‘分割字符’  -f  n  [filename]"></a>cut  -d  ‘分割字符’  -f  n  [filename]</h6><h6 id="cut-c-字符区间-filename"><a href="#cut-c-字符区间-filename" class="headerlink" title="cut  -c  字符区间  [filename]"></a>cut  -c  字符区间  [filename]</h6><h5 id="选项-6"><a href="#选项-6" class="headerlink" title="选项"></a>选项</h5><h6 id="d：后接分割字符"><a href="#d：后接分割字符" class="headerlink" title="-d：后接分割字符"></a>-d：后接分割字符</h6><h6 id="f：用-d的分割字符划分为数段，取第n段"><a href="#f：用-d的分割字符划分为数段，取第n段" class="headerlink" title="-f：用-d的分割字符划分为数段，取第n段"></a>-f：用-d的分割字符划分为数段，取第n段</h6><h6 id="c：以字符为单位取出固定区间"><a href="#c：以字符为单位取出固定区间" class="headerlink" title="-c：以字符为单位取出固定区间"></a>-c：以字符为单位取出固定区间</h6><h5 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h5><h6 id="echo-PATH-cut-d-‘-’-f-5"><a href="#echo-PATH-cut-d-‘-’-f-5" class="headerlink" title="echo  ${PATH}  |  cut  -d  ‘:’  -f  5"></a>echo  ${PATH}  |  cut  -d  ‘:’  -f  5</h6><h6 id="last-cut-c-1-9"><a href="#last-cut-c-1-9" class="headerlink" title="last  |  cut  -c  1-9"></a>last  |  cut  -c  1-9</h6><h4 id="grep-查找匹配的行并打印，支持正则表达式"><a href="#grep-查找匹配的行并打印，支持正则表达式" class="headerlink" title="grep    查找匹配的行并打印，支持正则表达式"></a>grep    查找匹配的行并打印，支持正则表达式</h4><h5 id="语法：grep-ABcinv-‘string’-filename"><a href="#语法：grep-ABcinv-‘string’-filename" class="headerlink" title="语法：grep  [-ABcinv]  ‘string’  [filename]"></a>语法：grep  [-ABcinv]  ‘string’  [filename]</h5><h5 id="选项-7"><a href="#选项-7" class="headerlink" title="选项"></a>选项</h5><h6 id="An：后接数字，除了找到string的行，后面n行也列出来"><a href="#An：后接数字，除了找到string的行，后面n行也列出来" class="headerlink" title="-An：后接数字，除了找到string的行，后面n行也列出来"></a>-An：后接数字，除了找到string的行，后面n行也列出来</h6><h6 id="Bn：后接数字，除了找到string的行，前面n行也列出来"><a href="#Bn：后接数字，除了找到string的行，前面n行也列出来" class="headerlink" title="-Bn：后接数字，除了找到string的行，前面n行也列出来"></a>-Bn：后接数字，除了找到string的行，前面n行也列出来</h6><h6 id="c：计算找到字符的行数"><a href="#c：计算找到字符的行数" class="headerlink" title="-c：计算找到字符的行数"></a>-c：计算找到字符的行数</h6><h6 id="i：忽略大小写的不同"><a href="#i：忽略大小写的不同" class="headerlink" title="-i：忽略大小写的不同"></a>-i：忽略大小写的不同</h6><h6 id="n：输出行号"><a href="#n：输出行号" class="headerlink" title="-n：输出行号"></a>-n：输出行号</h6><h6 id="v：反向选择，选取没有“string”的行"><a href="#v：反向选择，选取没有“string”的行" class="headerlink" title="-v：反向选择，选取没有“string”的行"></a>-v：反向选择，选取没有“string”的行</h6><h5 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h5><h6 id="last-grep-‘root’-cut-d-‘-‘-f-1"><a href="#last-grep-‘root’-cut-d-‘-‘-f-1" class="headerlink" title="last  |  grep  ‘root’  |  cut  -d  ‘ ‘  -f 1"></a>last  |  grep  ‘root’  |  cut  -d  ‘ ‘  -f 1</h6><h6 id="last-grep-v-‘root’"><a href="#last-grep-v-‘root’" class="headerlink" title="last  |  grep  -v  ‘root’"></a>last  |  grep  -v  ‘root’</h6><h4 id="sort-以行为单位进行排序"><a href="#sort-以行为单位进行排序" class="headerlink" title="sort    以行为单位进行排序"></a>sort    以行为单位进行排序</h4><h5 id="语法：sort-ntk-filename"><a href="#语法：sort-ntk-filename" class="headerlink" title="语法：sort  [-ntk]  [filename]"></a>语法：sort  [-ntk]  [filename]</h5><h5 id="选项-8"><a href="#选项-8" class="headerlink" title="选项"></a>选项</h5><h6 id="n：以数字进行排序（默认以字符排序）"><a href="#n：以数字进行排序（默认以字符排序）" class="headerlink" title="-n：以数字进行排序（默认以字符排序）"></a>-n：以数字进行排序（默认以字符排序）</h6><h6 id="t：后接分隔字符"><a href="#t：后接分隔字符" class="headerlink" title="-t：后接分隔字符"></a>-t：后接分隔字符</h6><h6 id="k-num：用-t的分割字符划分为数段，用第num段进行排序"><a href="#k-num：用-t的分割字符划分为数段，用第num段进行排序" class="headerlink" title="-k  num：用-t的分割字符划分为数段，用第num段进行排序"></a>-k  num：用-t的分割字符划分为数段，用第num段进行排序</h6><h5 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h5><h6 id="cat-etc-passwd-sort-t-‘-’-k-3-n"><a href="#cat-etc-passwd-sort-t-‘-’-k-3-n" class="headerlink" title="cat  &#x2F;etc&#x2F;passwd  |  sort  -t  ‘:’  -k  3  -n"></a>cat  &#x2F;etc&#x2F;passwd  |  sort  -t  ‘:’  -k  3  -n</h6><h4 id="uniq-对于重复的行，仅保留一行"><a href="#uniq-对于重复的行，仅保留一行" class="headerlink" title="uniq    对于重复的行，仅保留一行"></a>uniq    对于重复的行，仅保留一行</h4><h5 id="语法：uniq-ic"><a href="#语法：uniq-ic" class="headerlink" title="语法：uniq  [-ic]"></a>语法：uniq  [-ic]</h5><h5 id="选项-9"><a href="#选项-9" class="headerlink" title="选项"></a>选项</h5><h6 id="i：忽略大小写的不同-1"><a href="#i：忽略大小写的不同-1" class="headerlink" title="-i：忽略大小写的不同"></a>-i：忽略大小写的不同</h6><h6 id="c：进行计数"><a href="#c：进行计数" class="headerlink" title="-c：进行计数"></a>-c：进行计数</h6><h5 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h5><h6 id="last-cut-d-‘-‘-f-1-sort-uniq"><a href="#last-cut-d-‘-‘-f-1-sort-uniq" class="headerlink" title="last  |  cut  -d  ‘ ‘  -f  1  |  sort  |  uniq"></a>last  |  cut  -d  ‘ ‘  -f  1  |  sort  |  uniq</h6><h6 id="last-cut-d-‘-‘-f-1-sort-uniq-c"><a href="#last-cut-d-‘-‘-f-1-sort-uniq-c" class="headerlink" title="last  |  cut  -d  ‘ ‘  -f  1  |  sort  |  uniq  -c"></a>last  |  cut  -d  ‘ ‘  -f  1  |  sort  |  uniq  -c</h6><h4 id="wc-计算行数、字符数等"><a href="#wc-计算行数、字符数等" class="headerlink" title="wc    计算行数、字符数等"></a>wc    计算行数、字符数等</h4><h5 id="语法：wc-lwm-filename"><a href="#语法：wc-lwm-filename" class="headerlink" title="语法：wc  [-lwm]  [filename]"></a>语法：wc  [-lwm]  [filename]</h5><h5 id="选项-10"><a href="#选项-10" class="headerlink" title="选项"></a>选项</h5><h6 id="l：计算行数"><a href="#l：计算行数" class="headerlink" title="-l：计算行数"></a>-l：计算行数</h6><h6 id="w：计算单词数"><a href="#w：计算单词数" class="headerlink" title="-w：计算单词数"></a>-w：计算单词数</h6><h6 id="m：计算字符数"><a href="#m：计算字符数" class="headerlink" title="-m：计算字符数"></a>-m：计算字符数</h6><h5 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h5><h6 id="last-grep-‘root’-wc-l"><a href="#last-grep-‘root’-wc-l" class="headerlink" title="last  |  grep  ‘root’  |  wc -l"></a>last  |  grep  ‘root’  |  wc -l</h6><h4 id="tee-双向重定向，将数据同时分流到文件与屏幕"><a href="#tee-双向重定向，将数据同时分流到文件与屏幕" class="headerlink" title="tee    双向重定向，将数据同时分流到文件与屏幕"></a>tee    双向重定向，将数据同时分流到文件与屏幕</h4><h5 id="语法：tee-a-file"><a href="#语法：tee-a-file" class="headerlink" title="语法：tee  [-a]  file"></a>语法：tee  [-a]  file</h5><h5 id="选项-11"><a href="#选项-11" class="headerlink" title="选项"></a>选项</h5><h6 id="a：以累加的形式写入文件（默认覆盖）"><a href="#a：以累加的形式写入文件（默认覆盖）" class="headerlink" title="-a：以累加的形式写入文件（默认覆盖）"></a>-a：以累加的形式写入文件（默认覆盖）</h6><h5 id="例子-6"><a href="#例子-6" class="headerlink" title="例子"></a>例子</h5><h6 id="last-tee-last-list-cut-d-‘-‘-f-1"><a href="#last-tee-last-list-cut-d-‘-‘-f-1" class="headerlink" title="last  |  tee  last.list  |  cut  -d ‘ ‘  -f 1"></a>last  |  tee  last.list  |  cut  -d ‘ ‘  -f 1</h6><h5 id="用于在管道中保存一份中间数据的缓存"><a href="#用于在管道中保存一份中间数据的缓存" class="headerlink" title="用于在管道中保存一份中间数据的缓存"></a>用于在管道中保存一份中间数据的缓存</h5><h4 id="tr-删除或替换字符"><a href="#tr-删除或替换字符" class="headerlink" title="tr    删除或替换字符"></a>tr    删除或替换字符</h4><h5 id="语法：tr-d-‘char1’-‘char2’"><a href="#语法：tr-d-‘char1’-‘char2’" class="headerlink" title="语法：tr  [-d]  ‘char1’  ‘char2’"></a>语法：tr  [-d]  ‘char1’  ‘char2’</h5><h5 id="选项-12"><a href="#选项-12" class="headerlink" title="选项"></a>选项</h5><h6 id="d：删除char1字符，若无-d选项则将char1替换为char2"><a href="#d：删除char1字符，若无-d选项则将char1替换为char2" class="headerlink" title="-d：删除char1字符，若无-d选项则将char1替换为char2"></a>-d：删除char1字符，若无-d选项则将char1替换为char2</h6><h5 id="例子-7"><a href="#例子-7" class="headerlink" title="例子"></a>例子</h5><h6 id="last-tr-‘-a-z-’-‘-A-Z-’"><a href="#last-tr-‘-a-z-’-‘-A-Z-’" class="headerlink" title="last  |  tr  ‘[a-z]’  ‘[A-Z]’"></a>last  |  tr  ‘[a-z]’  ‘[A-Z]’</h6><h6 id="cat-etc-passwd-tr-d-‘-’"><a href="#cat-etc-passwd-tr-d-‘-’" class="headerlink" title="cat  &#x2F;etc&#x2F;passwd  |  tr  -d  ‘:’"></a>cat  &#x2F;etc&#x2F;passwd  |  tr  -d  ‘:’</h6><h4 id="col-将tab键替换为对等的空格键"><a href="#col-将tab键替换为对等的空格键" class="headerlink" title="col    将tab键替换为对等的空格键"></a>col    将tab键替换为对等的空格键</h4><h5 id="语法：col-x"><a href="#语法：col-x" class="headerlink" title="语法：col  -x"></a>语法：col  -x</h5><h5 id="例子-8"><a href="#例子-8" class="headerlink" title="例子"></a>例子</h5><h6 id="cat-etc-man-db-conf-col-x"><a href="#cat-etc-man-db-conf-col-x" class="headerlink" title="cat  &#x2F;etc&#x2F;man_db.conf  |  col  -x"></a>cat  &#x2F;etc&#x2F;man_db.conf  |  col  -x</h6><h5 id="相同作用expand、unexpand，详见私房菜P357"><a href="#相同作用expand、unexpand，详见私房菜P357" class="headerlink" title="相同作用expand、unexpand，详见私房菜P357"></a>相同作用expand、unexpand，详见私房菜P357</h5><h4 id="join-将两个文件中，有相同数据的那一行合并"><a href="#join-将两个文件中，有相同数据的那一行合并" class="headerlink" title="join    将两个文件中，有相同数据的那一行合并"></a>join    将两个文件中，有相同数据的那一行合并</h4><h5 id="详见私房菜P356"><a href="#详见私房菜P356" class="headerlink" title="详见私房菜P356"></a>详见私房菜P356</h5><h4 id="paste-直接将两个文件的对应两行连接起来，以Tab键隔开"><a href="#paste-直接将两个文件的对应两行连接起来，以Tab键隔开" class="headerlink" title="paste    直接将两个文件的对应两行连接起来，以Tab键隔开"></a>paste    直接将两个文件的对应两行连接起来，以Tab键隔开</h4><h5 id="语法：paste-d-file1-file2"><a href="#语法：paste-d-file1-file2" class="headerlink" title="语法：paste  [-d]  file1  file2"></a>语法：paste  [-d]  file1  file2</h5><h5 id="选项-13"><a href="#选项-13" class="headerlink" title="选项"></a>选项</h5><h6 id="d：后接分隔符，默认为Tab键"><a href="#d：后接分隔符，默认为Tab键" class="headerlink" title="-d：后接分隔符，默认为Tab键"></a>-d：后接分隔符，默认为Tab键</h6><h5 id="例子-9"><a href="#例子-9" class="headerlink" title="例子"></a>例子</h5><h6 id="paste-etc-passwd-etc-shadow"><a href="#paste-etc-passwd-etc-shadow" class="headerlink" title="paste  &#x2F;etc&#x2F;passwd   &#x2F;etc&#x2F;shadow"></a>paste  &#x2F;etc&#x2F;passwd   &#x2F;etc&#x2F;shadow</h6><h6 id="cat-etc-group-paste-etc-passwd-etc-shadow"><a href="#cat-etc-group-paste-etc-passwd-etc-shadow" class="headerlink" title="cat  &#x2F;etc&#x2F;group  |  paste  &#x2F;etc&#x2F;passwd  &#x2F;etc&#x2F;shadow  -"></a>cat  &#x2F;etc&#x2F;group  |  paste  &#x2F;etc&#x2F;passwd  &#x2F;etc&#x2F;shadow  -</h6><h4 id="split-依据文件大小或行数将大文件划分为小文件"><a href="#split-依据文件大小或行数将大文件划分为小文件" class="headerlink" title="split    依据文件大小或行数将大文件划分为小文件"></a>split    依据文件大小或行数将大文件划分为小文件</h4><h5 id="语法：split-bl-file-前缀名"><a href="#语法：split-bl-file-前缀名" class="headerlink" title="语法：split  [-bl]  file  前缀名"></a>语法：split  [-bl]  file  前缀名</h5><h5 id="选项-14"><a href="#选项-14" class="headerlink" title="选项"></a>选项</h5><h6 id="b：以大小划分，后接文件大小"><a href="#b：以大小划分，后接文件大小" class="headerlink" title="-b：以大小划分，后接文件大小"></a>-b：以大小划分，后接文件大小</h6><h6 id="l：以行数划分，后接行数"><a href="#l：以行数划分，后接行数" class="headerlink" title="-l：以行数划分，后接行数"></a>-l：以行数划分，后接行数</h6><h6 id="前缀名：小文件的前缀名，以aa、ab、-ac等命名小文件"><a href="#前缀名：小文件的前缀名，以aa、ab、-ac等命名小文件" class="headerlink" title="前缀名：小文件的前缀名，以aa、ab、***ac等命名小文件"></a>前缀名：小文件的前缀名，以<em><strong>aa、</strong></em>ab、***ac等命名小文件</h6><h5 id="例子-10"><a href="#例子-10" class="headerlink" title="例子"></a>例子</h5><h6 id="划分为servicesaa、servicesab等的300k的小文件：split-b-300k-etc-services-services"><a href="#划分为servicesaa、servicesab等的300k的小文件：split-b-300k-etc-services-services" class="headerlink" title="划分为servicesaa、servicesab等的300k的小文件：split  -b  300k  &#x2F;etc&#x2F;services  services"></a>划分为servicesaa、servicesab等的300k的小文件：split  -b  300k  &#x2F;etc&#x2F;services  services</h6><h6 id="将小文件合并：cat-services-servicesback"><a href="#将小文件合并：cat-services-servicesback" class="headerlink" title="将小文件合并：cat  services*  &gt;&gt;  servicesback"></a>将小文件合并：cat  services*  &gt;&gt;  servicesback</h6><h6 id="将ls的输出信息每10行记录为一个文件：ls-al-etc-split-l-10-lsetc"><a href="#将ls的输出信息每10行记录为一个文件：ls-al-etc-split-l-10-lsetc" class="headerlink" title="将ls的输出信息每10行记录为一个文件：ls  -al  &#x2F;etc  |  split  -l  10  -  lsetc"></a>将ls的输出信息每10行记录为一个文件：ls  -al  &#x2F;etc  |  split  -l  10  -  lsetc</h6><h4 id="xargs-从stdin解析出参数"><a href="#xargs-从stdin解析出参数" class="headerlink" title="xargs    从stdin解析出参数"></a>xargs    从stdin解析出参数</h4><h5 id="用途：从stdin解析出参数。针对某些不支持管道（不支持stdin输入）的命令，通过xargs从stdin获得参数，从而可以用于管道"><a href="#用途：从stdin解析出参数。针对某些不支持管道（不支持stdin输入）的命令，通过xargs从stdin获得参数，从而可以用于管道" class="headerlink" title="用途：从stdin解析出参数。针对某些不支持管道（不支持stdin输入）的命令，通过xargs从stdin获得参数，从而可以用于管道"></a>用途：从stdin解析出参数。针对某些不支持管道（不支持stdin输入）的命令，通过xargs从stdin获得参数，从而可以用于管道</h5><h5 id="语法：xargs-0epn-command"><a href="#语法：xargs-0epn-command" class="headerlink" title="语法：xargs  [-0epn]  command"></a>语法：xargs  [-0epn]  command</h5><h5 id="选项-15"><a href="#选项-15" class="headerlink" title="选项"></a>选项</h5><h6 id="0：如果输入的stdin含有特殊字符，例如-、-、空格等字符时，这个-0参数可以将它还原成一般字符，这个参数可以用于特殊状态"><a href="#0：如果输入的stdin含有特殊字符，例如-、-、空格等字符时，这个-0参数可以将它还原成一般字符，这个参数可以用于特殊状态" class="headerlink" title="-0：如果输入的stdin含有特殊字符，例如 &#96; 、\、空格等字符时，这个-0参数可以将它还原成一般字符，这个参数可以用于特殊状态"></a>-0：如果输入的stdin含有特殊字符，例如 &#96; 、\、空格等字符时，这个-0参数可以将它还原成一般字符，这个参数可以用于特殊状态</h6><h6 id="e：这是EOF-end-of-file-的意思，后面可以接一个字符，当xargs分析到这个字符时，就会停止工作"><a href="#e：这是EOF-end-of-file-的意思，后面可以接一个字符，当xargs分析到这个字符时，就会停止工作" class="headerlink" title="-e：这是EOF (end of file) 的意思，后面可以接一个字符，当xargs分析到这个字符时，就会停止工作"></a>-e：这是EOF (end of file) 的意思，后面可以接一个字符，当xargs分析到这个字符时，就会停止工作</h6><h6 id="p：在执行每个命令时，都会询问使用者"><a href="#p：在执行每个命令时，都会询问使用者" class="headerlink" title="-p：在执行每个命令时，都会询问使用者"></a>-p：在执行每个命令时，都会询问使用者</h6><h6 id="n：后面接次数，每次command命令执行时，要使用几个参数"><a href="#n：后面接次数，每次command命令执行时，要使用几个参数" class="headerlink" title="-n：后面接次数，每次command命令执行时，要使用几个参数"></a>-n：后面接次数，每次command命令执行时，要使用几个参数</h6><h5 id="例子-11"><a href="#例子-11" class="headerlink" title="例子"></a>例子</h5><h6 id="cut-d-‘-’-f-1-etc-passwd-head-n-3-xargs-n-1-id"><a href="#cut-d-‘-’-f-1-etc-passwd-head-n-3-xargs-n-1-id" class="headerlink" title="cut -d ‘:’ -f 1 &#x2F;etc&#x2F;passwd  |  head -n 3  |  xargs  -n 1  id"></a>cut -d ‘:’ -f 1 &#x2F;etc&#x2F;passwd  |  head -n 3  |  xargs  -n 1  id</h6><h6 id="cut-d-‘-’-f-1-etc-passwd-head-n-3-xargs-e’sync’-n-1-id"><a href="#cut-d-‘-’-f-1-etc-passwd-head-n-3-xargs-e’sync’-n-1-id" class="headerlink" title="cut -d ‘:’ -f 1 &#x2F;etc&#x2F;passwd  |  head -n 3  |  xargs  -e’sync’  -n 1  id"></a>cut -d ‘:’ -f 1 &#x2F;etc&#x2F;passwd  |  head -n 3  |  xargs  -e’sync’  -n 1  id</h6><h6 id="find-usr-sbin-perm-7000-xargs-ls-l"><a href="#find-usr-sbin-perm-7000-xargs-ls-l" class="headerlink" title="find  &#x2F;usr&#x2F;sbin -perm  &#x2F;7000  |  xargs  ls -l"></a>find  &#x2F;usr&#x2F;sbin -perm  &#x2F;7000  |  xargs  ls -l</h6><h6 id="find-home-name-“-java”-xargs-wc-l"><a href="#find-home-name-“-java”-xargs-wc-l" class="headerlink" title="find  &#x2F;home  -name  “*.java”  |  xargs  wc  -l"></a>find  &#x2F;home  -name  “*.java”  |  xargs  wc  -l</h6><h6 id="find-home-name-“-java”-wc-l"><a href="#find-home-name-“-java”-wc-l" class="headerlink" title="find  &#x2F;home  -name  “*.java”  |  wc  -l"></a>find  &#x2F;home  -name  “*.java”  |  wc  -l</h6><h6 id="find-home-name-“-java”-xargs-grep-‘123’"><a href="#find-home-name-“-java”-xargs-grep-‘123’" class="headerlink" title="find  &#x2F;home  -name  “*.java”  |  xargs  grep  ‘123’"></a>find  &#x2F;home  -name  “*.java”  |  xargs  grep  ‘123’</h6><h2 id="文本格式化处理"><a href="#文本格式化处理" class="headerlink" title="文本格式化处理"></a>文本格式化处理</h2><h3 id="grep-查找匹配的行并打印，支持正则表达式，"><a href="#grep-查找匹配的行并打印，支持正则表达式，" class="headerlink" title="grep     查找匹配的行并打印，支持正则表达式，"></a>grep     查找匹配的行并打印，支持正则表达式，</h3><pre><code class="hljs">        支持文件读取和标准输入</code></pre><h4 id="语法：grep-ABcinv-‘string’-filename-1"><a href="#语法：grep-ABcinv-‘string’-filename-1" class="headerlink" title="语法：grep  [-ABcinv]  ‘string’  [filename]"></a>语法：grep  [-ABcinv]  ‘string’  [filename]</h4><h4 id="选项-16"><a href="#选项-16" class="headerlink" title="选项"></a>选项</h4><h5 id="An：后接数字，除了找到string的行，后面n行也列出来-1"><a href="#An：后接数字，除了找到string的行，后面n行也列出来-1" class="headerlink" title="-An：后接数字，除了找到string的行，后面n行也列出来"></a>-An：后接数字，除了找到string的行，后面n行也列出来</h5><h5 id="Bn：后接数字，除了找到string的行，前面n行也列出来-1"><a href="#Bn：后接数字，除了找到string的行，前面n行也列出来-1" class="headerlink" title="-Bn：后接数字，除了找到string的行，前面n行也列出来"></a>-Bn：后接数字，除了找到string的行，前面n行也列出来</h5><h5 id="c：计算找到字符的行数-1"><a href="#c：计算找到字符的行数-1" class="headerlink" title="-c：计算找到字符的行数"></a>-c：计算找到字符的行数</h5><h5 id="i：忽略大小写的不同-2"><a href="#i：忽略大小写的不同-2" class="headerlink" title="-i：忽略大小写的不同"></a>-i：忽略大小写的不同</h5><h5 id="n：输出行号-1"><a href="#n：输出行号-1" class="headerlink" title="-n：输出行号"></a>-n：输出行号</h5><h5 id="v：反向选择，选取没有“string”的行-1"><a href="#v：反向选择，选取没有“string”的行-1" class="headerlink" title="-v：反向选择，选取没有“string”的行"></a>-v：反向选择，选取没有“string”的行</h5><h4 id="例子-12"><a href="#例子-12" class="headerlink" title="例子"></a>例子</h4><h5 id="last-grep-‘root’-cut-d-‘-‘-f-1-1"><a href="#last-grep-‘root’-cut-d-‘-‘-f-1-1" class="headerlink" title="last  |  grep  ‘root’  |  cut  -d  ‘ ‘  -f 1"></a>last  |  grep  ‘root’  |  cut  -d  ‘ ‘  -f 1</h5><h5 id="last-grep-v-‘root’-1"><a href="#last-grep-v-‘root’-1" class="headerlink" title="last  |  grep  -v  ‘root’"></a>last  |  grep  -v  ‘root’</h5><h5 id="cat-etc-passwd-grep-‘-MAN’"><a href="#cat-etc-passwd-grep-‘-MAN’" class="headerlink" title="cat  &#x2F;etc&#x2F;passwd  |  grep  ‘^MAN’"></a>cat  &#x2F;etc&#x2F;passwd  |  grep  ‘^MAN’</h5><h3 id="sed-文本编辑工具，可进行替换、删除、新增、选定等，支持RE，"><a href="#sed-文本编辑工具，可进行替换、删除、新增、选定等，支持RE，" class="headerlink" title="sed    文本编辑工具，可进行替换、删除、新增、选定等，支持RE，"></a>sed    文本编辑工具，可进行替换、删除、新增、选定等，支持RE，</h3><pre><code class="hljs">     支持文件读取和标准输入</code></pre><h4 id="语法：sed-nfri-‘操作’-filename"><a href="#语法：sed-nfri-‘操作’-filename" class="headerlink" title="语法：sed  [-nfri]  ‘操作’  [filename]"></a>语法：sed  [-nfri]  ‘操作’  [filename]</h4><h4 id="选项-17"><a href="#选项-17" class="headerlink" title="选项"></a>选项</h4><h5 id="n：使用安静模式，仅显示出被sed处理过的那一行，而非显示文件的所有行"><a href="#n：使用安静模式，仅显示出被sed处理过的那一行，而非显示文件的所有行" class="headerlink" title="-n：使用安静模式，仅显示出被sed处理过的那一行，而非显示文件的所有行"></a>-n：使用安静模式，仅显示出被sed处理过的那一行，而非显示文件的所有行</h5><h5 id="f：后接scriptfile，执行scriptfile中的命令"><a href="#f：后接scriptfile，执行scriptfile中的命令" class="headerlink" title="-f：后接scriptfile，执行scriptfile中的命令"></a>-f：后接scriptfile，执行scriptfile中的命令</h5><h5 id="r：使用拓展正则表达式"><a href="#r：使用拓展正则表达式" class="headerlink" title="-r：使用拓展正则表达式"></a>-r：使用拓展正则表达式</h5><h5 id="i：直接修改原文件内容，而非屏幕输出"><a href="#i：直接修改原文件内容，而非屏幕输出" class="headerlink" title="-i：直接修改原文件内容，而非屏幕输出"></a>-i：直接修改原文件内容，而非屏幕输出</h5><h4 id="‘操作’-的格式：定位1-，定位2-编辑命令-内容"><a href="#‘操作’-的格式：定位1-，定位2-编辑命令-内容" class="headerlink" title="‘操作’ 的格式：定位1[，定位2]编辑命令  [内容]"></a>‘操作’ 的格式：定位1[，定位2]编辑命令  [内容]</h4><h4 id="定位方式"><a href="#定位方式" class="headerlink" title="定位方式"></a>定位方式</h4><h5 id="行号"><a href="#行号" class="headerlink" title="行号"></a>行号</h5><h5 id="正则表达式"><a href="#正则表达式" class="headerlink" title="&#x2F;正则表达式&#x2F;"></a>&#x2F;正则表达式&#x2F;</h5><h4 id="编辑命令"><a href="#编辑命令" class="headerlink" title="编辑命令"></a>编辑命令</h4><h5 id="a：新增，在指定行的下一行添加"><a href="#a：新增，在指定行的下一行添加" class="headerlink" title="a：新增，在指定行的下一行添加"></a>a：新增，在指定行的下一行添加</h5><h5 id="c：替换，替换n1，n2之间的行"><a href="#c：替换，替换n1，n2之间的行" class="headerlink" title="c：替换，替换n1，n2之间的行"></a>c：替换，替换n1，n2之间的行</h5><h5 id="d：删除，通常后面不接内容"><a href="#d：删除，通常后面不接内容" class="headerlink" title="d：删除，通常后面不接内容"></a>d：删除，通常后面不接内容</h5><h5 id="i：插入，在指定行的上一行添加"><a href="#i：插入，在指定行的上一行添加" class="headerlink" title="i：插入，在指定行的上一行添加"></a>i：插入，在指定行的上一行添加</h5><h5 id="p：打印，通常与sed-n一起使用"><a href="#p：打印，通常与sed-n一起使用" class="headerlink" title="p：打印，通常与sed -n一起使用"></a>p：打印，通常与sed -n一起使用</h5><h5 id="s：查找替换，用法与vim相同，-n1-n2s-word1-word2-g-或-s-word1-word2-g"><a href="#s：查找替换，用法与vim相同，-n1-n2s-word1-word2-g-或-s-word1-word2-g" class="headerlink" title="s：查找替换，用法与vim相同， n1,n2s&#x2F;word1&#x2F;word2&#x2F;g 或 s&#x2F;word1&#x2F;word2&#x2F;g"></a>s：查找替换，用法与vim相同， n1,n2s&#x2F;word1&#x2F;word2&#x2F;g 或 s&#x2F;word1&#x2F;word2&#x2F;g</h5><h4 id="例子-13"><a href="#例子-13" class="headerlink" title="例子"></a>例子</h4><h5 id="nl-etc-passwd-sed-‘2a-drink’-在第2行后（即第3行）插入一行drink"><a href="#nl-etc-passwd-sed-‘2a-drink’-在第2行后（即第3行）插入一行drink" class="headerlink" title="nl  &#x2F;etc&#x2F;passwd  |  sed  ‘2a drink’   在第2行后（即第3行）插入一行drink"></a>nl  &#x2F;etc&#x2F;passwd  |  sed  ‘2a drink’   在第2行后（即第3行）插入一行drink</h5><h5 id="nl-etc-passwd-sed-‘2a-Drink-tea-or"><a href="#nl-etc-passwd-sed-‘2a-Drink-tea-or" class="headerlink" title="nl  &#x2F;etc&#x2F;passwd  |  sed  ‘2a Drink tea or\"></a>nl  &#x2F;etc&#x2F;passwd  |  sed  ‘2a Drink tea or\</h5><blockquote><p>drink beer?’<br>反斜杠加回车可以插入多行数据</p></blockquote><h5 id="nl-etc-passwd-sed-‘2-5c-No-2-5-number’-替换第2-5行"><a href="#nl-etc-passwd-sed-‘2-5c-No-2-5-number’-替换第2-5行" class="headerlink" title="nl  &#x2F;etc&#x2F;passwd  |  sed  ‘2,5c No 2-5 number’  替换第2~5行"></a>nl  &#x2F;etc&#x2F;passwd  |  sed  ‘2,5c No 2-5 number’  替换第2~5行</h5><h5 id="nl-etc-passwd-sed-‘2-5d’-删除第2-5行"><a href="#nl-etc-passwd-sed-‘2-5d’-删除第2-5行" class="headerlink" title="nl  &#x2F;etc&#x2F;passwd  |  sed  ‘2,5d’   删除第2~5行"></a>nl  &#x2F;etc&#x2F;passwd  |  sed  ‘2,5d’   删除第2~5行</h5><h5 id="nl-etc-passwd-sed-‘2-d’-删除第2到最后一行"><a href="#nl-etc-passwd-sed-‘2-d’-删除第2到最后一行" class="headerlink" title="nl  &#x2F;etc&#x2F;passwd  |  sed  ‘2,$d’   删除第2到最后一行"></a>nl  &#x2F;etc&#x2F;passwd  |  sed  ‘2,$d’   删除第2到最后一行</h5><h5 id="nl-etc-passwd-sed-n-‘5-7p’-打印第5-7行"><a href="#nl-etc-passwd-sed-n-‘5-7p’-打印第5-7行" class="headerlink" title="nl  &#x2F;etc&#x2F;passwd  |  sed  -n  ‘5,7p’   打印第5~7行"></a>nl  &#x2F;etc&#x2F;passwd  |  sed  -n  ‘5,7p’   打印第5~7行</h5><h5 id="nl-etc-passwd-sed-n-‘-MAN-p’-打印匹配MAN的行"><a href="#nl-etc-passwd-sed-n-‘-MAN-p’-打印匹配MAN的行" class="headerlink" title="nl  &#x2F;etc&#x2F;passwd  |  sed  -n  ‘&#x2F;MAN&#x2F;p’   打印匹配MAN的行"></a>nl  &#x2F;etc&#x2F;passwd  |  sed  -n  ‘&#x2F;MAN&#x2F;p’   打印匹配MAN的行</h5><h5 id="nl-etc-passwd-sed-n-‘2-MAN-p’-打印从第2行到第一次匹配MAN的行"><a href="#nl-etc-passwd-sed-n-‘2-MAN-p’-打印从第2行到第一次匹配MAN的行" class="headerlink" title="nl  &#x2F;etc&#x2F;passwd  |  sed  -n  ‘2,&#x2F;MAN&#x2F;p’   打印从第2行到第一次匹配MAN的行"></a>nl  &#x2F;etc&#x2F;passwd  |  sed  -n  ‘2,&#x2F;MAN&#x2F;p’   打印从第2行到第一次匹配MAN的行</h5><h5 id="nl-etc-passwd-sed-‘s-g’-把以-开头的行替换为空行"><a href="#nl-etc-passwd-sed-‘s-g’-把以-开头的行替换为空行" class="headerlink" title="nl  &#x2F;etc&#x2F;passwd  |  sed  ‘s&#x2F;^#.*$&#x2F;&#x2F;g’  把以#开头的行替换为空行"></a>nl  &#x2F;etc&#x2F;passwd  |  sed  ‘s&#x2F;^#.*$&#x2F;&#x2F;g’  把以#开头的行替换为空行</h5><h5 id="nl-etc-passwd-sed-‘1-3s-‘-在1-3行行首加上-，用于注释某些行"><a href="#nl-etc-passwd-sed-‘1-3s-‘-在1-3行行首加上-，用于注释某些行" class="headerlink" title="nl  &#x2F;etc&#x2F;passwd  |  sed  ‘1,3s&#x2F;^&#x2F;#&#x2F;‘   在1~3行行首加上#，用于注释某些行"></a>nl  &#x2F;etc&#x2F;passwd  |  sed  ‘1,3s&#x2F;^&#x2F;#&#x2F;‘   在1~3行行首加上#，用于注释某些行</h5><h3 id="awk-将文件的每一行分为数个字段来处理，常用于格式化输出。支持RE，"><a href="#awk-将文件的每一行分为数个字段来处理，常用于格式化输出。支持RE，" class="headerlink" title="awk    将文件的每一行分为数个字段来处理，常用于格式化输出。支持RE，"></a>awk    将文件的每一行分为数个字段来处理，常用于格式化输出。支持RE，</h3><pre><code class="hljs">      支持文件读取和标准输入</code></pre><h4 id="语法：awk-‘条件-操作-条件-操作-…’-filename"><a href="#语法：awk-‘条件-操作-条件-操作-…’-filename" class="headerlink" title="语法：awk  ‘条件{操作}  条件{操作}…’  [filename]"></a>语法：awk  ‘条件{操作}  条件{操作}…’  [filename]</h4><h4 id="awk每次读入一行，将一行的数据分段放入-1、-2等变量中，根据条件判断是否要执行后面的操作。再读取下一行，重复上面步骤。"><a href="#awk每次读入一行，将一行的数据分段放入-1、-2等变量中，根据条件判断是否要执行后面的操作。再读取下一行，重复上面步骤。" class="headerlink" title="awk每次读入一行，将一行的数据分段放入$1、$2等变量中，根据条件判断是否要执行后面的操作。再读取下一行，重复上面步骤。"></a>awk每次读入一行，将一行的数据分段放入$1、$2等变量中，根据条件判断是否要执行后面的操作。再读取下一行，重复上面步骤。</h4><h4 id="每一行的每个字段有其变量名，为-1、-2等。-0代表一整列数据。特殊变量：NF：每一行拥有的字段数，NR：目前处理的是第几行，FS：目前的分割字符，默认是空格。设置分割字符：-F’-’"><a href="#每一行的每个字段有其变量名，为-1、-2等。-0代表一整列数据。特殊变量：NF：每一行拥有的字段数，NR：目前处理的是第几行，FS：目前的分割字符，默认是空格。设置分割字符：-F’-’" class="headerlink" title="每一行的每个字段有其变量名，为$1、$2等。$0代表一整列数据。特殊变量：NF：每一行拥有的字段数，NR：目前处理的是第几行，FS：目前的分割字符，默认是空格。设置分割字符：-F’:’"></a>每一行的每个字段有其变量名，为$1、$2等。$0代表一整列数据。特殊变量：NF：每一行拥有的字段数，NR：目前处理的是第几行，FS：目前的分割字符，默认是空格。设置分割字符：-F’:’</h4><h4 id="例子-14"><a href="#例子-14" class="headerlink" title="例子"></a>例子</h4><h5 id="last-n-5-awk-‘-print-1-“-t-“-3-’-列出第1和3字段，并以Tab分割"><a href="#last-n-5-awk-‘-print-1-“-t-“-3-’-列出第1和3字段，并以Tab分割" class="headerlink" title="last  -n 5  |  awk  ‘{print  $1  “\t “  $3}’   列出第1和3字段，并以Tab分割"></a>last  -n 5  |  awk  ‘{print  $1  “\t “  $3}’   列出第1和3字段，并以Tab分割</h5><h5 id="last-n-5-awk-‘-print-1-“-t-lines-“-NR-“-t-columns-“-NF-’"><a href="#last-n-5-awk-‘-print-1-“-t-lines-“-NR-“-t-columns-“-NF-’" class="headerlink" title="last  -n 5  |  awk  ‘{print  $1  “\t lines: “  NR  “\t columns: “  NF}’"></a>last  -n 5  |  awk  ‘{print  $1  “\t lines: “  NR  “\t columns: “  NF}’</h5><h5 id="last-n-5-awk-‘BEGIN-FS-”-”-3"><a href="#last-n-5-awk-‘BEGIN-FS-”-”-3" class="headerlink" title="last  -n 5  |  awk  ‘BEGIN{FS&#x3D;”:”}  $3&lt;10{print  $1  “\t “  $3}’   以冒号为分隔符，当第三字段大于10时打印第1和3字段"></a>last  -n 5  |  awk  ‘BEGIN{FS&#x3D;”:”}  $3&lt;10{print  $1  “\t “  $3}’   以冒号为分隔符，当第三字段大于10时打印第1和3字段</h5><h5 id="cat-pay-txt-awk-‘NR-1-printf-“-10s-10s-10s-10s-10s-n”-1-2-3-4-”Total”"><a href="#cat-pay-txt-awk-‘NR-1-printf-“-10s-10s-10s-10s-10s-n”-1-2-3-4-”Total”" class="headerlink" title="cat  pay.txt  |  awk  ‘NR&#x3D;&#x3D;1{printf   “%10s %10s %10s %10s %10s\n”,$1,$2,$3,$4,”Total”} \"></a>cat  pay.txt  |  awk  ‘NR&#x3D;&#x3D;1{printf   “%10s %10s %10s %10s %10s\n”,$1,$2,$3,$4,”Total”} \</h5><p>NR&gt;&#x3D;2{total&#x3D;$2+$3+$4; printf  “%10s %10d %10d %10d %10.2f\n”,$1,$2,$3,$4,total}’</p><h3 id="printf-格式化输出"><a href="#printf-格式化输出" class="headerlink" title="printf    格式化输出"></a>printf    格式化输出</h3><h4 id="语法：printf-‘格式字符串’-实际内容"><a href="#语法：printf-‘格式字符串’-实际内容" class="headerlink" title="语法：printf  ‘格式字符串’  实际内容"></a>语法：printf  ‘格式字符串’  实际内容</h4><h4 id="printf不能直接读取文件且不支持管道，要用-读取文件提供给printf"><a href="#printf不能直接读取文件且不支持管道，要用-读取文件提供给printf" class="headerlink" title="printf不能直接读取文件且不支持管道，要用$( )读取文件提供给printf"></a>printf不能直接读取文件且不支持管道，要用$( )读取文件提供给printf</h4><h4 id="用法与C语言printf类似，s代表字符串，i代表整数，d代表十进制数，f代表浮点数"><a href="#用法与C语言printf类似，s代表字符串，i代表整数，d代表十进制数，f代表浮点数" class="headerlink" title="用法与C语言printf类似，s代表字符串，i代表整数，d代表十进制数，f代表浮点数"></a>用法与C语言printf类似，s代表字符串，i代表整数，d代表十进制数，f代表浮点数</h4><h4 id="例子-15"><a href="#例子-15" class="headerlink" title="例子"></a>例子</h4><h5 id="printf-‘-s-t-s-t-s-t-s-t-s-t-n’-cat-printf-txt"><a href="#printf-‘-s-t-s-t-s-t-s-t-s-t-n’-cat-printf-txt" class="headerlink" title="printf  ‘%s\t %s\t %s\t %s\t %s\t \n’  $(cat  printf.txt)"></a>printf  ‘%s\t %s\t %s\t %s\t %s\t \n’  $(cat  printf.txt)</h5><h5 id="printf-‘-10s-5i-5i-5i-8-2f-n’-cat-printf-txt-grep-v-‘Name’"><a href="#printf-‘-10s-5i-5i-5i-8-2f-n’-cat-printf-txt-grep-v-‘Name’" class="headerlink" title="printf  ‘%10s %5i %5i %5i %8.2f \n’  $(cat  printf.txt  |  grep  -v  ‘Name’)"></a>printf  ‘%10s %5i %5i %5i %8.2f \n’  $(cat  printf.txt  |  grep  -v  ‘Name’)</h5><h5 id="printf-‘-x45-n’-输出ACSII码值为十六进制的数值0x45（十进制69）的字符"><a href="#printf-‘-x45-n’-输出ACSII码值为十六进制的数值0x45（十进制69）的字符" class="headerlink" title="printf  ‘\x45\n’   输出ACSII码值为十六进制的数值0x45（十进制69）的字符"></a>printf  ‘\x45\n’   输出ACSII码值为十六进制的数值0x45（十进制69）的字符</h5><h3 id="diff-对比纯文本文件"><a href="#diff-对比纯文本文件" class="headerlink" title="diff    对比纯文本文件"></a>diff    对比纯文本文件</h3><h4 id="语法：diff-bBi-fromfile-tofile"><a href="#语法：diff-bBi-fromfile-tofile" class="headerlink" title="语法：diff  [-bBi]  fromfile  tofile"></a>语法：diff  [-bBi]  fromfile  tofile</h4><h4 id="选项-18"><a href="#选项-18" class="headerlink" title="选项"></a>选项</h4><h5 id="b：忽略一行中多个空白的区别"><a href="#b：忽略一行中多个空白的区别" class="headerlink" title="-b：忽略一行中多个空白的区别"></a>-b：忽略一行中多个空白的区别</h5><h5 id="B：忽略空白行的差别"><a href="#B：忽略空白行的差别" class="headerlink" title="-B：忽略空白行的差别"></a>-B：忽略空白行的差别</h5><h5 id="i：忽略大小写的差别"><a href="#i：忽略大小写的差别" class="headerlink" title="-i：忽略大小写的差别"></a>-i：忽略大小写的差别</h5><h5 id="fromfile：原始文件"><a href="#fromfile：原始文件" class="headerlink" title="fromfile：原始文件"></a>fromfile：原始文件</h5><h5 id="tofile：目标文件"><a href="#tofile：目标文件" class="headerlink" title="tofile：目标文件"></a>tofile：目标文件</h5><h3 id="cmp-利用字节单位对比"><a href="#cmp-利用字节单位对比" class="headerlink" title="cmp    利用字节单位对比"></a>cmp    利用字节单位对比</h3><h4 id="详见私房菜P382"><a href="#详见私房菜P382" class="headerlink" title="详见私房菜P382"></a>详见私房菜P382</h4><h3 id="patch-利用diff生成的补丁文件更新旧文件"><a href="#patch-利用diff生成的补丁文件更新旧文件" class="headerlink" title="patch    利用diff生成的补丁文件更新旧文件"></a>patch    利用diff生成的补丁文件更新旧文件</h3><h4 id="详见私房菜P383"><a href="#详见私房菜P383" class="headerlink" title="详见私房菜P383"></a>详见私房菜P383</h4><h2 id="帐户管理"><a href="#帐户管理" class="headerlink" title="帐户管理"></a>帐户管理</h2><h3 id="id-显示当前用户的UID与GID"><a href="#id-显示当前用户的UID与GID" class="headerlink" title="id    显示当前用户的UID与GID"></a>id    显示当前用户的UID与GID</h3><h3 id="groups-显示当前用户支持的所有用户组"><a href="#groups-显示当前用户支持的所有用户组" class="headerlink" title="groups     显示当前用户支持的所有用户组"></a>groups     显示当前用户支持的所有用户组</h3><h4 id="第一个输出的是有效用户组（决定了所建立新文件的所属用户组），可以通过newgrp修改"><a href="#第一个输出的是有效用户组（决定了所建立新文件的所属用户组），可以通过newgrp修改" class="headerlink" title="第一个输出的是有效用户组（决定了所建立新文件的所属用户组），可以通过newgrp修改"></a>第一个输出的是有效用户组（决定了所建立新文件的所属用户组），可以通过newgrp修改</h4><h3 id="newgrp-切换有效用户组"><a href="#newgrp-切换有效用户组" class="headerlink" title="newgrp    切换有效用户组"></a>newgrp    切换有效用户组</h3><h4 id="语法-：newgrp-用户组名"><a href="#语法-：newgrp-用户组名" class="headerlink" title="语法 ：newgrp  用户组名"></a>语法 ：newgrp  用户组名</h4><h4 id="新用户组需为支持用户组。newgrp以一个子shell实现功能，临时修改GID，用完可以exit退出子shell。"><a href="#新用户组需为支持用户组。newgrp以一个子shell实现功能，临时修改GID，用完可以exit退出子shell。" class="headerlink" title="新用户组需为支持用户组。newgrp以一个子shell实现功能，临时修改GID，用完可以exit退出子shell。"></a>新用户组需为支持用户组。newgrp以一个子shell实现功能，临时修改GID，用完可以exit退出子shell。</h4><h3 id="useradd-新增用户"><a href="#useradd-新增用户" class="headerlink" title="useradd    新增用户"></a>useradd    新增用户</h3><h4 id="语法：useradd-u-UID-g-初始用户组-G-次要用户组-c-说明信息-etc-passwd第5字段-d-家目录绝对路径-s-shell-Mmref-用户名"><a href="#语法：useradd-u-UID-g-初始用户组-G-次要用户组-c-说明信息-etc-passwd第5字段-d-家目录绝对路径-s-shell-Mmref-用户名" class="headerlink" title="语法：useradd  [-u UID]  [-g 初始用户组]  [-G 次要用户组]  [-c  说明信息(&#x2F;etc&#x2F;passwd第5字段)]  [-d 家目录绝对路径]  [-s shell]  [-Mmref]  用户名"></a>语法：useradd  [-u UID]  [-g 初始用户组]  [-G 次要用户组]  [-c  说明信息(&#x2F;etc&#x2F;passwd第5字段)]  [-d 家目录绝对路径]  [-s shell]  [-Mmref]  用户名</h4><h4 id="选项-19"><a href="#选项-19" class="headerlink" title="选项"></a>选项</h4><h5 id="M：不建立家目录（系统帐户默认值）"><a href="#M：不建立家目录（系统帐户默认值）" class="headerlink" title="-M：不建立家目录（系统帐户默认值）"></a>-M：不建立家目录（系统帐户默认值）</h5><h5 id="m：建立家目录（一般帐户默认值）"><a href="#m：建立家目录（一般帐户默认值）" class="headerlink" title="-m：建立家目录（一般帐户默认值）"></a>-m：建立家目录（一般帐户默认值）</h5><h5 id="r：建立系统帐户（限制UID为1-999，默认不建立家目录）"><a href="#r：建立系统帐户（限制UID为1-999，默认不建立家目录）" class="headerlink" title="-r：建立系统帐户（限制UID为1~999，默认不建立家目录）"></a>-r：建立系统帐户（限制UID为1~999，默认不建立家目录）</h5><h5 id="f：后接密码失效天数（-etc-shadow第7字段）（密码过期日后的宽限期）（密码过期日后经过此天数后将失效，无法用该密码登录），0为过期后立即失效，-1为永不失效"><a href="#f：后接密码失效天数（-etc-shadow第7字段）（密码过期日后的宽限期）（密码过期日后经过此天数后将失效，无法用该密码登录），0为过期后立即失效，-1为永不失效" class="headerlink" title="-f：后接密码失效天数（&#x2F;etc&#x2F;shadow第7字段）（密码过期日后的宽限期）（密码过期日后经过此天数后将失效，无法用该密码登录），0为过期后立即失效，-1为永不失效"></a>-f：后接密码失效天数（&#x2F;etc&#x2F;shadow第7字段）（密码过期日后的宽限期）（密码过期日后经过此天数后将失效，无法用该密码登录），0为过期后立即失效，-1为永不失效</h5><h5 id="e：后接账号失效日（-etc-shadow第8字段）（此日期后账号不能再使用，但数据仍在），格式YYYY-MM-dd"><a href="#e：后接账号失效日（-etc-shadow第8字段）（此日期后账号不能再使用，但数据仍在），格式YYYY-MM-dd" class="headerlink" title="-e：后接账号失效日（&#x2F;etc&#x2F;shadow第8字段）（此日期后账号不能再使用，但数据仍在），格式YYYY-MM-dd"></a>-e：后接账号失效日（&#x2F;etc&#x2F;shadow第8字段）（此日期后账号不能再使用，但数据仍在），格式YYYY-MM-dd</h5><h3 id="passwd-修改密码"><a href="#passwd-修改密码" class="headerlink" title="passwd    修改密码"></a>passwd    修改密码</h3><h4 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h4><h5 id="修改自己密码：passwd"><a href="#修改自己密码：passwd" class="headerlink" title="修改自己密码：passwd"></a>修改自己密码：passwd</h5><h5 id="修改指定用户密码：passwd-luSnxwi-用户名"><a href="#修改指定用户密码：passwd-luSnxwi-用户名" class="headerlink" title="修改指定用户密码：passwd  [-luSnxwi]  用户名"></a>修改指定用户密码：passwd  [-luSnxwi]  用户名</h5><h5 id="通过stdin输入密码：passwd-–stdin-用户名"><a href="#通过stdin输入密码：passwd-–stdin-用户名" class="headerlink" title="通过stdin输入密码：passwd  –stdin  用户名"></a>通过stdin输入密码：passwd  –stdin  用户名</h5><h6 id="用于shell脚本大量建立用户，如echo-“1234”-passwd-–stdin-用户名"><a href="#用于shell脚本大量建立用户，如echo-“1234”-passwd-–stdin-用户名" class="headerlink" title="用于shell脚本大量建立用户，如echo  “1234” | passwd  –stdin  用户名"></a>用于shell脚本大量建立用户，如echo  “1234” | passwd  –stdin  用户名</h6><h4 id="选项-20"><a href="#选项-20" class="headerlink" title="选项"></a>选项</h4><h5 id="l：锁定密码，使密码暂时失效（-etc-shadow第2字段前加上！）"><a href="#l：锁定密码，使密码暂时失效（-etc-shadow第2字段前加上！）" class="headerlink" title="-l：锁定密码，使密码暂时失效（&#x2F;etc&#x2F;shadow第2字段前加上！）"></a>-l：锁定密码，使密码暂时失效（&#x2F;etc&#x2F;shadow第2字段前加上！）</h5><h5 id="u：解锁密码"><a href="#u：解锁密码" class="headerlink" title="-u：解锁密码"></a>-u：解锁密码</h5><h5 id="S：列出密码相关参数"><a href="#S：列出密码相关参数" class="headerlink" title="-S：列出密码相关参数"></a>-S：列出密码相关参数</h5><h5 id="n：后接密码不可修改天数（-etc-shadow第4字段）（上一次修改密码往后此天数内不可再次修改密码）"><a href="#n：后接密码不可修改天数（-etc-shadow第4字段）（上一次修改密码往后此天数内不可再次修改密码）" class="headerlink" title="-n：后接密码不可修改天数（&#x2F;etc&#x2F;shadow第4字段）（上一次修改密码往后此天数内不可再次修改密码）"></a>-n：后接密码不可修改天数（&#x2F;etc&#x2F;shadow第4字段）（上一次修改密码往后此天数内不可再次修改密码）</h5><h5 id="x：后接密码过期天数（-etc-shadow第5字段）（上一次修改密码往后此天数内需修改密码，否则该期限之后，密码将过期，登录时系统将强制你修改密码才能继续使用）"><a href="#x：后接密码过期天数（-etc-shadow第5字段）（上一次修改密码往后此天数内需修改密码，否则该期限之后，密码将过期，登录时系统将强制你修改密码才能继续使用）" class="headerlink" title="-x：后接密码过期天数（&#x2F;etc&#x2F;shadow第5字段）（上一次修改密码往后此天数内需修改密码，否则该期限之后，密码将过期，登录时系统将强制你修改密码才能继续使用）"></a>-x：后接密码过期天数（&#x2F;etc&#x2F;shadow第5字段）（上一次修改密码往后此天数内需修改密码，否则该期限之后，密码将过期，登录时系统将强制你修改密码才能继续使用）</h5><h5 id="w：后接警告天数（-etc-shadow第6字段）（密码过期日往前此天数内，登录时系统将发出警告，提醒即将过期，要修改密码）"><a href="#w：后接警告天数（-etc-shadow第6字段）（密码过期日往前此天数内，登录时系统将发出警告，提醒即将过期，要修改密码）" class="headerlink" title="-w：后接警告天数（&#x2F;etc&#x2F;shadow第6字段）（密码过期日往前此天数内，登录时系统将发出警告，提醒即将过期，要修改密码）"></a>-w：后接警告天数（&#x2F;etc&#x2F;shadow第6字段）（密码过期日往前此天数内，登录时系统将发出警告，提醒即将过期，要修改密码）</h5><h5 id="i：后接密码失效天数（-etc-shadow第7字段）（密码过期日后的宽限期）（密码过期日后经过此天数后将失效，无法用该密码登录），0为立即失效，-1为永不失效"><a href="#i：后接密码失效天数（-etc-shadow第7字段）（密码过期日后的宽限期）（密码过期日后经过此天数后将失效，无法用该密码登录），0为立即失效，-1为永不失效" class="headerlink" title="-i：后接密码失效天数（&#x2F;etc&#x2F;shadow第7字段）（密码过期日后的宽限期）（密码过期日后经过此天数后将失效，无法用该密码登录），0为立即失效，-1为永不失效"></a>-i：后接密码失效天数（&#x2F;etc&#x2F;shadow第7字段）（密码过期日后的宽限期）（密码过期日后经过此天数后将失效，无法用该密码登录），0为立即失效，-1为永不失效</h5><h3 id="chage-显示和修改密码相关参数"><a href="#chage-显示和修改密码相关参数" class="headerlink" title="chage    显示和修改密码相关参数"></a>chage    显示和修改密码相关参数</h3><h4 id="语法：chage-ldEImMW-用户名"><a href="#语法：chage-ldEImMW-用户名" class="headerlink" title="语法：chage  [-ldEImMW]  用户名"></a>语法：chage  [-ldEImMW]  用户名</h4><h4 id="选项-21"><a href="#选项-21" class="headerlink" title="选项"></a>选项</h4><h5 id="l：列出密码相关参数，依次为上一次修改密码日期、密码过期日、密码失效日、账户失效日、密码不可修改天数、密码过期天数、警告天数。与passwd-S功能相同，但更加清楚。"><a href="#l：列出密码相关参数，依次为上一次修改密码日期、密码过期日、密码失效日、账户失效日、密码不可修改天数、密码过期天数、警告天数。与passwd-S功能相同，但更加清楚。" class="headerlink" title="-l：列出密码相关参数，依次为上一次修改密码日期、密码过期日、密码失效日、账户失效日、密码不可修改天数、密码过期天数、警告天数。与passwd -S功能相同，但更加清楚。"></a>-l：列出密码相关参数，依次为上一次修改密码日期、密码过期日、密码失效日、账户失效日、密码不可修改天数、密码过期天数、警告天数。与passwd -S功能相同，但更加清楚。</h5><h5 id="d：后接上一次修改密码日期（-etc-passwd第3字段），格式YYYY-MM-dd"><a href="#d：后接上一次修改密码日期（-etc-passwd第3字段），格式YYYY-MM-dd" class="headerlink" title="-d：后接上一次修改密码日期（&#x2F;etc&#x2F;passwd第3字段），格式YYYY-MM-dd"></a>-d：后接上一次修改密码日期（&#x2F;etc&#x2F;passwd第3字段），格式YYYY-MM-dd</h5><h5 id="m：后接密码不可修改天数（-etc-shadow第4字段）（上一次修改密码往后此天数内不可再次修改密码）"><a href="#m：后接密码不可修改天数（-etc-shadow第4字段）（上一次修改密码往后此天数内不可再次修改密码）" class="headerlink" title="-m：后接密码不可修改天数（&#x2F;etc&#x2F;shadow第4字段）（上一次修改密码往后此天数内不可再次修改密码）"></a>-m：后接密码不可修改天数（&#x2F;etc&#x2F;shadow第4字段）（上一次修改密码往后此天数内不可再次修改密码）</h5><h5 id="M：后接密码过期天数（-etc-shadow第5字段）（上一次修改密码往后此天数内需修改密码，否则该期限之后，密码将过期，登录时系统将强制你修改密码才能继续使用）"><a href="#M：后接密码过期天数（-etc-shadow第5字段）（上一次修改密码往后此天数内需修改密码，否则该期限之后，密码将过期，登录时系统将强制你修改密码才能继续使用）" class="headerlink" title="-M：后接密码过期天数（&#x2F;etc&#x2F;shadow第5字段）（上一次修改密码往后此天数内需修改密码，否则该期限之后，密码将过期，登录时系统将强制你修改密码才能继续使用）"></a>-M：后接密码过期天数（&#x2F;etc&#x2F;shadow第5字段）（上一次修改密码往后此天数内需修改密码，否则该期限之后，密码将过期，登录时系统将强制你修改密码才能继续使用）</h5><h5 id="W：后接警告天数（-etc-shadow第6字段）（密码过期日往前此天数内，登录时系统将发出警告，提醒即将过期，要修改密码）"><a href="#W：后接警告天数（-etc-shadow第6字段）（密码过期日往前此天数内，登录时系统将发出警告，提醒即将过期，要修改密码）" class="headerlink" title="-W：后接警告天数（&#x2F;etc&#x2F;shadow第6字段）（密码过期日往前此天数内，登录时系统将发出警告，提醒即将过期，要修改密码）"></a>-W：后接警告天数（&#x2F;etc&#x2F;shadow第6字段）（密码过期日往前此天数内，登录时系统将发出警告，提醒即将过期，要修改密码）</h5><h5 id="I-大写i-：后接密码失效天数（-etc-shadow第7字段）（密码过期日后的宽限期）（密码过期日后经过此天数后将失效，无法用该密码登录），0为过期后立即失效，-1为永不失效"><a href="#I-大写i-：后接密码失效天数（-etc-shadow第7字段）（密码过期日后的宽限期）（密码过期日后经过此天数后将失效，无法用该密码登录），0为过期后立即失效，-1为永不失效" class="headerlink" title="-I(大写i)：后接密码失效天数（&#x2F;etc&#x2F;shadow第7字段）（密码过期日后的宽限期）（密码过期日后经过此天数后将失效，无法用该密码登录），0为过期后立即失效，-1为永不失效"></a>-I(大写i)：后接密码失效天数（&#x2F;etc&#x2F;shadow第7字段）（密码过期日后的宽限期）（密码过期日后经过此天数后将失效，无法用该密码登录），0为过期后立即失效，-1为永不失效</h5><h5 id="E：后接账号失效日（-etc-shadow第8字段）（此日期后账号不能再使用，但数据仍在），格式YYYY-MM-dd"><a href="#E：后接账号失效日（-etc-shadow第8字段）（此日期后账号不能再使用，但数据仍在），格式YYYY-MM-dd" class="headerlink" title="-E：后接账号失效日（&#x2F;etc&#x2F;shadow第8字段）（此日期后账号不能再使用，但数据仍在），格式YYYY-MM-dd"></a>-E：后接账号失效日（&#x2F;etc&#x2F;shadow第8字段）（此日期后账号不能再使用，但数据仍在），格式YYYY-MM-dd</h5><h3 id="usermod-修改账户相关设置"><a href="#usermod-修改账户相关设置" class="headerlink" title="usermod    修改账户相关设置"></a>usermod    修改账户相关设置</h3><h4 id="语法：usermod-选项-用户名"><a href="#语法：usermod-选项-用户名" class="headerlink" title="语法：usermod  [选项]  用户名"></a>语法：usermod  [选项]  用户名</h4><h4 id="选项-22"><a href="#选项-22" class="headerlink" title="选项"></a>选项</h4><h5 id="支持useradd所有选项"><a href="#支持useradd所有选项" class="headerlink" title="支持useradd所有选项"></a>支持useradd所有选项</h5><h5 id="a：与-G合用，增加次要用户组的支持，而非设置"><a href="#a：与-G合用，增加次要用户组的支持，而非设置" class="headerlink" title="-a：与-G合用，增加次要用户组的支持，而非设置"></a>-a：与-G合用，增加次要用户组的支持，而非设置</h5><h5 id="L、-U：锁定、解锁密码（与passwd-lu相同）"><a href="#L、-U：锁定、解锁密码（与passwd-lu相同）" class="headerlink" title="-L、-U：锁定、解锁密码（与passwd -lu相同）"></a>-L、-U：锁定、解锁密码（与passwd -lu相同）</h5><h3 id="userdel-删除用户"><a href="#userdel-删除用户" class="headerlink" title="userdel    删除用户"></a>userdel    删除用户</h3><h4 id="语法：userdel-r-用户名"><a href="#语法：userdel-r-用户名" class="headerlink" title="语法：userdel  [-r]  用户名"></a>语法：userdel  [-r]  用户名</h4><h4 id="选项-23"><a href="#选项-23" class="headerlink" title="选项"></a>选项</h4><h5 id="r：连同家目录一起删除"><a href="#r：连同家目录一起删除" class="headerlink" title="-r：连同家目录一起删除"></a>-r：连同家目录一起删除</h5><h1 id="常见选项含义"><a href="#常见选项含义" class="headerlink" title="常见选项含义"></a>常见选项含义</h1><h2 id="r-R：递归地向下"><a href="#r-R：递归地向下" class="headerlink" title="-r&#x2F;-R：递归地向下"></a>-r&#x2F;-R：递归地向下</h2><h2 id="p：递归地向上"><a href="#p：递归地向上" class="headerlink" title="-p：递归地向上"></a>-p：递归地向上</h2><h2 id="a：all所有"><a href="#a：all所有" class="headerlink" title="-a：all所有"></a>-a：all所有</h2><h2 id="h：将文件容量以人类较易读的方式显示"><a href="#h：将文件容量以人类较易读的方式显示" class="headerlink" title="-h：将文件容量以人类较易读的方式显示"></a>-h：将文件容量以人类较易读的方式显示</h2><h2 id="i：交互模式，询问是否进行操作"><a href="#i：交互模式，询问是否进行操作" class="headerlink" title="-i：交互模式，询问是否进行操作"></a>-i：交互模式，询问是否进行操作</h2><h2 id="f：强制"><a href="#f：强制" class="headerlink" title="-f：强制"></a>-f：强制</h2><h2 id="n：行数-行号"><a href="#n：行数-行号" class="headerlink" title="-n：行数&#x2F;行号"></a>-n：行数&#x2F;行号</h2><h2 id="u：destination比source旧才更新destination"><a href="#u：destination比source旧才更新destination" class="headerlink" title="-u：destination比source旧才更新destination"></a>-u：destination比source旧才更新destination</h2><h2 id="v：显示提示信息-反向选择"><a href="#v：显示提示信息-反向选择" class="headerlink" title="-v：显示提示信息&#x2F;反向选择"></a>-v：显示提示信息&#x2F;反向选择</h2><h1 id="输出：2020-07-14-21-27"><a href="#输出：2020-07-14-21-27" class="headerlink" title="输出：2020&#x2F;07&#x2F;14 21:27"></a>输出：2020&#x2F;07&#x2F;14 21:27</h1><h1 id="默认输出整数"><a href="#默认输出整数" class="headerlink" title="默认输出整数"></a>默认输出整数</h1><h1 id="时间参数可为：now、-分钟数、时：分"><a href="#时间参数可为：now、-分钟数、时：分" class="headerlink" title="时间参数可为：now、+分钟数、时：分"></a>时间参数可为：now、+分钟数、时：分</h1><p>若不加时间参数，默认1分钟后执行操作</p><h1 id="关机操作必须由root执行"><a href="#关机操作必须由root执行" class="headerlink" title="关机操作必须由root执行"></a>关机操作必须由root执行</h1><h1 id="权限对文件与目录有不同的含义，见附图"><a href="#权限对文件与目录有不同的含义，见附图" class="headerlink" title="权限对文件与目录有不同的含义，见附图"></a>权限对文件与目录有不同的含义，见附图</h1><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p><img src="D:/Downloads/588.png" alt="588"></p><h1 id="ls-l所列出的第一位含义"><a href="#ls-l所列出的第一位含义" class="headerlink" title="ls -l所列出的第一位含义"></a>ls -l所列出的第一位含义</h1><h2 id="：常规文件，分为纯文本文件、二进制文件、数据文件"><a href="#：常规文件，分为纯文本文件、二进制文件、数据文件" class="headerlink" title="-：常规文件，分为纯文本文件、二进制文件、数据文件"></a>-：常规文件，分为纯文本文件、二进制文件、数据文件</h2><h2 id="d：目录"><a href="#d：目录" class="headerlink" title="d：目录"></a>d：目录</h2><h2 id="l：符号链接文件（硬链接文件类型为-）"><a href="#l：符号链接文件（硬链接文件类型为-）" class="headerlink" title="l：符号链接文件（硬链接文件类型为-）"></a>l：符号链接文件（硬链接文件类型为-）</h2><h2 id="b：区块设备文件，以区块读写的设备，如磁盘软盘"><a href="#b：区块设备文件，以区块读写的设备，如磁盘软盘" class="headerlink" title="b：区块设备文件，以区块读写的设备，如磁盘软盘"></a>b：区块设备文件，以区块读写的设备，如磁盘软盘</h2><h2 id="c：字符设备文件，串行端口的设备，如键盘鼠标"><a href="#c：字符设备文件，串行端口的设备，如键盘鼠标" class="headerlink" title="c：字符设备文件，串行端口的设备，如键盘鼠标"></a>c：字符设备文件，串行端口的设备，如键盘鼠标</h2><h2 id="s：接口数据文件，用于网络的数据交换"><a href="#s：接口数据文件，用于网络的数据交换" class="headerlink" title="s：接口数据文件，用于网络的数据交换"></a>s：接口数据文件，用于网络的数据交换</h2><h2 id="p：管道文件，先进先出的特殊文件类型"><a href="#p：管道文件，先进先出的特殊文件类型" class="headerlink" title="p：管道文件，先进先出的特殊文件类型"></a>p：管道文件，先进先出的特殊文件类型</h2><h1 id="路径缺省时代表cd"><a href="#路径缺省时代表cd" class="headerlink" title="路径缺省时代表cd ~"></a>路径缺省时代表cd ~</h1><h1 id="可使用别名‘ll’"><a href="#可使用别名‘ll’" class="headerlink" title="可使用别名‘ll’"></a>可使用别名‘ll’</h1><h1 id="mtime、atime、ctime含义见touch"><a href="#mtime、atime、ctime含义见touch" class="headerlink" title="mtime、atime、ctime含义见touch"></a>mtime、atime、ctime含义见touch</h1><h1 id="若无-p选项，复制后目标文件的拥有者通常会变为cp命令的执行者，要注意文件的属性权限"><a href="#若无-p选项，复制后目标文件的拥有者通常会变为cp命令的执行者，要注意文件的属性权限" class="headerlink" title="若无-p选项，复制后目标文件的拥有者通常会变为cp命令的执行者，要注意文件的属性权限"></a>若无-p选项，复制后目标文件的拥有者通常会变为cp命令的执行者，要注意文件的属性权限</h1><h1 id="建议设定别名rm-’rm-i’"><a href="#建议设定别名rm-’rm-i’" class="headerlink" title="建议设定别名rm&#x3D;’rm -i’"></a>建议设定别名rm&#x3D;’rm -i’</h1><h1 id="cp、rm作用于目录都要用-r选项，mv作用于目录不需要"><a href="#cp、rm作用于目录都要用-r选项，mv作用于目录不需要" class="headerlink" title="cp、rm作用于目录都要用-r选项，mv作用于目录不需要"></a>cp、rm作用于目录都要用-r选项，mv作用于目录不需要</h1><h1 id="若无-c，touch默认将文件的三个时间更新为当前时间，若文件不存在则创建新文件"><a href="#若无-c，touch默认将文件的三个时间更新为当前时间，若文件不存在则创建新文件" class="headerlink" title="若无-c，touch默认将文件的三个时间更新为当前时间，若文件不存在则创建新文件"></a>若无-c，touch默认将文件的三个时间更新为当前时间，若文件不存在则创建新文件</h1><h1 id="这两种方式无法更新ctime，只能更新mtime、atime"><a href="#这两种方式无法更新ctime，只能更新mtime、atime" class="headerlink" title="这两种方式无法更新ctime，只能更新mtime、atime"></a>这两种方式无法更新ctime，只能更新mtime、atime</h1><h1 id="使用cp-a时只能复制mtime、atime，不能复制ctime"><a href="#使用cp-a时只能复制mtime、atime，不能复制ctime" class="headerlink" title="使用cp -a时只能复制mtime、atime，不能复制ctime"></a>使用cp -a时只能复制mtime、atime，不能复制ctime</h1><h1 id="ls-l显示的是mtime"><a href="#ls-l显示的是mtime" class="headerlink" title="ls -l显示的是mtime"></a>ls -l显示的是mtime</h1><h1 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h1><h2 id="文件：-rw-rw-rw-666"><a href="#文件：-rw-rw-rw-666" class="headerlink" title="文件：-rw-rw-rw-  666"></a>文件：-rw-rw-rw-  666</h2><h2 id="目录：drwxrwxrwx-777"><a href="#目录：drwxrwxrwx-777" class="headerlink" title="目录：drwxrwxrwx  777"></a>目录：drwxrwxrwx  777</h2><h1 id="rmdir只能删除空目录，非空目录会报错，非空目录要用rm-r"><a href="#rmdir只能删除空目录，非空目录会报错，非空目录要用rm-r" class="headerlink" title="rmdir只能删除空目录，非空目录会报错，非空目录要用rm -r"></a>rmdir只能删除空目录，非空目录会报错，非空目录要用rm -r</h1><h1 id="more不支持PageDown-UP，less功能更全"><a href="#more不支持PageDown-UP，less功能更全" class="headerlink" title="more不支持PageDown&#x2F;UP，less功能更全"></a>more不支持PageDown&#x2F;UP，less功能更全</h1><h1 id="可用管道组合head与tail，打印文件部分行"><a href="#可用管道组合head与tail，打印文件部分行" class="headerlink" title="可用管道组合head与tail，打印文件部分行"></a>可用管道组合head与tail，打印文件部分行</h1><h1 id="whereis与locate查找较快，find较慢且占用磁盘资源，因此优先使用前两个"><a href="#whereis与locate查找较快，find较慢且占用磁盘资源，因此优先使用前两个" class="headerlink" title="whereis与locate查找较快，find较慢且占用磁盘资源，因此优先使用前两个"></a>whereis与locate查找较快，find较慢且占用磁盘资源，因此优先使用前两个</h1><h1 id="whereis只查找与可执行文件、说明文件、源文件相关的特定目录"><a href="#whereis只查找与可执行文件、说明文件、源文件相关的特定目录" class="headerlink" title="whereis只查找与可执行文件、说明文件、源文件相关的特定目录"></a>whereis只查找与可执行文件、说明文件、源文件相关的特定目录</h1><h1 id="xfs文件系统只支持AadiS属性，ext系列支持更多"><a href="#xfs文件系统只支持AadiS属性，ext系列支持更多" class="headerlink" title="xfs文件系统只支持AadiS属性，ext系列支持更多"></a>xfs文件系统只支持AadiS属性，ext系列支持更多</h1><h1 id="Linux的文件系统通常分为数据存放区域（包括inode表和数据区块）和元数据区（包括超级区块、inode对照表、区块对照表）。ext2为传统文件系统，ext3-4、xfs为日志式文件系统，能解决系统中止造成的元数据与数据存放区域不一致问题。"><a href="#Linux的文件系统通常分为数据存放区域（包括inode表和数据区块）和元数据区（包括超级区块、inode对照表、区块对照表）。ext2为传统文件系统，ext3-4、xfs为日志式文件系统，能解决系统中止造成的元数据与数据存放区域不一致问题。" class="headerlink" title="Linux的文件系统通常分为数据存放区域（包括inode表和数据区块）和元数据区（包括超级区块、inode对照表、区块对照表）。ext2为传统文件系统，ext3&#x2F;4、xfs为日志式文件系统，能解决系统中止造成的元数据与数据存放区域不一致问题。"></a>Linux的文件系统通常分为数据存放区域（包括inode表和数据区块）和元数据区（包括超级区块、inode对照表、区块对照表）。ext2为传统文件系统，ext3&#x2F;4、xfs为日志式文件系统，能解决系统中止造成的元数据与数据存放区域不一致问题。</h1><h1 id="最后一个参数为文件-目录时，显示该文件-目录所在文件系统的使用情况"><a href="#最后一个参数为文件-目录时，显示该文件-目录所在文件系统的使用情况" class="headerlink" title="最后一个参数为文件&#x2F;目录时，显示该文件&#x2F;目录所在文件系统的使用情况"></a>最后一个参数为文件&#x2F;目录时，显示该文件&#x2F;目录所在文件系统的使用情况</h1><h1 id="不加任何选项时，du只列出该目录下每个子目录（以及递归的所有子孙目录）与该目录的大小，不列出该目录下文件的大小。默认以1K为单位。"><a href="#不加任何选项时，du只列出该目录下每个子目录（以及递归的所有子孙目录）与该目录的大小，不列出该目录下文件的大小。默认以1K为单位。" class="headerlink" title="不加任何选项时，du只列出该目录下每个子目录（以及递归的所有子孙目录）与该目录的大小，不列出该目录下文件的大小。默认以1K为单位。"></a>不加任何选项时，du只列出该目录下每个子目录（以及递归的所有子孙目录）与该目录的大小，不列出该目录下文件的大小。默认以1K为单位。</h1><h1 id="不加-s，默认建立硬链接"><a href="#不加-s，默认建立硬链接" class="headerlink" title="不加-s，默认建立硬链接"></a>不加-s，默认建立硬链接</h1><h1 id="du用于查看目录-文件的大小，df用于查看文件系统（分区）的使用情况，见附图"><a href="#du用于查看目录-文件的大小，df用于查看文件系统（分区）的使用情况，见附图" class="headerlink" title="du用于查看目录&#x2F;文件的大小，df用于查看文件系统（分区）的使用情况，见附图"></a>du用于查看目录&#x2F;文件的大小，df用于查看文件系统（分区）的使用情况，见附图</h1><h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p><img src="D:/Downloads/1082.png" alt="1082"></p><h1 id="这里设备文件名不能加数字，分区是针对整个磁盘设备（如-dev-sda）而非某个分区或者说文件系统（如-dev-sda1）"><a href="#这里设备文件名不能加数字，分区是针对整个磁盘设备（如-dev-sda）而非某个分区或者说文件系统（如-dev-sda1）" class="headerlink" title="这里设备文件名不能加数字，分区是针对整个磁盘设备（如&#x2F;dev&#x2F;sda）而非某个分区或者说文件系统（如&#x2F;dev&#x2F;sda1）"></a>这里设备文件名不能加数字，分区是针对整个磁盘设备（如&#x2F;dev&#x2F;sda）而非某个分区或者说文件系统（如&#x2F;dev&#x2F;sda1）</h1><h1 id="注意GPT分区表要用gdisk，MBR分区表要用fdisk，不能搞错。处理分区时要先将文件系统卸载。"><a href="#注意GPT分区表要用gdisk，MBR分区表要用fdisk，不能搞错。处理分区时要先将文件系统卸载。" class="headerlink" title="注意GPT分区表要用gdisk，MBR分区表要用fdisk，不能搞错。处理分区时要先将文件系统卸载。"></a>注意GPT分区表要用gdisk，MBR分区表要用fdisk，不能搞错。处理分区时要先将文件系统卸载。</h1><h1 id="对磁盘进行分区的步骤通常为：用lsblk或blkid找到磁盘，用parted-print查看分区表类型，再根据类型选择gdisk或fdisk进行分区，partprobe更新内核信息，再用mkfs进行格式化，最后用mount进行挂载，写入-etc-fstab的相关行"><a href="#对磁盘进行分区的步骤通常为：用lsblk或blkid找到磁盘，用parted-print查看分区表类型，再根据类型选择gdisk或fdisk进行分区，partprobe更新内核信息，再用mkfs进行格式化，最后用mount进行挂载，写入-etc-fstab的相关行" class="headerlink" title="对磁盘进行分区的步骤通常为：用lsblk或blkid找到磁盘，用parted print查看分区表类型，再根据类型选择gdisk或fdisk进行分区，partprobe更新内核信息，再用mkfs进行格式化，最后用mount进行挂载，写入&#x2F;etc&#x2F;fstab的相关行"></a>对磁盘进行分区的步骤通常为：用lsblk或blkid找到磁盘，用parted print查看分区表类型，再根据类型选择gdisk或fdisk进行分区，partprobe更新内核信息，再用mkfs进行格式化，最后用mount进行挂载，写入&#x2F;etc&#x2F;fstab的相关行</h1><h1 id="一个文件系统（设备文件名-分区）与一个挂载点（目录）应该一一对应。如果原目录非空，挂载后原文件会被暂时隐藏。一个磁盘（-dev-sda）进行分区后就分成了各分区（partition），各分区对应Linux中一个设备文件（-dev-sda1），对分区进行格式化后就成了文件系统（filesystem），最后将文件系统挂载（mount）在一个挂载点（目录）上，即可使用。"><a href="#一个文件系统（设备文件名-分区）与一个挂载点（目录）应该一一对应。如果原目录非空，挂载后原文件会被暂时隐藏。一个磁盘（-dev-sda）进行分区后就分成了各分区（partition），各分区对应Linux中一个设备文件（-dev-sda1），对分区进行格式化后就成了文件系统（filesystem），最后将文件系统挂载（mount）在一个挂载点（目录）上，即可使用。" class="headerlink" title="一个文件系统（设备文件名&#x2F;分区）与一个挂载点（目录）应该一一对应。如果原目录非空，挂载后原文件会被暂时隐藏。一个磁盘（&#x2F;dev&#x2F;sda）进行分区后就分成了各分区（partition），各分区对应Linux中一个设备文件（&#x2F;dev&#x2F;sda1），对分区进行格式化后就成了文件系统（filesystem），最后将文件系统挂载（mount）在一个挂载点（目录）上，即可使用。"></a>一个文件系统（设备文件名&#x2F;分区）与一个挂载点（目录）应该一一对应。如果原目录非空，挂载后原文件会被暂时隐藏。一个磁盘（&#x2F;dev&#x2F;sda）进行分区后就分成了各分区（partition），各分区对应Linux中一个设备文件（&#x2F;dev&#x2F;sda1），对分区进行格式化后就成了文件系统（filesystem），最后将文件系统挂载（mount）在一个挂载点（目录）上，即可使用。</h1><h1 id="这里设备文件名要加数字，格式化是对一个分区（如-dev-sda1）进行格式化，创建文件系统"><a href="#这里设备文件名要加数字，格式化是对一个分区（如-dev-sda1）进行格式化，创建文件系统" class="headerlink" title="这里设备文件名要加数字，格式化是对一个分区（如&#x2F;dev&#x2F;sda1）进行格式化，创建文件系统"></a>这里设备文件名要加数字，格式化是对一个分区（如&#x2F;dev&#x2F;sda1）进行格式化，创建文件系统</h1><h1 id="这里设备文件名要加数字，挂载是对文件系统-分区而言。推荐使用UUID进行挂载，避免更换设备导致设备文件名不一致。"><a href="#这里设备文件名要加数字，挂载是对文件系统-分区而言。推荐使用UUID进行挂载，避免更换设备导致设备文件名不一致。" class="headerlink" title="这里设备文件名要加数字，挂载是对文件系统&#x2F;分区而言。推荐使用UUID进行挂载，避免更换设备导致设备文件名不一致。"></a>这里设备文件名要加数字，挂载是对文件系统&#x2F;分区而言。推荐使用UUID进行挂载，避免更换设备导致设备文件名不一致。</h1><h1 id="要将工作目录退出文件系统后才能卸载该文件系统"><a href="#要将工作目录退出文件系统后才能卸载该文件系统" class="headerlink" title="要将工作目录退出文件系统后才能卸载该文件系统"></a>要将工作目录退出文件系统后才能卸载该文件系统</h1><h1 id="UUID可用uuidgen命令生成"><a href="#UUID可用uuidgen命令生成" class="headerlink" title="UUID可用uuidgen命令生成"></a>UUID可用uuidgen命令生成</h1><h1 id="删除磁盘分区的步骤为：用umount卸载分区，删除-etc-fstab的相关行，用gdisk删除分区，partprobe更新内核信息"><a href="#删除磁盘分区的步骤为：用umount卸载分区，删除-etc-fstab的相关行，用gdisk删除分区，partprobe更新内核信息" class="headerlink" title="删除磁盘分区的步骤为：用umount卸载分区，删除&#x2F;etc&#x2F;fstab的相关行，用gdisk删除分区，partprobe更新内核信息"></a>删除磁盘分区的步骤为：用umount卸载分区，删除&#x2F;etc&#x2F;fstab的相关行，用gdisk删除分区，partprobe更新内核信息</h1><h1 id="gzip默认压缩后会删除源文件。使用-c并重定向到文件可以保留源文件，如gzip-c-services-services-gz"><a href="#gzip默认压缩后会删除源文件。使用-c并重定向到文件可以保留源文件，如gzip-c-services-services-gz" class="headerlink" title="gzip默认压缩后会删除源文件。使用-c并重定向到文件可以保留源文件，如gzip -c services &gt; services.gz"></a>gzip默认压缩后会删除源文件。使用-c并重定向到文件可以保留源文件，如gzip -c services &gt; services.gz</h1><h1 id="gzip-d会在解压后删除原压缩文件-gz"><a href="#gzip-d会在解压后删除原压缩文件-gz" class="headerlink" title="gzip -d会在解压后删除原压缩文件.gz"></a>gzip -d会在解压后删除原压缩文件.gz</h1><h1 id="gzip可向下兼容解压compress、zip的压缩文件"><a href="#gzip可向下兼容解压compress、zip的压缩文件" class="headerlink" title="gzip可向下兼容解压compress、zip的压缩文件"></a>gzip可向下兼容解压compress、zip的压缩文件</h1><h1 id="压缩率xz最好，但时间xz最差"><a href="#压缩率xz最好，但时间xz最差" class="headerlink" title="压缩率xz最好，但时间xz最差"></a>压缩率xz最好，但时间xz最差</h1><h1 id="要解开的单一文件名要通过-t-选项查找到正确的文件名"><a href="#要解开的单一文件名要通过-t-选项查找到正确的文件名" class="headerlink" title="要解开的单一文件名要通过 -t 选项查找到正确的文件名"></a>要解开的单一文件名要通过 -t 选项查找到正确的文件名</h1><h1 id="这里打包后的文件名要符合上面压缩文件命名规范，如-tar-gz等。由于tar会打包时会把目录结构打进去，因此强烈建议不使用绝对路径，打包前先cd到目标目录，tar命令中使用相对路径，如cd-home-fly-tobetar-tar-cz-f-zipfile"><a href="#这里打包后的文件名要符合上面压缩文件命名规范，如-tar-gz等。由于tar会打包时会把目录结构打进去，因此强烈建议不使用绝对路径，打包前先cd到目标目录，tar命令中使用相对路径，如cd-home-fly-tobetar-tar-cz-f-zipfile" class="headerlink" title="这里打包后的文件名要符合上面压缩文件命名规范，如*.tar.gz等。由于tar会打包时会把目录结构打进去，因此强烈建议不使用绝对路径，打包前先cd到目标目录，tar命令中使用相对路径，如cd &#x2F;home&#x2F;fly&#x2F;tobetar&#x2F; &amp;&amp; tar -cz -f ${zipfile} .&#x2F;*"></a>这里打包后的文件名要符合上面压缩文件命名规范，如*.tar.gz等。由于tar会打包时会把目录结构打进去，因此强烈建议不使用绝对路径，打包前先cd到目标目录，tar命令中使用相对路径，如cd &#x2F;home&#x2F;fly&#x2F;tobetar&#x2F; &amp;&amp; tar -cz -f ${zipfile} .&#x2F;*</h1><h1 id="xfsdump只能备份独立的文件系统，使用前要用df确认是一个独立挂载的文件系统"><a href="#xfsdump只能备份独立的文件系统，使用前要用df确认是一个独立挂载的文件系统" class="headerlink" title="xfsdump只能备份独立的文件系统，使用前要用df确认是一个独立挂载的文件系统"></a>xfsdump只能备份独立的文件系统，使用前要用df确认是一个独立挂载的文件系统</h1><h1 id="完整备份时填0，增量备份时依次填1-9"><a href="#完整备份时填0，增量备份时依次填1-9" class="headerlink" title="完整备份时填0，增量备份时依次填1~9"></a>完整备份时填0，增量备份时依次填1~9</h1><h1 id="可以如tar的-f一样接磁带名-dev-st0"><a href="#可以如tar的-f一样接磁带名-dev-st0" class="headerlink" title="可以如tar的-f一样接磁带名&#x2F;dev&#x2F;st0"></a>可以如tar的-f一样接磁带名&#x2F;dev&#x2F;st0</h1><h1 id="可以如tar的-f一样接磁带名-dev-st0-1"><a href="#可以如tar的-f一样接磁带名-dev-st0-1" class="headerlink" title="可以如tar的-f一样接磁带名&#x2F;dev&#x2F;st0"></a>可以如tar的-f一样接磁带名&#x2F;dev&#x2F;st0</h1><h1 id="恢复时也要按备份时的顺序，从level-0到level-9-依次恢复"><a href="#恢复时也要按备份时的顺序，从level-0到level-9-依次恢复" class="headerlink" title="恢复时也要按备份时的顺序，从level 0到level 9 依次恢复"></a>恢复时也要按备份时的顺序，从level 0到level 9 依次恢复</h1><h1 id="备份时要进入待备份目录再find，避免加上绝对路径-。还原时要进入相应目录解包。"><a href="#备份时要进入待备份目录再find，避免加上绝对路径-。还原时要进入相应目录解包。" class="headerlink" title="备份时要进入待备份目录再find，避免加上绝对路径&#x2F;。还原时要进入相应目录解包。"></a>备份时要进入待备份目录再find，避免加上绝对路径&#x2F;。还原时要进入相应目录解包。</h1><h1 id="几种与备份相关的命令比较"><a href="#几种与备份相关的命令比较" class="headerlink" title="几种与备份相关的命令比较"></a>几种与备份相关的命令比较</h1><h2 id="tar：常用于目录的备份，可以进行打包及压缩操作"><a href="#tar：常用于目录的备份，可以进行打包及压缩操作" class="headerlink" title="tar：常用于目录的备份，可以进行打包及压缩操作"></a>tar：常用于目录的备份，可以进行打包及压缩操作</h2><h2 id="xfsdump：常用于整个文件系统的备份，并可以增量备份"><a href="#xfsdump：常用于整个文件系统的备份，并可以增量备份" class="headerlink" title="xfsdump：常用于整个文件系统的备份，并可以增量备份"></a>xfsdump：常用于整个文件系统的备份，并可以增量备份</h2><h2 id="dd：常用于整个磁盘或设备的备份，因为dd是按块读取，直接读取扇区，可以完整的备份磁盘整个扇区表面的数据（包括启动扇区、超级块、元数据）。新的分区不需要格式化，可以直接拷贝过去。"><a href="#dd：常用于整个磁盘或设备的备份，因为dd是按块读取，直接读取扇区，可以完整的备份磁盘整个扇区表面的数据（包括启动扇区、超级块、元数据）。新的分区不需要格式化，可以直接拷贝过去。" class="headerlink" title="dd：常用于整个磁盘或设备的备份，因为dd是按块读取，直接读取扇区，可以完整的备份磁盘整个扇区表面的数据（包括启动扇区、超级块、元数据）。新的分区不需要格式化，可以直接拷贝过去。"></a>dd：常用于整个磁盘或设备的备份，因为dd是按块读取，直接读取扇区，可以完整的备份磁盘整个扇区表面的数据（包括启动扇区、超级块、元数据）。新的分区不需要格式化，可以直接拷贝过去。</h2><h2 id="cpio：拷贝to-from-cpio格式的文件，可以备份任何文件，包括设备文件，但需要配合find命令，详见私房菜P284"><a href="#cpio：拷贝to-from-cpio格式的文件，可以备份任何文件，包括设备文件，但需要配合find命令，详见私房菜P284" class="headerlink" title="cpio：拷贝to&#x2F;from cpio格式的文件，可以备份任何文件，包括设备文件，但需要配合find命令，详见私房菜P284"></a>cpio：拷贝to&#x2F;from cpio格式的文件，可以备份任何文件，包括设备文件，但需要配合find命令，详见私房菜P284</h2><h1 id="回环设备的用途：在原分区中划分出一个新分区、用文件模拟创建swap分区"><a href="#回环设备的用途：在原分区中划分出一个新分区、用文件模拟创建swap分区" class="headerlink" title="回环设备的用途：在原分区中划分出一个新分区、用文件模拟创建swap分区"></a>回环设备的用途：在原分区中划分出一个新分区、用文件模拟创建swap分区</h1><h1 id="子进程仅会继承父进程的环境变量，不会继承父进程的自定义变量"><a href="#子进程仅会继承父进程的环境变量，不会继承父进程的自定义变量" class="headerlink" title="子进程仅会继承父进程的环境变量，不会继承父进程的自定义变量"></a>子进程仅会继承父进程的环境变量，不会继承父进程的自定义变量</h1><h1 id="登录时bash配置文件的读取顺序详见私房菜P339"><a href="#登录时bash配置文件的读取顺序详见私房菜P339" class="headerlink" title="登录时bash配置文件的读取顺序详见私房菜P339"></a>登录时bash配置文件的读取顺序详见私房菜P339</h1><h1 id="减号放在文件名的位置，可以代表此处文件由stdin输入或由stdout输出，如："><a href="#减号放在文件名的位置，可以代表此处文件由stdin输入或由stdout输出，如：" class="headerlink" title="减号放在文件名的位置，可以代表此处文件由stdin输入或由stdout输出，如："></a>减号放在文件名的位置，可以代表此处文件由stdin输入或由stdout输出，如：</h1><p>tar  -cv  -f  -  &#x2F;home  |  tar  -xv  -f  -  -C  &#x2F;tmp&#x2F;homeback</p><h1 id="ls不支持stdin输入，使用xargs后由管道传来的stdin解析出参数，填入ls-l后面"><a href="#ls不支持stdin输入，使用xargs后由管道传来的stdin解析出参数，填入ls-l后面" class="headerlink" title="ls不支持stdin输入，使用xargs后由管道传来的stdin解析出参数，填入ls  -l后面"></a>ls不支持stdin输入，使用xargs后由管道传来的stdin解析出参数，填入ls  -l后面</h1><h1 id="将管道传来的stdin（find找到的文件名列表）解析为参数（一个个文件名）填入wc-l后面。此条命令的作用是查询-home下每个java文件各自的行数"><a href="#将管道传来的stdin（find找到的文件名列表）解析为参数（一个个文件名）填入wc-l后面。此条命令的作用是查询-home下每个java文件各自的行数" class="headerlink" title="将管道传来的stdin（find找到的文件名列表）解析为参数（一个个文件名）填入wc -l后面。此条命令的作用是查询&#x2F;home下每个java文件各自的行数"></a>将管道传来的stdin（find找到的文件名列表）解析为参数（一个个文件名）填入wc -l后面。此条命令的作用是查询&#x2F;home下每个java文件各自的行数</h1><h1 id="将管道传来的stdin直接作为标准输入（find找到的文件名列表）输入到wc-l中。此条命令的作用是查询-home下java文件的数量"><a href="#将管道传来的stdin直接作为标准输入（find找到的文件名列表）输入到wc-l中。此条命令的作用是查询-home下java文件的数量" class="headerlink" title="将管道传来的stdin直接作为标准输入（find找到的文件名列表）输入到wc -l中。此条命令的作用是查询&#x2F;home下java文件的数量"></a>将管道传来的stdin直接作为标准输入（find找到的文件名列表）输入到wc -l中。此条命令的作用是查询&#x2F;home下java文件的数量</h1><h1 id="string可以使用正则表达式"><a href="#string可以使用正则表达式" class="headerlink" title="string可以使用正则表达式"></a>string可以使用正则表达式</h1><h1 id="注意单引号中出现的非变量的文字部分要用双引号括起来"><a href="#注意单引号中出现的非变量的文字部分要用双引号括起来" class="headerlink" title="注意单引号中出现的非变量的文字部分要用双引号括起来"></a>注意单引号中出现的非变量的文字部分要用双引号括起来</h1><h1 id="grep、sed、awk并称Linux三剑客"><a href="#grep、sed、awk并称Linux三剑客" class="headerlink" title="grep、sed、awk并称Linux三剑客"></a>grep、sed、awk并称Linux三剑客</h1><h1 id="每次丢一个参数给id命令来执行"><a href="#每次丢一个参数给id命令来执行" class="headerlink" title="每次丢一个参数给id命令来执行"></a>每次丢一个参数给id命令来执行</h1><h1 id="依据前一个命令的-变量返回值判定，若-0，则执行cmd2，若-≠0，则不执行。"><a href="#依据前一个命令的-变量返回值判定，若-0，则执行cmd2，若-≠0，则不执行。" class="headerlink" title="依据前一个命令的 $? 变量返回值判定，若$?&#x3D;0，则执行cmd2，若$?≠0，则不执行。"></a>依据前一个命令的 $? 变量返回值判定，若$?&#x3D;0，则执行cmd2，若$?≠0，则不执行。</h1><p>$?：上一个命令返回值，当命令成功执行时返回0，否则返回非0值。</p><h1 id="用户的GID（-etc-passwd第4字段）决定了初始用户组（通常与用户名同名）"><a href="#用户的GID（-etc-passwd第4字段）决定了初始用户组（通常与用户名同名）" class="headerlink" title="用户的GID（&#x2F;etc&#x2F;passwd第4字段）决定了初始用户组（通常与用户名同名）"></a>用户的GID（&#x2F;etc&#x2F;passwd第4字段）决定了初始用户组（通常与用户名同名）</h1><h1 id="一般用户只能修改自己密码，需要输入旧密码，且密码规范较严。root用户可修改自己及他人密码，不需要输入旧密码，且可以用较为简单的密码。"><a href="#一般用户只能修改自己密码，需要输入旧密码，且密码规范较严。root用户可修改自己及他人密码，不需要输入旧密码，且可以用较为简单的密码。" class="headerlink" title="一般用户只能修改自己密码，需要输入旧密码，且密码规范较严。root用户可修改自己及他人密码，不需要输入旧密码，且可以用较为简单的密码。"></a>一般用户只能修改自己密码，需要输入旧密码，且密码规范较严。root用户可修改自己及他人密码，不需要输入旧密码，且可以用较为简单的密码。</h1><h1 id="只可root使用"><a href="#只可root使用" class="headerlink" title="只可root使用"></a>只可root使用</h1><h1 id="若账号只是暂时不启用，可以将账户失效日设为1970-01-01"><a href="#若账号只是暂时不启用，可以将账户失效日设为1970-01-01" class="headerlink" title="若账号只是暂时不启用，可以将账户失效日设为1970-01-01"></a>若账号只是暂时不启用，可以将账户失效日设为1970-01-01</h1><h1 id="useradd、usermod、userdel只有root可以使用"><a href="#useradd、usermod、userdel只有root可以使用" class="headerlink" title="useradd、usermod、userdel只有root可以使用"></a>useradd、usermod、userdel只有root可以使用</h1><h1 id="只有root可设置"><a href="#只有root可设置" class="headerlink" title="只有root可设置"></a>只有root可设置</h1><h1 id="三个选项之间不可共存。不加这三个选项，表示仅作打包，filename要取为-tar；加这三个选项，表示同时使用压缩技术，filename要取为-tar-gz、-tar-bz2、-tar-xz"><a href="#三个选项之间不可共存。不加这三个选项，表示仅作打包，filename要取为-tar；加这三个选项，表示同时使用压缩技术，filename要取为-tar-gz、-tar-bz2、-tar-xz" class="headerlink" title="三个选项之间不可共存。不加这三个选项，表示仅作打包，filename要取为*.tar；加这三个选项，表示同时使用压缩技术，filename要取为*.tar.gz、*.tar.bz2、*.tar.xz"></a>三个选项之间不可共存。不加这三个选项，表示仅作打包，filename要取为*.tar；加这三个选项，表示同时使用压缩技术，filename要取为*.tar.gz、*.tar.bz2、*.tar.xz</h1><h1 id="三个选项之间不可共存"><a href="#三个选项之间不可共存" class="headerlink" title="三个选项之间不可共存"></a>三个选项之间不可共存</h1><h1 id="光盘写入工具，详见私房菜P277"><a href="#光盘写入工具，详见私房菜P277" class="headerlink" title="光盘写入工具，详见私房菜P277"></a>光盘写入工具，详见私房菜P277</h1>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bash/Shell/Linux速查表</title>
    <link href="/posts/213f.html"/>
    <url>/posts/213f.html</url>
    
    <content type="html"><![CDATA[<h2 id="Bash-Shell脚本语法与Linux常用命令速查表"><a href="#Bash-Shell脚本语法与Linux常用命令速查表" class="headerlink" title="Bash&#x2F;Shell脚本语法与Linux常用命令速查表"></a>Bash&#x2F;Shell脚本语法与Linux常用命令速查表</h2><p>转载自<a href="https://github.com/skywind3000/awesome-cheatsheets">awesome-cheatsheets</a>，作者：skywind3000，侵删</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">BASH CHEATSHEET (中文速查表)  -  by skywind (created on 2018/02/14)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Version: 47, Last Modified: 2019/09/24 17:58</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">https://github.com/skywind3000/awesome-cheatsheets</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">常用快捷键（默认使用 Emacs 键位）</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>CTRL+A              # 移动到行首，同 &lt;Home&gt;<br>CTRL+B              # 向后移动，同 &lt;Left&gt;<br>CTRL+C              # 结束当前命令<br>CTRL+D              # 删除光标前的字符，同 &lt;Delete&gt; ，或者没有内容时，退出会话<br>CTRL+E              # 移动到行末，同 &lt;End&gt;<br>CTRL+F              # 向前移动，同 &lt;Right&gt;<br>CTRL+G              # 退出当前编辑（比如正在 CTRL+R 搜索历史时）<br>CTRL+H              # 删除光标左边的字符，同 &lt;Backspace&gt;<br>CTRL+K              # 删除光标位置到行末的内容<br>CTRL+L              # 清屏并重新显示<br>CTRL+N              # 移动到命令历史的下一行，同 &lt;Down&gt;<br>CTRL+O              # 类似回车，但是会显示下一行历史<br>CTRL+P              # 移动到命令历史的上一行，同 &lt;Up&gt;<br>CTRL+R              # 历史命令反向搜索，使用 CTRL+G 退出搜索<br>CTRL+S              # 历史命令正向搜索，使用 CTRL+G 退出搜索<br>CTRL+T              # 交换前后两个字符<br>CTRL+U              # 删除字符到行首<br>CTRL+V              # 输入字符字面量，先按 CTRL+V 再按任意键<br>CTRL+W              # 删除光标左边的一个单词<br>CTRL+X              # 列出可能的补全<br>CTRL+Y              # 粘贴前面 CTRL+u/k/w 删除过的内容<br>CTRL+Z              # 暂停前台进程返回 bash，需要时可用 fg 将其切换回前台<br>CTRL+_              # 撤销（undo），有的终端将 CTRL+_ 映射为 CTRL+/ 或 CTRL+7<br><br>ALT+b               # 向后（左边）移动一个单词<br>ALT+d               # 删除光标后（右边）一个单词<br>ALT+f               # 向前（右边）移动一个单词<br>ALT+t               # 交换字符<br>ALT+BACKSPACE       # 删除光标前面一个单词，类似 CTRL+W，但不影响剪贴板<br><br>CTRL+X CTRL+X       # 连续按两次 CTRL+X，光标在当前位置和行首来回跳转 <br>CTRL+X CTRL+E       # 用你指定的编辑器，编辑当前命令<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">BASH 基本操作</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>exit                # 退出当前登录<br>env                 # 显示环境变量<br>echo $SHELL         # 显示你在使用什么 SHELL<br><br>bash                # 使用 bash，用 exit 返回<br>which bash          # 搜索 $PATH，查找哪个程序对应命令 bash<br>whereis bash        # 搜索可执行，头文件和帮助信息的位置，使用系统内建数据库<br>whatis bash         # 查看某个命令的解释，一句话告诉你这是干什么的<br><br>clear               # 清初屏幕内容<br>reset               # 重置终端（当你不小心 cat 了一个二进制，终端状态乱掉时使用）<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">目录操作</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>cd                  # 返回自己 $HOME 目录<br>cd &#123;dirname&#125;        # 进入目录<br>pwd                 # 显示当前所在目录<br>mkdir &#123;dirname&#125;     # 创建目录<br>mkdir -p &#123;dirname&#125;  # 递归创建目录<br>pushd &#123;dirname&#125;     # 目录压栈并进入新目录<br>popd                # 弹出并进入栈顶的目录<br>dirs -v             # 列出当前目录栈<br>cd -                # 回到之前的目录<br>cd -&#123;N&#125;             # 切换到目录栈中的第 N个目录，比如 cd -2 将切换到第二个<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">文件操作</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>ls                  # 显示当前目录内容，后面可接目录名：ls &#123;dir&#125; 显示指定目录<br>ls -l               # 列表方式显示目录内容，包括文件日期，大小，权限等信息<br>ls -1               # 列表方式显示目录内容，只显示文件名称，减号后面是数字 1<br>ls -a               # 显示所有文件和目录，包括隐藏文件（.开头的文件/目录名）<br>ln -s &#123;fn&#125; &#123;link&#125;   # 给指定文件创建一个软链接<br>cp &#123;src&#125; &#123;dest&#125;     # 拷贝文件，cp -r dir1 dir2 可以递归拷贝（目录）<br>rm &#123;fn&#125;             # 删除文件，rm -r 递归删除目录，rm -f 强制删除<br>mv &#123;src&#125; &#123;dest&#125;     # 移动文件，如果 dest 是目录，则移动，是文件名则覆盖<br>touch &#123;fn&#125;          # 创建或者更新一下制定文件<br>cat &#123;fn&#125;            # 输出文件原始内容<br>any_cmd &gt; &#123;fn&#125;      # 执行任意命令并将标准输出重定向到指定文件<br>more &#123;fn&#125;           # 逐屏显示某文件内容，空格翻页，q 退出<br>less &#123;fn&#125;           # 更高级点的 more，更多操作，q 退出<br>head &#123;fn&#125;           # 显示文件头部数行，可用 head -3 abc.txt 显示头三行<br>tail &#123;fn&#125;           # 显示文件尾部数行，可用 tail -3 abc.txt 显示尾部三行<br>tail -f &#123;fn&#125;        # 持续显示文件尾部数据，可用于监控日志<br>nano &#123;fn&#125;           # 使用 nano 编辑器编辑文件<br>vim &#123;fn&#125;            # 使用 vim 编辑文件<br>diff &#123;f1&#125; &#123;f2&#125;      # 比较两个文件的内容<br>wc &#123;fn&#125;             # 统计文件有多少行，多少个单词<br>chmod 644 &#123;fn&#125;      # 修改文件权限为 644，可以接 -R 对目录循环改权限<br>chgrp group &#123;fn&#125;    # 修改文件所属的用户组<br>chown user1 &#123;fn&#125;    # 修改文件所有人为 user1, chown user1:group1 fn 可以修改组<br>file &#123;fn&#125;           # 检测文件的类型和编码<br>basename &#123;fn&#125;       # 查看文件的名字（不包括路径）<br>dirname &#123;fn&#125;        # 查看文件的路径（不包括名字）<br>grep &#123;pat&#125; &#123;fn&#125;     # 在文件中查找出现过 pat 的内容<br>grep -r &#123;pat&#125; .     # 在当前目录下递归查找所有出现过 pat 的文件内容<br>stat &#123;fn&#125;           # 显示文件的详细信息<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">用户管理</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>whoami              # 显示我的用户名<br>who                 # 显示已登录用户信息，w / who / users 内容略有不同<br>w                   # 显示已登录用户信息，w / who / users 内容略有不同<br>users               # 显示已登录用户信息，w / who / users 内容略有不同<br>passwd              # 修改密码，passwd &#123;user&#125; 可以用于 root 修改别人密码<br>finger &#123;user&#125;       # 显示某用户信息，包括 id, 名字, 登录状态等<br>adduser &#123;user&#125;      # 添加用户<br>deluser &#123;user&#125;      # 删除用户<br>w                   # 查看谁在线<br>su                  # 切换到 root 用户<br>su -                # 切换到 root 用户并登录（执行登录脚本）<br>su &#123;user&#125;           # 切换到某用户<br>su -&#123;user&#125;          # 切换到某用户并登录（执行登录脚本）<br>id &#123;user&#125;           # 查看用户的 uid，gid 以及所属其他用户组<br>id -u &#123;user&#125;        # 打印用户 uid<br>id -g &#123;user&#125;        # 打印用户 gid<br>write &#123;user&#125;        # 向某用户发送一句消息<br>last                # 显示最近用户登录列表<br>last &#123;user&#125;         # 显示登录记录<br>lastb               # 显示失败登录记录<br>lastlog             # 显示所有用户的最近登录记录<br>sudo &#123;command&#125;      # 以 root 权限执行某命令<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">进程管理</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>ps                        # 查看当前会话进程<br>ps ax                     # 查看所有进程，类似 ps -e<br>ps aux                    # 查看所有进程详细信息，类似 ps -ef<br>ps auxww                  # 查看所有进程，并且显示进程的完整启动命令<br>ps -u &#123;user&#125;              # 查看某用户进程<br>ps axjf                   # 列出进程树<br>ps xjf -u &#123;user&#125;          # 列出某用户的进程树<br>ps -eo pid,user,command   # 按用户指定的格式查看进程<br>ps aux | grep httpd       # 查看名为 httpd 的所有进程<br>ps --ppid &#123;pid&#125;           # 查看父进程为 pid 的所有进程<br>pstree                    # 树形列出所有进程，pstree 默认一般不带，需安装<br>pstree &#123;user&#125;             # 进程树列出某用户的进程<br>pstree -u                 # 树形列出所有进程以及所属用户<br>pgrep &#123;procname&#125;          # 搜索名字匹配的进程的 pid，比如 pgrep apache2<br><br>kill &#123;pid&#125;                # 结束进程<br>kill -9 &#123;pid&#125;             # 强制结束进程，9/SIGKILL 是强制不可捕获结束信号<br>kill -KILL &#123;pid&#125;          # 强制执行进程，kill -9 的另外一种写法<br>kill -l                   # 查看所有信号<br>kill -l TERM              # 查看 TERM 信号的编号<br>killall &#123;procname&#125;        # 按名称结束所有进程<br>pkill &#123;procname&#125;          # 按名称结束进程，除名称外还可以有其他参数<br><br>top                       # 查看最活跃的进程<br>top -u &#123;user&#125;             # 查看某用户最活跃的进程<br><br>any_command &amp;             # 在后台运行某命令，也可用 CTRL+Z 将当前进程挂到后台<br>jobs                      # 查看所有后台进程（jobs）<br>bg                        # 查看后台进程，并切换过去<br>fg                        # 切换后台进程到前台<br>fg &#123;job&#125;                  # 切换特定后台进程到前台<br><br>trap cmd sig1 sig2        # 在脚本中设置信号处理命令<br>trap &quot;&quot; sig1 sig2         # 在脚本中屏蔽某信号<br>trap - sig1 sig2          # 恢复默认信号处理行为<br><br>nohup &#123;command&#125;           # 长期运行某程序，在你退出登录都保持它运行<br>nohup &#123;command&#125; &amp;         # 在后台长期运行某程序<br>disown &#123;PID|JID&#125;          # 将进程从后台任务列表（jobs）移除<br><br>wait                      # 等待所有后台进程任务结束<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">常用命令：SSH / 系统信息 / 网络</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>ssh user@host             # 以用户 user 登录到远程主机 host<br>ssh -p &#123;port&#125; user@host   # 指定端口登录主机<br>ssh-copy-id user@host     # 拷贝你的 ssh key 到远程主机，避免重复输入密码<br>scp &#123;fn&#125; user@host:path   # 拷贝文件到远程主机<br>scp user@host:path dest   # 从远程主机拷贝文件回来<br>scp -P &#123;port&#125; ...         # 指定端口远程拷贝文件<br><br>uname -a                  # 查看内核版本等信息<br>man &#123;help&#125;                # 查看帮助<br>man -k &#123;keyword&#125;          # 查看哪些帮助文档里包含了该关键字<br>info &#123;help&#125;               # 查看 info pages，比 man 更强的帮助系统<br>uptime                    # 查看系统启动时间<br>date                      # 显示日期<br>cal                       # 显示日历<br>vmstat                    # 显示内存和 CPU 使用情况<br>vmstat 10                 # 每 10 秒打印一行内存和 CPU情况，CTRL+C 退出<br>free                      # 显示内存和交换区使用情况<br>df                        # 显示磁盘使用情况<br>du                        # 显示当前目录占用，du . --max-depth=2 可以指定深度<br>du -h                     # 显示当前目录占用，-h 以方便阅读的格式输出 (K/M/G)<br>uname                     # 显示系统版本号<br>hostname                  # 显示主机名称<br>showkey -a                # 查看终端发送的按键编码<br><br>ping &#123;host&#125;               # ping 远程主机并显示结果，CTRL+C 退出<br>ping -c N &#123;host&#125;          # ping 远程主机 N 次<br>traceroute &#123;host&#125;         # 侦测路由连通情况<br>mtr &#123;host&#125;                # 高级版本 traceroute<br>host &#123;domain&#125;             # DNS 查询，&#123;domain&#125; 前面可加 -a 查看详细信息<br>whois &#123;domain&#125;            # 取得域名 whois 信息<br>dig &#123;domain&#125;              # 取得域名 dns 信息<br>route -n                  # 查看路由表<br>netstat -a                # 列出所有端口<br>netstat -an               # 查看所有连接信息，不解析域名<br>netstat -anp              # 查看所有连接信息，包含进程信息（需要 sudo）<br>netstat -l                # 查看所有监听的端口<br>netstat -t                # 查看所有 TCP 链接<br>netstat -lntu             # 显示所有正在监听的 TCP 和 UDP 信息<br>netstat -lntup            # 显示所有正在监听的 socket 及进程信息<br>netstat -i                # 显示网卡信息<br>netstat -rn               # 显示当前系统路由表，同 route -n<br>ss -an                    # 比 netstat -an 更快速更详细<br>ss -s                     # 统计 TCP 的 established, wait 等<br><br>wget &#123;url&#125;                # 下载文件，可加 --no-check-certificate 忽略 ssl 验证<br>wget -qO- &#123;url&#125;           # 下载文件并输出到标准输出（不保存）<br>curl -sL &#123;url&#125;            # 同 wget -qO- &#123;url&#125; 没有 wget 的时候使用<br><br>sz &#123;file&#125;                 # 发送文件到终端，zmodem 协议<br>rz                        # 接收终端发送过来的文件<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">变量操作</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>varname=value             # 定义变量<br>varname=value command     # 定义子进程变量并执行子进程<br>echo &quot;$varname&quot;           # 查看变量内容<br>echo $$                   # 查看当前 shell 的进程号<br>echo $!                   # 查看最近调用的后台任务进程号<br>echo $?                   # 查看最近一条命令的返回码<br>export VARNAME=value      # 设置环境变量（将会影响到子进程）<br><br>array[0]=valA             # 定义数组<br>array[1]=valB<br>array[2]=valC<br>array=([0]=valA [1]=valB [2]=valC)   # 另一种方式<br>array=(valA valB valC)               # 另一种方式<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;array[i]&#125;               <span class="hljs-comment"># 取得数组中的元素</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;#array[@]&#125;              <span class="hljs-comment"># 取得数组的长度</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;#array[i]&#125;              <span class="hljs-comment"># 取得数组中某个变量的长度</span></span><br><br>declare -a                # 查看所有数组<br>declare -f                # 查看所有函数<br>declare -F                # 查看所有函数，仅显示函数名<br>declare -i                # 查看所有整数<br>declare -r                # 查看所有只读变量<br>declare -x                # 查看所有被导出成环境变量的东西<br>declare -p varname        # 输出变量是怎么定义的（类型+值）<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;varname:-word&#125;          <span class="hljs-comment"># 如果变量不为空则返回变量，否则返回 word</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;varname:=word&#125;          <span class="hljs-comment"># 如果变量不为空则返回变量，否则赋值成 word 并返回</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;varname:?message&#125;       <span class="hljs-comment"># 如果变量不为空则返回变量，否则打印错误信息并退出</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;varname:+word&#125;          <span class="hljs-comment"># 如果变量不为空则返回 word，否则返回 null</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;varname:offset:len&#125;     <span class="hljs-comment"># 取得字符串的子字符串</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;variable#pattern&#125;       <span class="hljs-comment"># 如果变量头部匹配 pattern，则删除最小匹配部分返回剩下的</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;variable##pattern&#125;      <span class="hljs-comment"># 如果变量头部匹配 pattern，则删除最大匹配部分返回剩下的</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;variable%pattern&#125;       <span class="hljs-comment"># 如果变量尾部匹配 pattern，则删除最小匹配部分返回剩下的</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;variable%%pattern&#125;      <span class="hljs-comment"># 如果变量尾部匹配 pattern，则删除最大匹配部分返回剩下的</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;variable/pattern/str&#125;   <span class="hljs-comment"># 将变量中第一个匹配 pattern 的替换成 str，并返回</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;variable//pattern/str&#125;  <span class="hljs-comment"># 将变量中所有匹配 pattern 的地方替换成 str 并返回</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;#varname&#125;               <span class="hljs-comment"># 返回字符串长度</span></span><br><br>*(patternlist)            # 零次或者多次匹配<br>+(patternlist)            # 一次或者多次匹配<br>?(patternlist)            # 零次或者一次匹配<br>@(patternlist)            # 单词匹配<br>!(patternlist)            # 不匹配<br><br>array=($text)             # 按空格分隔 text 成数组，并赋值给变量<br>IFS=&quot;/&quot; array=($text)     # 按斜杆分隔字符串 text 成数组，并赋值给变量<br>text=&quot;$&#123;array[*]&#125;&quot;        # 用空格链接数组并赋值给变量<br>text=$(IFS=/; echo &quot;$&#123;array[*]&#125;&quot;)  # 用斜杠链接数组并赋值给变量<br><br>A=( foo bar &quot;a  b c&quot; 42 ) # 数组定义<br>B=(&quot;$&#123;A[@]:1:2&#125;&quot;)         # 数组切片：B=( bar &quot;a  b c&quot; )<br>C=(&quot;$&#123;A[@]:1&#125;&quot;)           # 数组切片：C=( bar &quot;a  b c&quot; 42 )<br>echo &quot;$&#123;B[@]&#125;&quot;            # bar a  b c<br>echo &quot;$&#123;B[1]&#125;&quot;            # a  b c<br>echo &quot;$&#123;C[@]&#125;&quot;            # bar a  b c 42<br>echo &quot;$&#123;C[@]: -2:2&#125;&quot;      # a  b c 42  减号前的空格是必须的<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">(UNIX <span class="hljs-built_in">command</span>)           <span class="hljs-comment"># 在 subshell 中运行命令 (不会改变当前 shell 的环境)，并将标准输出内容捕获并返回</span></span><br>varname=$(id -u user)     # 将用户名为 user 的 uid 赋值给 varname 变量<br><br>num=$(expr 1 + 2)         # 兼容 posix sh 的计算，使用 expr 命令计算结果<br>num=$(expr $num + 1)      # 数字自增<br>expr 2 \* \( 2 + 3 \)     # 兼容 posix sh 的复杂计算，输出 10<br><br>num=$[1 + 2]              # 计算 1+2 赋值给 num，使用 bash 独有的 $[..] 计算<br>num=$((1 + 2))            # 同上, 但该语法由 POSIX shell 指定<br>num=$(($num + 1))         # 变量递增<br>num=$((num + 1))          # 变量递增，双括号内的 $ 可以省略<br>num=$((1 + (2 + 3) * 2))  # 复杂计算<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">事件指示符 (仅在交互式 shell 生效)</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>!!                  # 上一条命令<br>!^                  # 上一条命令的第一个单词<br>!:n                 # 上一条命令的第n个单词<br>!:n-$               # 上一条命令的第n个单词到最后一个单词<br>!$                  # 上一条命令的最后一个单词<br>!-n:$               # 上n条命令的最后一个单词<br>!string             # 最近一条包含string的命令<br>!^string1^string2   # 最近一条包含string1的命令, 快速替换string1为string2<br>!#                  # 本条命令之前所有的输入内容<br>!#:n                # 本条命令之前的第n个单词, 快速备份cp /etc/passwd !#:1.bak<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">函数</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">定义一个新函数</span><br>function myfunc() &#123;<br>    # $1 代表第一个参数，$N 代表第 N 个参数<br>    # $# 代表参数个数<br>    # $0 代表被调用者自身的名字<br>    # $@ 代表所有参数，类型是个数组，想传递所有参数给其他命令用 cmd &quot;$@&quot; <br>    # $* 空格链接起来的所有参数，类型是字符串<br>    &#123;shell commands ...&#125;<br>&#125;<br><br>myfunc                    # 调用函数 myfunc <br>myfunc arg1 arg2 arg3     # 带参数的函数调用<br>myfunc &quot;$@&quot;               # 将所有参数传递给函数<br>myfunc &quot;$&#123;array[@]&#125;&quot;      # 将一个数组当作多个参数传递给函数<br>shift                     # 参数左移<br><br>unset -f myfunc           # 删除函数<br>declare -f                # 列出函数定义<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">条件判断（兼容 posix sh 的条件判断）：man <span class="hljs-built_in">test</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>statement1 &amp;&amp; statement2  # and 操作符<br>statement1 || statement2  # or 操作符<br><br>exp1 -a exp2              # exp1 和 exp2 同时为真时返回真（POSIX XSI扩展）<br>exp1 -o exp2              # exp1 和 exp2 有一个为真就返回真（POSIX XSI扩展）<br>( expression )            # 如果 expression 为真时返回真，输入注意括号前反斜杆<br>! expression              # 如果 expression 为假那返回真<br><br>str1 = str2               # 判断字符串相等，如 [ &quot;$x&quot; = &quot;$y&quot; ] &amp;&amp; echo yes<br>str1 != str2              # 判断字符串不等，如 [ &quot;$x&quot; != &quot;$y&quot; ] &amp;&amp; echo yes<br>str1 &lt; str2               # 字符串小于，如 [ &quot;$x&quot; \&lt; &quot;$y&quot; ] &amp;&amp; echo yes<br>str2 &gt; str2               # 字符串大于，注意 &lt; 或 &gt; 是字面量，输入时要加反斜杆<br>-n str1                   # 判断字符串不为空（长度大于零）<br>-z str1                   # 判断字符串为空（长度等于零）<br><br>-a file                   # 判断文件存在，如 [ -a /tmp/abc ] &amp;&amp; echo &quot;exists&quot;<br>-d file                   # 判断文件存在，且该文件是一个目录<br>-e file                   # 判断文件存在，和 -a 等价<br>-f file                   # 判断文件存在，且该文件是一个普通文件（非目录等）<br>-r file                   # 判断文件存在，且可读<br>-s file                   # 判断文件存在，且尺寸大于0<br>-w file                   # 判断文件存在，且可写<br>-x file                   # 判断文件存在，且执行<br>-N file                   # 文件上次修改过后还没有读取过<br>-O file                   # 文件存在且属于当前用户<br>-G file                   # 文件存在且匹配你的用户组<br>file1 -nt file2           # 文件1 比 文件2 新<br>file1 -ot file2           # 文件1 比 文件2 旧<br><br>num1 -eq num2             # 数字判断：num1 == num2<br>num1 -ne num2             # 数字判断：num1 != num2<br>num1 -lt num2             # 数字判断：num1 &lt; num2<br>num1 -le num2             # 数字判断：num1 &lt;= num2<br>num1 -gt num2             # 数字判断：num1 &gt; num2<br>num1 -ge num2             # 数字判断：num1 &gt;= num2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">分支控制：<span class="hljs-keyword">if</span> 和经典 <span class="hljs-built_in">test</span>，兼容 posix sh 的条件判断语句</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>test &#123;expression&#125;         # 判断条件为真的话 test 程序返回0 否则非零<br>[ expression ]            # 判断条件为真的话返回0 否则非零<br><br>test &quot;abc&quot; = &quot;def&quot;        # 查看返回值 echo $? 显示 1，因为条件为假<br>test &quot;abc&quot; != &quot;def&quot;       # 查看返回值 echo $? 显示 0，因为条件为真<br><br>test -a /tmp; echo $?     # 调用 test 判断 /tmp 是否存在，并打印 test 的返回值<br>[ -a /tmp ]; echo $?      # 和上面完全等价，/tmp 肯定是存在的，所以输出是 0<br><br>test cond &amp;&amp; cmd1         # 判断条件为真时执行 cmd1<br>[ cond ] &amp;&amp; cmd1          # 和上面完全等价<br>[ cond ] &amp;&amp; cmd1 || cmd2  # 条件为真执行 cmd1 否则执行 cmd2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">判断 /etc/passwd 文件是否存在</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">经典的 <span class="hljs-keyword">if</span> 语句就是判断后面的命令返回值为0的话，认为条件为真，否则为假</span><br>if test -e /etc/passwd; then<br>    echo &quot;alright it exists ... &quot;<br>else<br>    echo &quot;it doesn&#x27;t exist ... &quot;<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">和上面完全等价，[ 是个和 <span class="hljs-built_in">test</span> 一样的可执行程序，但最后一个参数必须为 ]</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这个名字为 <span class="hljs-string">&quot;[&quot;</span> 的可执行程序一般就在 /bin 或 /usr/bin 下面，比 <span class="hljs-built_in">test</span> 优雅些</span><br>if [ -e /etc/passwd ]; then   <br>    echo &quot;alright it exists ... &quot;<br>else<br>    echo &quot;it doesn&#x27;t exist ... &quot;<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">和上面两个完全等价，其实到 bash 时代 [ 已经是内部命令了，用 <span class="hljs-built_in">enable</span> 可以看到</span><br>[ -e /etc/passwd ] &amp;&amp; echo &quot;alright it exists&quot; || echo &quot;it doesn&#x27;t exist&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">判断变量的值</span><br>if [ &quot;$varname&quot; = &quot;foo&quot; ]; then<br>    echo &quot;this is foo&quot;<br>elif [ &quot;$varname&quot; = &quot;bar&quot; ]; then<br>    echo &quot;this is bar&quot;<br>else<br>    echo &quot;neither&quot;<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">复杂条件判断，注意 || 和 &amp;&amp; 是完全兼容 POSIX 的推荐写法</span><br>if [ $x -gt 10 ] &amp;&amp; [ $x -lt 20 ]; then<br>    echo &quot;yes, between 10 and 20&quot;<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以用 &amp;&amp; 命令连接符来做和上面完全等价的事情</span><br>[ $x -gt 10 ] &amp;&amp; [ $x -lt 20 ] &amp;&amp; echo &quot;yes, between 10 and 20&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">小括号和 -a -o 是 POSIX XSI 扩展写法，小括号是字面量，输入时前面要加反斜杆</span><br>if [ \( $x -gt 10 \) -a \( $x -lt 20 \) ]; then<br>    echo &quot;yes, between 10 and 20&quot;<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">同样可以用 &amp;&amp; 命令连接符来做和上面完全等价的事情</span><br>[ \( $x -gt 10 \) -a \( $x -lt 20 \) ] &amp;&amp; echo &quot;yes, between 10 and 20&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">判断程序存在的话就执行</span><br>[ -x /bin/ls ] &amp;&amp; /bin/ls -l<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果不考虑兼容 posix sh 和 dash 这些的话，可用 bash 独有的 ((..)) 和 [[..]]:</span><br>https://www.ibm.com/developerworks/library/l-bash-test/index.html<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">流程控制：<span class="hljs-keyword">while</span> / <span class="hljs-keyword">for</span> / <span class="hljs-keyword">case</span> / <span class="hljs-keyword">until</span></span> <br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">while</span> 循环</span><br>while condition; do<br>    statements<br>done<br><br>i=1<br>while [ $i -le 10 ]; do<br>    echo $i; <br>    i=$(expr $i + 1)<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">for</span> 循环：上面的 <span class="hljs-keyword">while</span> 语句等价</span><br>for i in &#123;1..10&#125;; do<br>    echo $i<br>done<br><br>for name [in list]; do<br>    statements<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">for</span> 列举某目录下面的所有文件</span><br>for f in /home/*; do <br>    echo $f<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">bash 独有的 (( .. )) 语句，更接近 C 语言，但是不兼容 posix sh</span><br>for (( initialisation ; ending condition ; update )); do<br>    statements<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">和上面的写法等价</span><br>for ((i = 0; i &lt; 10; i++)); do echo $i; done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">case</span> 判断</span><br>case expression in <br>    pattern1a | pattern1b | ... )<br>        statements ;;<br>    pattern2 )<br>        statements ;;<br>    * )<br>        otherwise ;;<br>esac<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">until</span> 语句</span><br>until condition; do<br>    statements<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">select</span> 语句</span><br>select name [in list]; do<br>  statements that can use $name<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">命令处理</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>command ls                         # 忽略 alias 直接执行程序或者内建命令 ls<br>builtin cd                         # 忽略 alias 直接运行内建的 cd 命令<br>enable                             # 列出所有 bash 内置命令，或禁止某命令<br>help &#123;builtin_command&#125;             # 查看内置命令的帮助（仅限 bash 内置命令）<br><br>eval $script                       # 对 script 变量中的字符串求值（执行）<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出/输入 重定向</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>cmd1 | cmd2                        # 管道，cmd1 的标准输出接到 cmd2 的标准输入<br>&lt; file                             # 将文件内容重定向为命令的标准输入<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">file                             <span class="hljs-comment"># 将命令的标准输出重定向到文件，会覆盖文件</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt; file                            <span class="hljs-comment"># 将命令的标准输出重定向到文件，追加不覆盖</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">| file                            <span class="hljs-comment"># 强制输出到文件，即便设置过：set -o noclobber</span></span><br><span class="hljs-meta prompt_">n&gt;</span><span class="language-bash">| file                           <span class="hljs-comment"># 强制将文件描述符 n的输出重定向到文件</span></span><br>&lt;&gt; file                            # 同时使用该文件作为标准输入和标准输出<br>n&lt;&gt; file                           # 同时使用文件作为文件描述符 n 的输出和输入<br><span class="hljs-meta prompt_">n&gt; </span><span class="language-bash">file                            <span class="hljs-comment"># 重定向文件描述符 n 的输出到文件</span></span><br>n&lt; file                            # 重定向文件描述符 n 的输入为文件内容<br><span class="hljs-meta prompt_">n&gt;</span><span class="language-bash">&amp;                                <span class="hljs-comment"># 将标准输出 dup/合并 到文件描述符 n</span></span><br>n&lt;&amp;                                # 将标准输入 dump/合并 定向为描述符 n<br><span class="hljs-meta prompt_">n&gt;</span><span class="language-bash">&amp;m                               <span class="hljs-comment"># 文件描述符 n 被作为描述符 m 的副本，输出用</span></span><br>n&lt;&amp;m                               # 文件描述符 n 被作为描述符 m 的副本，输入用<br>&amp;&gt;file                             # 将标准输出和标准错误重定向到文件<br>&lt;&amp;-                                # 关闭标准输入<br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&amp;-                                <span class="hljs-comment"># 关闭标准输出</span></span><br><span class="hljs-meta prompt_">n&gt;</span><span class="language-bash">&amp;-                               <span class="hljs-comment"># 关闭作为输出的文件描述符 n</span></span><br>n&lt;&amp;-                               # 关闭作为输入的文件描述符 n<br>diff &lt;(cmd1) &lt;(cmd2)               # 比较两个命令的输出<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">文本处理 - <span class="hljs-built_in">cut</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>cut -c 1-16                        # 截取每行头16个字符<br>cut -c 1-16 file                   # 截取指定文件中每行头 16个字符<br>cut -c3-                           # 截取每行从第三个字符开始到行末的内容<br>cut -d&#x27;:&#x27; -f5                      # 截取用冒号分隔的第五列内容<br>cut -d&#x27;;&#x27; -f2,10                   # 截取用分号分隔的第二和第十列内容<br>cut -d&#x27; &#x27; -f3-7                    # 截取空格分隔的三到七列<br>echo &quot;hello&quot; | cut -c1-3           # 显示 hel<br>echo &quot;hello sir&quot; | cut -d&#x27; &#x27; -f2   # 显示 sir<br>ps | tr -s &quot; &quot; | cut -d &quot; &quot; -f 2,3,4  # cut 搭配 tr 压缩字符<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">文本处理 - awk / sed</span> <br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>awk &#x27;&#123;print $5&#125;&#x27; file              # 打印文件中以空格分隔的第五列<br>awk -F &#x27;,&#x27; &#x27;&#123;print $5&#125;&#x27; file       # 打印文件中以逗号分隔的第五列<br>awk &#x27;/str/ &#123;print $2&#125;&#x27; file        # 打印文件中包含 str 的所有行的第二列<br>awk -F &#x27;,&#x27; &#x27;&#123;print $NF&#125;&#x27; file      # 打印逗号分隔的文件中的每行最后一列 <br>awk &#x27;&#123;s+=$1&#125; END &#123;print s&#125;&#x27; file   # 计算所有第一列的合<br>awk &#x27;NR%3==1&#x27; file                 # 从第一行开始，每隔三行打印一行<br><br>sed &#x27;s/find/replace/&#x27; file         # 替换文件中首次出现的字符串并输出结果 <br>sed &#x27;10s/find/replace/&#x27; file       # 替换文件第 10 行内容<br>sed &#x27;10,20s/find/replace/&#x27; file    # 替换文件中 10-20 行内容<br>sed -r &#x27;s/regex/replace/g&#x27; file    # 替换文件中所有出现的字符串<br>sed -i &#x27;s/find/replace/g&#x27; file     # 替换文件中所有出现的字符并且覆盖文件<br>sed -i &#x27;/find/i\newline&#x27; file      # 在文件的匹配文本前插入行<br>sed -i &#x27;/find/a\newline&#x27; file      # 在文件的匹配文本后插入行<br>sed &#x27;/line/s/find/replace/&#x27; file   # 先搜索行特征再执行替换<br>sed -e &#x27;s/f/r/&#x27; -e &#x27;s/f/r&#x27; file    # 执行多次替换<br>sed &#x27;s#find#replace#&#x27; file         # 使用 # 替换 / 来避免 pattern 中有斜杆<br>sed -i -r &#x27;s/^\s+//g&#x27; file         # 删除文件每行头部空格<br>sed &#x27;/^$/d&#x27; file                   # 删除文件空行并打印<br>sed -i &#x27;s/\s\+$//&#x27; file            # 删除文件每行末尾多余空格<br>sed -n &#x27;2p&#x27; file                   # 打印文件第二行<br>sed -n &#x27;2,5p&#x27; file                 # 打印文件第二到第五行<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">排序 - <span class="hljs-built_in">sort</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>sort file                          # 排序文件<br>sort -r file                       # 反向排序（降序）<br>sort -n file                       # 使用数字而不是字符串进行比较<br>sort -t: -k 3n /etc/passwd         # 按 passwd 文件的第三列进行排序<br>sort -u file                       # 去重排序<br>sort -h file                       # 支持 K/M/G 等量级符号，可与 du 结合使用<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">快速跳转 - https://github.com/rupa/z</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>source /path/to/z.sh               # .bashrc 中初始化 z.sh<br>z                                  # 列出所有历史路径以及他们的权重<br>z foo                              # 跳到历史路径中匹配 foo 的权重最大的目录<br>z foo bar                          # 跳到历史路径中匹配 foo 和 bar 权重最大的目录<br>z -l foo                           # 列出所有历史路径中匹配 foo 的目录及权重<br>z -r foo                           # 按照最高访问次数优先进行匹配跳转<br>z -t foo                           # 按照最近访问优先进行匹配跳转<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">键盘绑定</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>bind &#x27;&quot;\eh&quot;:&quot;\C-b&quot;&#x27;                # 绑定 ALT+h 为光标左移，同 CTRL+b / &lt;Left&gt;<br>bind &#x27;&quot;\el&quot;:&quot;\C-f&quot;&#x27;                # 绑定 ALT+l 为光标右移，同 CTRL+f / &lt;Right&gt;<br>bind &#x27;&quot;\ej&quot;:&quot;\C-n&quot;&#x27;                # 绑定 ALT+j 为下条历史，同 CTRL+n / &lt;Down&gt;<br>bind &#x27;&quot;\ek&quot;:&quot;\C-p&quot;&#x27;                # 绑定 ALT+k 为上条历史，同 CTRL+p / &lt;Up&gt;<br>bind &#x27;&quot;\eH&quot;:&quot;\eb&quot;&#x27;                 # 绑定 ALT+H 为光标左移一个单词，同 ALT-b <br>bind &#x27;&quot;\eL&quot;:&quot;\ef&quot;&#x27;                 # 绑定 ALT+L 为光标右移一个单词，同 ALT-f <br>bind &#x27;&quot;\eJ&quot;:&quot;\C-a&quot;&#x27;                # 绑定 ALT+J 为移动到行首，同 CTRL+a / &lt;Home&gt;<br>bind &#x27;&quot;\eK&quot;:&quot;\C-e&quot;&#x27;                # 绑定 ALT+K 为移动到行末，同 CTRL+e / &lt;End&gt;<br>bind &#x27;&quot;\e;&quot;:&quot;ls -l\n&quot;&#x27;             # 绑定 ALT+; 为执行 ls -l 命令<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">网络管理：ip / ifconfig / nmap ...</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>ip a                               # 显示所有网络地址，同 ip address<br>ip a show eth1                     # 显示网卡 IP 地址<br>ip a add 172.16.1.23/24 dev eth1   # 添加网卡 IP 地址<br>ip a del 172.16.1.23/24 dev eth1   # 删除网卡 IP 地址<br>ip link show dev eth0              # 显示网卡设备属性<br>ip link set eth1 up                # 激活网卡<br>ip link set eth1 down              # 关闭网卡<br>ip link set eth1 address &#123;mac&#125;     # 修改 MAC 地址<br>ip neighbour                       # 查看 ARP 缓存<br>ip route                           # 查看路由表<br>ip route add 10.1.0.0/24 via 10.0.0.253 dev eth0    # 添加静态路由<br>ip route del 10.1.0.0/24           # 删除静态路由<br><br>ifconfig                           # 显示所有网卡和接口信息<br>ifconfig -a                        # 显示所有网卡（包括开机没启动的）信息<br>ifconfig eth0                      # 指定设备显示信息<br>ifconfig eth0 up                   # 激活网卡<br>ifconfig eth0 down                 # 关闭网卡<br>ifconfig eth0 192.168.120.56       # 给网卡配置 IP 地址<br>ifconfig eth0 10.0.0.8 netmask 255.255.255.0 up     # 配置 IP 并启动<br>ifconfig eth0 hw ether 00:aa:bb:cc:dd:ee            # 修改 MAC 地址<br><br>nmap 10.0.0.12                     # 扫描主机 1-1000 端口<br>nmap -p 1024-65535 10.0.0.12       # 扫描给定端口<br>nmap 10.0.0.0/24                   # 给定网段扫描局域网内所有主机<br>nmap -O -sV 10.0.0.12              # 探测主机服务和操作系统版本<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">有趣的命令</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>man hier                           # 查看文件系统的结构和含义<br>man test                           # 查看 posix sh 的条件判断帮助<br>man ascii                          # 显示 ascii 表<br>getconf LONG_BIT                   # 查看系统是 32 位还是 64 位<br>bind -P                            # 列出所有 bash 的快捷键<br>mount | column -t                  # 漂亮的列出当前加载的文件系统<br>curl ip.cn                         # 取得外网 ip 地址和服务商信息<br>disown -a &amp;&amp; exit                  # 关闭所有后台任务并退出<br>cat /etc/issue                     # 查看 Linux 发行版信息<br>lsof -i port:80                    # 哪个程序在使用 80 端口？<br>showkey -a                         # 取得按键的 ASCII 码<br>svn diff | view -                  # 使用 Vim 来显示带色彩的 diff 输出<br>mv filename.&#123;old,new&#125;              # 快速文件改名<br>time read                          # 使用 CTRL-D 停止，最简单的计时功能<br>cp file.txt&#123;,.bak&#125;                 # 快速备份文件<br>sudo touch /forcefsck              # 强制在下次重启时扫描磁盘<br>find ~ -mmin 60 -type f            # 查找 $HOME 目录中，60 分钟内修改过的文件<br>curl wttr.in/~beijing              # 查看北京的天气预报<br>echo $&#123;SSH_CLIENT%% *&#125;             # 取得你是从什么 IP 链接到当前主机上的<br>echo $[RANDOM%X+1]                 # 取得 1 到 X 之间的随机数<br>bind -x &#x27;&quot;\C-l&quot;:ls -l&#x27;             # 设置 CTRL+l 为执行 ls -l 命令<br>find / -type f -size +5M           # 查找大于 5M 的文件<br>chmod --reference f1 f2            # 将 f2 的权限设置成 f1 一模一样的<br>curl -L cheat.sh                   # 速查表大全<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">常用技巧</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出最常使用的命令</span><br>history | awk &#x27;&#123;a[$2]++&#125;END&#123;for(i in a)&#123;print a[i] &quot; &quot; i&#125;&#125;&#x27; | sort -rn | head<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有网络状态：ESTABLISHED / TIME_WAIT / FIN_WAIT1 / FIN_WAIT2</span> <br>netstat -n | awk &#x27;/^tcp/ &#123;++tt[$NF]&#125; END &#123;for (a in tt) print a, tt[a]&#125;&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过 SSH 来 mount 文件系统</span><br>sshfs name@server:/path/to/folder /path/to/mount/point<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示前十个运行的进程并按内存使用量排序</span><br>ps aux | sort -nk +4 | tail<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在右上角显示时钟</span><br>while sleep 1;do tput sc;tput cup 0 $(($(tput cols)-29));date;tput rc;done&amp;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从网络上的压缩文件中解出一个文件来，并避免保存中间文件</span><br>wget -qO - &quot;http://www.tarball.com/tarball.gz&quot; | tar zxvf -<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">性能测试：测试处理器性能</span><br>python -c &quot;import test.pystone;print(test.pystone.pystones())&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">性能测试：测试内存带宽</span><br>dd if=/dev/zero of=/dev/null bs=1M count=32768<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Linux 下挂载一个 iso 文件</span><br>mount /path/to/file.iso /mnt/cdrom -oloop<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过主机 A 直接 ssh 到主机 B</span><br>ssh -t hostA ssh hostB<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载一个网站的所有图片</span><br>wget -r -l1 --no-parent -nH -nd -P/tmp -A&quot;.gif,.jpg&quot; http://example.com/images<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">快速创建项目目录</span><br>mkdir -p work/&#123;project1,project2&#125;/&#123;src,bin,bak&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">按日期范围查找文件</span><br>find . -type f -newermt &quot;2010-01-01&quot; ! -newermt &quot;2010-06-01&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示当前正在使用网络的进程</span><br>lsof -P -i -n | cut -f 1 -d &quot; &quot;| uniq | tail -n +2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Vim 中保存一个没有权限的文件</span><br>:w !sudo tee &gt; /dev/null %<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在 .bashrc / .bash_profile 中加载另外一个文件（比如你保存在 github 上的配置）</span><br>source ~/github/profiles/my_bash_init.sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">反向代理：将外网主机（202.115.8.1）端口（8443）转发到内网主机 192.168.1.2:443</span><br>ssh -CqTnN -R 0.0.0.0:8443:192.168.1.2:443  user@202.115.8.1<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">正向代理：将本地主机的 8443 端口，通过 192.168.1.3 转发到 192.168.1.2:443</span> <br>ssh -CqTnN -L 0.0.0.0:8443:192.168.1.2:443  user@192.168.1.3<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">socks5 代理：把本地 1080 端口的 socks5 的代理请求通过远程主机转发出去</span><br>ssh -CqTnN -D localhost:1080  user@202.115.8.1<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">终端下正确设置 ALT 键和 BackSpace 键</span><br>http://www.skywind.me/blog/archives/2021<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">有用的函数</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">自动解压：判断文件后缀名并调用相应解压命令</span><br>function q-extract() &#123;<br>    if [ -f $1 ] ; then<br>        case $1 in<br>        *.tar.bz2)   tar -xvjf $1    ;;<br>        *.tar.gz)    tar -xvzf $1    ;;<br>        *.tar.xz)    tar -xvJf $1    ;;<br>        *.bz2)       bunzip2 $1     ;;<br>        *.rar)       rar x $1       ;;<br>        *.gz)        gunzip $1      ;;<br>        *.tar)       tar -xvf $1     ;;<br>        *.tbz2)      tar -xvjf $1    ;;<br>        *.tgz)       tar -xvzf $1    ;;<br>        *.zip)       unzip $1       ;;<br>        *.Z)         uncompress $1  ;;<br>        *.7z)        7z x $1        ;;<br>        *)           echo &quot;don&#x27;t know how to extract &#x27;$1&#x27;...&quot; ;;<br>        esac<br>    else<br>        echo &quot;&#x27;$1&#x27; is not a valid file!&quot;<br>    fi<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">自动压缩：判断后缀名并调用相应压缩程序</span><br>function q-compress() &#123;<br>    if [ -n &quot;$1&quot; ] ; then<br>        FILE=$1<br>        case $FILE in<br>        *.tar) shift &amp;&amp; tar -cf $FILE $* ;;<br>        *.tar.bz2) shift &amp;&amp; tar -cjf $FILE $* ;;<br>        *.tar.xz) shift &amp;&amp; tar -cJf $FILE $* ;;<br>        *.tar.gz) shift &amp;&amp; tar -czf $FILE $* ;;<br>        *.tgz) shift &amp;&amp; tar -czf $FILE $* ;;<br>        *.zip) shift &amp;&amp; zip $FILE $* ;;<br>        *.rar) shift &amp;&amp; rar $FILE $* ;;<br>        esac<br>    else<br>        echo &quot;usage: q-compress &lt;foo.tar.gz&gt; ./foo ./bar&quot;<br>    fi<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">漂亮的带语法高亮的 color <span class="hljs-built_in">cat</span> ，需要先 pip install pygments</span><br>function ccat() &#123;<br>    local style=&quot;monokai&quot;<br>    if [ $# -eq 0 ]; then<br>        pygmentize -P style=$style -P tabsize=4 -f terminal256 -g<br>    else<br>        for NAME in $@; do<br>            pygmentize -P style=$style -P tabsize=4 -f terminal256 -g &quot;$NAME&quot;<br>        done<br>    fi<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">好玩的配置</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">放到你的 ~/.bashrc 配置文件中，给 man 增加漂亮的色彩高亮</span><br>export LESS_TERMCAP_mb=$&#x27;\E[1m\E[32m&#x27;<br>export LESS_TERMCAP_mh=$&#x27;\E[2m&#x27;<br>export LESS_TERMCAP_mr=$&#x27;\E[7m&#x27;<br>export LESS_TERMCAP_md=$&#x27;\E[1m\E[36m&#x27;<br>export LESS_TERMCAP_ZW=&quot;&quot;<br>export LESS_TERMCAP_us=$&#x27;\E[4m\E[1m\E[37m&#x27;<br>export LESS_TERMCAP_me=$&#x27;\E(B\E[m&#x27;<br>export LESS_TERMCAP_ue=$&#x27;\E[24m\E(B\E[m&#x27;<br>export LESS_TERMCAP_ZO=&quot;&quot;<br>export LESS_TERMCAP_ZN=&quot;&quot;<br>export LESS_TERMCAP_se=$&#x27;\E[27m\E(B\E[m&#x27;<br>export LESS_TERMCAP_ZV=&quot;&quot;<br>export LESS_TERMCAP_so=$&#x27;\E[1m\E[33m\E[44m&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ALT+hjkl/HJKL 快速移动光标，将下面内容添加到 ~/.inputrc 中可作用所有工具，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">包括 bash/zsh/python/lua 等使用 readline 的工具，帮助见：info rluserman</span><br>&quot;\eh&quot;: backward-char<br>&quot;\el&quot;: forward-char<br>&quot;\ej&quot;: next-history<br>&quot;\ek&quot;: previous-history<br>&quot;\eH&quot;: backward-word<br>&quot;\eL&quot;: forward-word<br>&quot;\eJ&quot;: beginning-of-line<br>&quot;\eK&quot;: end-of-line<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">References</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>https://github.com/Idnan/bash-guide<br>http://www.linuxstall.com/linux-command-line-tips-that-every-linux-user-should-know/<br>https://ss64.com/bash/syntax-keyboard.html<br>http://wiki.bash-hackers.org/commands/classictest<br>https://www.ibm.com/developerworks/library/l-bash-test/index.html<br>https://www.cyberciti.biz/faq/bash-loop-over-file/<br>https://linuxconfig.org/bash-scripting-tutorial<br>https://github.com/LeCoupa/awesome-cheatsheets/blob/master/languages/bash.sh<br>https://devhints.io/bash<br>https://github.com/jlevy/the-art-of-command-line<br>https://yq.aliyun.com/articles/68541<br>https://tiswww.case.edu/php/chet/bash/article.pdf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">vim: <span class="hljs-built_in">set</span> ts=4 sw=4 tw=0 et :</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>速查表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
      <tag>Bash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux笔记-shell脚本语法</title>
    <link href="/posts/827c.html"/>
    <url>/posts/827c.html</url>
    
    <content type="html"><![CDATA[<h1 id="shell脚本语法"><a href="#shell脚本语法" class="headerlink" title="shell脚本语法"></a>shell脚本语法</h1><h2 id="脚本开头要写的内容"><a href="#脚本开头要写的内容" class="headerlink" title="脚本开头要写的内容"></a>脚本开头要写的内容</h2><ul><li>#!&#x2F;bin&#x2F;bash 或 #!&#x2F;bin&#x2F;bash</li><li>脚本的功能、作者、版本信息等</li><li>预先设置环境变量</li></ul><h2 id="变量相关规则"><a href="#变量相关规则" class="headerlink" title="变量相关规则"></a>变量相关规则</h2><ul><li>设置变量时用等号连接，如：myname&#x3D;vbird</li><li>引用变量的方式：${变量名} 或 $变量名（可能引起歧义的情况下尽量使用花括号）</li><li>输出变量内容：echo  ${变量名}</li><li>变量名不能以数字开头</li><li>等号两边不能直接出现空格，如：myname&#x3D;vbird as是错的</li><li>变量内容若有空格可用单引号或双引号，双引号中的特殊字符保留原本功能，单引号中的特殊字符仅为一般字符，如var&#x3D;”lang is $LANG”，$LANG替换为变量内容</li><li>可用反斜杠\将特殊字符( [Enter]、$、\、空格、’ )转义为一般字符，如：myname&#x3D;vbird\ tsai</li><li>若要扩增变量内容，可以如：PATH&#x3D;”$PATH”:&#x2F;home&#x2F;bin 或 PATH&#x3D;${PATH}:&#x2F;home&#x2F;bin</li><li>若要获得额外的命令所提供的信息进行替换时，可用 $(命令) ，如：version&#x3D;$(uname -r)</li><li>可使用unset取消变量，如：unset  myname</li><li>变量的数值计算，用$((运算式))，如 total&#x3D;$(( ${firstnu}*${secnu} ))，但bash中数值计算最多只能到整数</li><li>变量的默认类型为字符串，若要定义整数：declare -i num&#x3D;12，定义数组：declare -a array&#x3D;(a b c d)</li></ul><h2 id="脚本执行的两种方式"><a href="#脚本执行的两种方式" class="headerlink" title="脚本执行的两种方式"></a>脚本执行的两种方式</h2><ol><li>直接执行：包括：1、使用绝对路径&#x2F;相对路径；2、将所在目录放在PATH环境变量中；（1、2两种需要为脚本文件加上rx权限）3、用bash&#x2F;sh命令执行脚本。特点是在子进程的bash中执行，子进程结束后，变量或操作不会传回父进程。</li><li>利用source：用法是source  脚本名，特点是在父进程中执行，各项操作会在原bash中生效</li></ol><h2 id="test命令的测试功能"><a href="#test命令的测试功能" class="headerlink" title="test命令的测试功能"></a>test命令的测试功能</h2><p>语法：test  选项  文件名&#x2F;变量&#x2F;字符串……</p><p>test命令没有输出，当测试成功，命令返回值 $? 变量为0，失败则为非0。因此可以结合&amp;&amp;、|| 使用。</p><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><ul><li>-e：文件名是否存在</li><li>-f：文件名是否存在且为文件</li><li>-d：文件名是否存在且为目录</li><li>n1 -eq n2：两数值相等（不等使用-ne）</li><li>n1 -gt n2：n1大于n2（小于使用-lt）</li><li>-z  string：字符串是否为空</li><li>str1 &#x3D; str2     （若使用判断符号，必须写为[ str1 &#x3D; str2 ] 或者 [[ str1 &#x3D;&#x3D; str2 ]]）（关于 [] 与 [[]] 的区别可参考<a href="https://tao.zz.ac/unix/test-bracket.html">博客</a>）</li><li>str1 !&#x3D; str2</li><li>-a 且   -o 或     ！非</li></ul><p>更多选项及用法如文件类型、权限检测、文件比较、整数比较、字符串判定、多重条件判定等，见私房菜P396</p><p>常结合命令执行的判断依据&amp;&amp;、|| 使用，如：test  -e  filename  &amp;&amp;  echo  “Exist”  ||  echo  “Not exist”</p><h2 id="判断符号"><a href="#判断符号" class="headerlink" title="判断符号[ ]"></a>判断符号[ ]</h2><p>用法与test相同，如 [ -e  filename ] 等价于 test  -e  filename，也可与&amp;&amp;、|| 结合使用</p><p>注意中括号内的每一个组件之间都要有空格分隔，每一个变量或常量都要有双引号</p><h2 id="默认变量"><a href="#默认变量" class="headerlink" title="默认变量"></a>默认变量</h2><ul><li>$0：脚本文件名</li><li>$1、$2等：依次为各个参数</li><li>$#：输入的参数个数</li><li>$@：所有参数，代表【”$1”  “$2”  “$3”  …】，以空格隔开</li></ul><h2 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ 条件判断式1 ]; then<br>程序段<br>elif [ 条件判断式2 ]; then<br>程序段<br>else<br>程序段<br>fi<br></code></pre></td></tr></table></figure><p>多个条件判断式可以用&amp;&amp;或 || 连接，如 [ 条件判断式1 ] &amp;&amp; [ 条件判断式2 ]</p><h3 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">case $&#123;变量名&#125; in<br>   &quot;第1个变量内容&quot;）<br>程序段<br>;;<br>   &quot;第2个变量内容&quot;）<br>程序段<br>;;<br>   *)<br>程序段<br>;;<br>esac<br></code></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">function 函数名() &#123;<br>函数体<br>&#125;<br></code></pre></td></tr></table></figure><p>函数体中可用$1、$2等代表参数1、参数2等</p><p>调用方式：函数名  参数1  参数2  ……   如：<code>printit 1</code></p><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">while [ 条件判断式 ]<br>do<br>程序段<br>done<br></code></pre></td></tr></table></figure><h4 id="until语句"><a href="#until语句" class="headerlink" title="until语句"></a>until语句</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">until [ 条件判断式 ]<br>do<br>程序段<br>done<br></code></pre></td></tr></table></figure><h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">for var in con1 con2 ...<br>do<br>程序段<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">例子：</span><br>users=$(cut -d &#x27;:&#x27; -f1 /etc/passwd)<br>for username in $&#123;users&#125;<br>do<br>id $&#123;username&#125;<br>done<br></code></pre></td></tr></table></figure><p>in后面的内容可以用 $(seq  n1  n2) 或 {n1…n2} ，代表n1到n2的连续输字</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for (( 初始值; 限制值; 赋值运算 ))<br>do<br>程序段<br>done<br></code></pre></td></tr></table></figure><p>与C语言用法相同</p><h2 id="脚本跟踪与调试"><a href="#脚本跟踪与调试" class="headerlink" title="脚本跟踪与调试"></a>脚本跟踪与调试</h2><p>sh  调试shell脚本</p><p>语法：sh [-nx] 脚本名</p><p>选项</p><ul><li>-n：不执行脚本，仅查询语法问题</li><li>-x：将执行过程显示出来，非常有用，可用于调试</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux笔记-正则表达式</title>
    <link href="/posts/789.html"/>
    <url>/posts/789.html</url>
    
    <content type="html"><![CDATA[<h1 id="正则表达式RegularExpression"><a href="#正则表达式RegularExpression" class="headerlink" title="正则表达式RegularExpression"></a>正则表达式RegularExpression</h1><p>一种字符串处理的表示方式。正则表达式可用在多种场合，常见的用法是用grep&#x2F;sed&#x2F;awk命令对文件内容进行匹配筛选，如 <code>grep -n &quot;g..d&quot; tmp.txt</code> 命令匹配文件中含有g??d形式的行，并输出行号。还可用于vim编辑器中。</p><h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><ul><li>[:alnum:]：英文大小写字符及数字（注意匹配时要写双层方括号，如 [[:alnum:]] 、[^[:digit:]]）</li><li>[:alpha:]：英文大小写字符</li><li>[:lower:]：英文小写字符，即a~z</li><li>[:upper:]：英文大写字符，即A~Z</li><li>[:digit:]：数字，即0~9</li><li>[:blank:]：空格键与Tab键</li><li>[:graph:]：除了空格符（空格键与[Tab]按键）外的其他所有按键</li><li>[:cntrl:]：控制按键，包括CR、LF、Tab、Del等</li><li>[:print:]：代表任何可以被打印出来的字符</li><li>[:punct:]：代表标点符号（punctuation symbol），亦即:”‘?!;:#$</li><li>[:space:]：任何会产生空白的字符，包括空格键、[Tab]、 CR等</li><li>[:xdigit:]：代表十六进制的数字类型，因此包括0 ~ 9、A ~ F、a ~ f 的数字与字符</li></ul><h2 id="基础RE字符"><a href="#基础RE字符" class="headerlink" title="基础RE字符"></a>基础RE字符</h2><ul><li>^word：^匹配行首</li><li>word$：$匹配行尾</li><li>.：小数点，匹配一个任意字符</li><li>*：星号，与一个RE字符搭配使用，表示前一个RE字符重复0到无穷多次（注意正则表达式与通配符不同，通配符中星号代表0到无穷多个字符，？代表任意一个字符）</li><li>\：将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\\‘ 匹配 “\“，而 ‘\(‘ 则匹配 “(“。</li><li>[list]：字符集合，匹配一个方括号中的字符，注意仅匹配一个</li><li>[n1-n2]：字符范围，匹配两个字符之间的连续字符中的一个</li><li>[^list]：反向选择，匹配不在list中的字符</li><li>{n,m}：代表前一个RE字符重复n到m次，{n}表示重复n次，{n,}表示重复至少n次</li></ul><blockquote><p>注意 { 与 } 符号在shell中有特殊含义（用于变量），所以如果在shell中grep使用正则，要加上转义符\ 。例如输入 <code>grep -n &quot;o\&#123;2\&#125;&quot; tmp.txt</code>  将在文件中匹配含有两个o的字符串。在其他地方用正则不用这样。</p></blockquote><h2 id="拓展RE字符"><a href="#拓展RE字符" class="headerlink" title="拓展RE字符"></a>拓展RE字符</h2><ul><li>拓展正则表达式要使用egrep（grep -E的别名）或sed  -r，见私房菜P376</li><li>+：加号，与一个RE字符搭配使用，表示前一个RE字符重复1到无穷多次</li><li>?：问号，与一个RE字符搭配使用，表示前一个RE字符重复0或1次</li><li>|：或，如 gd|god</li><li>( )：标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用</li><li>( )+：多个重复群组的判别</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ul><li>t[ae]st  匹配test或tast</li><li>[^g]oo  匹配oo，但前边不能是g</li><li>[^[:lower:]]oo  匹配oo，前边不能是小写字母</li><li>[0-9]或[[:digit:]]  匹配数字0-9</li><li>^the   匹配位于行首的the</li><li>^[^[:alpha:]]   匹配行首非英文字母</li><li>\.$   匹配以小数点结尾的行</li><li>^$   匹配空白行</li><li>^#   匹配以#开头的行</li><li>a*  匹配0到无穷多个字符a</li><li>aa*  匹配1到无穷多个字符a，以此类推</li><li>.*   匹配0到无穷多个任意字符</li><li>go{2,5}g   匹配两个g中间出现2~5次o</li></ul><blockquote><p>例：<code>grep -n &quot;go\&#123;2,5\&#125;g&quot; tmp.txt</code></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux笔记-Linux快捷键</title>
    <link href="/posts/9abd.html"/>
    <url>/posts/9abd.html</url>
    
    <content type="html"><![CDATA[<h1 id="Linux快捷键"><a href="#Linux快捷键" class="headerlink" title="Linux快捷键"></a>Linux快捷键</h1><ul><li>Ctrl+Alt+F1~F6    切换终端</li><li>Tab    自动补全</li><li>移动光标<ul><li>Ctrl+A    移动光标到开头</li><li>Ctrl+B    移动光标到结尾</li><li>Ctrl+F    光标往后移动一个字符</li><li>Ctrl+B    光标往前移动一个字符</li></ul></li><li>剪切字符<ul><li>Ctrl+K    剪切光标到行尾的字符</li><li>Ctrl+U    剪切光标到行首的字符</li><li>Ctrl+Y    将剪切的字符进行粘贴</li></ul></li><li>复制粘贴<ul><li>Ctrl+Ins    复制</li><li>Shift+Ins    粘贴</li></ul></li><li>Ctrl+C    中断当前命令</li><li>Ctrl+U    删除已输入的命令串</li><li>Ctrl+D    键盘输入结束（End Of File）或离开命令行模式（相当于输入exit）</li><li>Ctrl+R    搜索命令行使用过的历史命令记录</li><li>Ctrl+L    清屏</li><li>Ctrl+Z    暂停</li><li>Ctrl+S    锁屏</li><li>Ctrl+Q    解除锁屏</li><li>Esc+.    获取上一条命令的最后部分</li><li>\ + Enter    在下一行继续输入命令</li><li>Shift+PageUp&#x2F;PageDown    命令行模式下向前&#x2F;后翻页</li><li>!!    执行上一条命令</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CurveZMQ协议简介</title>
    <link href="/posts/f088.html"/>
    <url>/posts/f088.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要介绍ZeroMQ的安全模型——CurveZMQ 协议，简单描述其流程。将个人理解记录为笔记。</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ZeroMQ的安全模型基于 CurveZMQ 协议，该协议基于 Curve25519 椭圆曲线加密算法，使用公钥加密和对称密钥加密相结合的方式。CurveZMQ 提供了端到端的加密通信，确保消息在传输过程中不会被窃听或篡改。同时，CurveZMQ 还实现了一个基于公钥&#x2F;私钥对的认证机制，以验证通信节点的身份。</p><p>CurveZMQ 可以解决重放攻击、放大攻击、MIM攻击、密钥盗窃、客户端识别和各种拒绝服务攻击。</p><p>CurveZMQ 的安全性证明和详细过程参考：<a href="https://rfc.zeromq.org/spec/26/">https://rfc.zeromq.org/spec/26/</a></p><p>其他参考网站：</p><p><a href="https://libzmq.readthedocs.io/en/latest/zmq_curve.html">https://libzmq.readthedocs.io/en/latest/zmq_curve.html</a></p><p><a href="https://blog.csdn.net/weixin_45661808/article/details/145155486">https://blog.csdn.net/weixin_45661808/article/details/145155486</a></p><p><a href="https://developer.aliyun.com/article/1463834">https://developer.aliyun.com/article/1463834</a></p><h2 id="CurveZMQ-加密通信过程"><a href="#CurveZMQ-加密通信过程" class="headerlink" title="CurveZMQ 加密通信过程"></a>CurveZMQ 加密通信过程</h2><h3 id="1-密钥对生成"><a href="#1-密钥对生成" class="headerlink" title="1. 密钥对生成"></a>1. 密钥对生成</h3><p>每个使用 CurveZMQ 的通信端（客户端和服务端）都需要生成一个公钥和私钥的密钥对。这个密钥对由以下两部分组成：</p><ol><li>私钥（Secret Key）：此密钥只能由持有者知道，用于生成共享密钥。</li><li>公钥（Public Key）：这个密钥可以公开，用来交换给对方。</li></ol><p>密钥对生成过程是通过 zmq_curve_keypair() 函数完成的（Curve25519 算法）。</p><p>客户端生成长期的<u>客户端密钥对</u>：<strong>客户端公钥</strong>、<strong>客户端私钥</strong>。</p><p>服务端生成长期的<u>服务端密钥对</u>：<strong>服务端公钥</strong>、<strong>服务端私钥</strong>。</p><h3 id="2-公钥交换"><a href="#2-公钥交换" class="headerlink" title="2. 公钥交换"></a>2. 公钥交换</h3><ul><li>在 CurveZMQ 协议中，公钥用于验证身份并生成共享密钥。因此，通信双方必须交换各自的公钥。</li><li>交换公钥的方式可以是通过配置或预先共享的方式进行。也可以在一个安全的渠道（如 HTTPS）中进行。</li><li>交换完成后，客户端知道服务端长期公钥，服务端知道客户端长期公钥</li></ul><h3 id="3-CurveZMQ握手过程"><a href="#3-CurveZMQ握手过程" class="headerlink" title="3. CurveZMQ握手过程"></a>3. CurveZMQ握手过程</h3><p>握手过程的官方详细介绍见：<a href="https://rfc.zeromq.org/spec/26/">https://rfc.zeromq.org/spec/26/</a></p><div class="note note-primary">            <p><strong>符号定义</strong>：</p><p>客户端长期密钥对记为C ，服务端长期密钥对记为S。</p><p>客户端临时密钥对记为C’，服务端临时密钥对记为S’。</p><p>定义 Box[X] (C-&gt;S) 表示一个加密盒子，它将明文X，“从C加密到S”，这意味着只有C可以创建盒子，只有S可以打开它。盒子是从C到S的单向信息传输。创建和打开盒子的实际步骤是：</p><ul><li><strong>发送方C</strong> 使用<u>C的私钥</u>和<u>S的公钥</u>计算一个共享秘钥（使用Curve25519算法计算出的ECDH秘钥），再生成一个随机数Nonce。然后使用加密函数对明文进行加密（该函数内部通常使用XSalsa20流密码进行加密，并使用Poly1305消息认证码来确保密文的完整性和真实性）</li><li><strong>接收方S</strong> 使用<u>C的公钥</u>和<u>S的私钥</u>计算相同的共享秘钥（根据Curve25519算法的原理，计算出的此秘钥与上方的共享秘钥相等），再加上相同的随机数（随报文发送），使用解密函数即可解密出明文。</li></ul>          </div><ol><li><p>客户端发起连接，首先生成一个临时密钥对。向服务端发出一个<strong>HELLO命令</strong>，其中包含客户端临时公钥。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C">hello = %d5 <span class="hljs-string">&quot;HELLO&quot;</span> hello-version hello-padding hello-client hello-nonce hello-box<br>hello-version = %x1 %x0 ; CurveZMQ major-minor version <br>hello-padding = <span class="hljs-number">72</span>%x00 ; Anti-amplification padding <br>hello-client = <span class="hljs-number">32</span>OCTET ; Client public transient key C<span class="hljs-string">&#x27; </span><br><span class="hljs-string">hello-nonce = 8OCTET ; Short nonce, prefixed by &quot;CurveZMQHELLO---&quot; </span><br><span class="hljs-string">hello-box = 80OCTET ; Signature, Box [64 * %x0](C&#x27;</span>-&gt;S) <br></code></pre></td></tr></table></figure></li><li><p>当服务器收到HELLO时，它会生成自己的临时密钥对，并将这个 服务器临时私钥 编码为“cookie”（cookie&#x3D;客户端临时公钥+服务器临时私钥），作为<strong>WELCOME命令</strong>发送回客户端。WELCOME命令还包含服务器临时公钥，加密后只有客户端可以读取（welcome-box必须使用服务端长期公钥+客户端临时私钥才能解密）。然后丢弃服务端临时密钥对。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C">welcome = %d7 <span class="hljs-string">&quot;WELCOME&quot;</span> welcome-nonce welcome-box<br>welcome-nonce = <span class="hljs-number">16</span>OCTET ; Long nonce, prefixed by <span class="hljs-string">&quot;WELCOME-&quot;</span> <br>welcome-box = <span class="hljs-number">144</span>OCTET ; Box [S<span class="hljs-string">&#x27; + cookie](S-&gt;C&#x27;</span>)<br><br>cookie = cookie-nonce cookie-box <br>cookie-nonce = <span class="hljs-number">16</span>OCTET ; Long nonce, prefixed by <span class="hljs-string">&quot;COOKIE--&quot;</span> <br>cookie-box = <span class="hljs-number">80</span>OCTET ; Box [C<span class="hljs-string">&#x27; + s&#x27;</span>](K)<br></code></pre></td></tr></table></figure></li><li><p>客户端收到WELCOME命令，解密得到服务器临时公钥和“cookie”。然后客户端发回一个<strong>INITIATE命令</strong>，其中包含“cookie”、经过加密的客户端永久公钥，只有服务端能够读取到（因为initiate-box必须用客户端临时公钥+服务端临时私钥才能解密）。服务端可从cookie中读取到客户端临时公钥+之前丢弃的服务器临时私钥。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C">initiate = %d8 <span class="hljs-string">&quot;INITIATE&quot;</span> initiate-cookie initiate-nonce initiate-box <br>initiate-cookie = cookie ; Server-provided cookie <br>initiate-nonce = <span class="hljs-number">8</span>OCTET ; Short nonce, prefixed by <span class="hljs-string">&quot;CurveZMQINITIATE&quot;</span> <br>initiate-box = <span class="hljs-number">144</span>*OCTET ; Box [C + vouch + metadata](C<span class="hljs-string">&#x27;-&gt;S&#x27;</span>) <br><br>vouch = vouch-nonce vouch-box <br>vouch-nonce = <span class="hljs-number">16</span>OCTET ; Long nonce, prefixed by <span class="hljs-string">&quot;VOUCH---&quot;</span> <br>vouch-box = <span class="hljs-number">80</span>OCTET ; Box [C<span class="hljs-string">&#x27;,S](C-&gt;S&#x27;</span>) <br></code></pre></td></tr></table></figure><div class="note note-info">            <p><u>服务端临时密钥对</u>：服务器在发送WELCOME时生成，但是并不保存。而是在cookie中传输给客户端。直到客户端回传回有效的INITIATE命令后，重新从cookie中读取出服务器临时私钥。其目的是将连接状态（服务器临时私钥的密文）交给客户端保存，自己无需在内存中为大量未完成的握手连接保存状态，能有效防御DoS拒绝服务攻击。</p>          </div></li><li><p>服务器读取INITIATE命令，解密后可读取客户端永久公钥（在上方initiate-box中），然后可以对客户端身份进行验证。然后还可以读取cookie，获取客户端临时公钥、服务器临时私钥。随即服务器回复<strong>READY命令</strong>，表示握手成功。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">ready = %d5 <span class="hljs-string">&quot;READY&quot;</span> ready-nonce ready-box <br>ready-nonce = <span class="hljs-number">8</span>OCTET ; Short nonce, prefixed by <span class="hljs-string">&quot;CurveZMQREADY---&quot;</span> <br>ready-box = <span class="hljs-number">16</span>*OCTET ; Box [metadata](S<span class="hljs-string">&#x27;-&gt;C&#x27;</span>) <br></code></pre></td></tr></table></figure></li><li><p>至此，通过安全的方式，双方各自拥有了自己的临时私钥、对方的临时公钥。利用 Curve25519 椭圆曲线算法的特性，双方可以独立地计算出相同的<strong>共享密钥</strong> (Shared Secret)，该密钥将作为本次会话的<strong>会话密钥</strong> (Session Key)。</p></li></ol><p><img src="/../../img/deepseek_mermaid_20250910_b6c48f.png"></p><h3 id="4-加密消息传输阶段"><a href="#4-加密消息传输阶段" class="headerlink" title="4. 加密消息传输阶段"></a>4. 加密消息传输阶段</h3><p>  ZeroMQ 底层使用之前协商出的会话密钥、随机数和 Poly1305 认证加密算法对消息进行加密和认证。消息负载Payload使用发送方临时私钥+接收方临时公钥，和一个在报文中发送的随机数，来进行加密（Curve25519算法）。接收方使用发送方临时公钥+接收方临时私钥，和从报文中读取的随机数nonce，进行解密，得到消息负载Payload。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C">; MESSAGE command, <span class="hljs-number">33</span>+ octets <br>message = %d7 <span class="hljs-string">&quot;MESSAGE&quot;</span> message_nonce message-box <br>message-nonce = <span class="hljs-number">8</span>OCTET ; Short nonce, prefixed by <span class="hljs-string">&quot;CurveZMQMESSAGE-&quot;</span> <br>message-box = <span class="hljs-number">17</span>*OCTET ; Box [payload](S<span class="hljs-string">&#x27;-&gt;C&#x27;</span>) or (C<span class="hljs-string">&#x27;-&gt;S&#x27;</span>) <br>; This is the text sent encrypted in the box <br>payload = payload-flags payload-data <br>payload-flags = OCTET ; Explained below <br>payload-data = *octet ; <span class="hljs-number">0</span> or more octets <br></code></pre></td></tr></table></figure><h2 id="大模型对于CurveZMQ的介绍"><a href="#大模型对于CurveZMQ的介绍" class="headerlink" title="大模型对于CurveZMQ的介绍"></a>大模型对于CurveZMQ的介绍</h2><p>下面提供两份Deepseek对于CurveZMQ的介绍，结合阅读有助于理解：</p><h4 id="文件1："><a href="#文件1：" class="headerlink" title="文件1："></a>文件1：</h4><div class="row">    <embed src="/pdf/基于CurveZMQ的加密通信方案设计-DeepSeek.pdf" width="100%" height="550" type="application/pdf"></div><h4 id="文件2："><a href="#文件2：" class="headerlink" title="文件2："></a>文件2：</h4><div class="row">    <embed src="/pdf/CurveZMQ密钥生成与安全通信详解-DeepSeek.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ZMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学术论文分享 - Hierarchical Reinforcement Learning-based Mobility-aware Content Caching and Delivery Policy for Vehicle Networks</title>
    <link href="/posts/3fb7.html"/>
    <url>/posts/3fb7.html</url>
    
    <content type="html"><![CDATA[<p>在此分享个人在2022年ICA3PP（International Conference on Algorithms and Architectures for Parallel Processing）会议发表的一篇论文。😏</p><p><strong>欢迎引用</strong>：以下为bib格式：🫡</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs routeros">@InProceedings&#123;10.1007/978-3-031-22677-9_3,<br><span class="hljs-attribute">author</span>=<span class="hljs-string">&quot;Zhang, Le</span><br><span class="hljs-string">and Lai, Yongxuan</span><br><span class="hljs-string">and Yang, Fan&quot;</span>,<br><span class="hljs-attribute">editor</span>=<span class="hljs-string">&quot;Meng, Weizhi</span><br><span class="hljs-string">and Lu, Rongxing</span><br><span class="hljs-string">and Min, Geyong</span><br><span class="hljs-string">and Vaidya, Jaideep&quot;</span>,<br><span class="hljs-attribute">title</span>=<span class="hljs-string">&quot;Hierarchical Reinforcement Learning-Based Mobility-Aware Content Caching and Delivery Policy for Vehicle Networks&quot;</span>,<br><span class="hljs-attribute">booktitle</span>=<span class="hljs-string">&quot;Algorithms and Architectures for Parallel Processing&quot;</span>,<br><span class="hljs-attribute">year</span>=<span class="hljs-string">&quot;2023&quot;</span>,<br><span class="hljs-attribute">publisher</span>=<span class="hljs-string">&quot;Springer Nature Switzerland&quot;</span>,<br><span class="hljs-attribute">address</span>=<span class="hljs-string">&quot;Cham&quot;</span>,<br><span class="hljs-attribute">pages</span>=<span class="hljs-string">&quot;43--62&quot;</span>,<br><span class="hljs-attribute">isbn</span>=<span class="hljs-string">&quot;978-3-031-22677-9&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关键词</strong>：mobile edge computing ·vehicle network ·content caching and delivery ·hierarchical reinforcement learning ·deep deterministic policy gradient</p><p><strong>论文发表链接</strong>：<a href="https://link.springer.com/chapter/10.1007/978-3-031-22677-9_3">click here</a></p><div class="row">    <embed src="/pdf/HDRLCaching-论文全文.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>边缘计算</tag>
      
      <tag>车联网</tag>
      
      <tag>强化学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题总结</title>
    <link href="/posts/d4a8.html"/>
    <url>/posts/d4a8.html</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文是在求职过程中，跟随<a href="https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">代码随想录</a>练习LeetCode题目（C++）所形成的笔记，记录下来以备后续使用。本文大体结构与代码随想录一致，并辅以<a href="https://c.biancheng.net/cplus/">C++基础教程</a>的相关知识。</p><blockquote><p>灰色引用是LeetCode题号，部分带链接。</p></blockquote><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组理论基础"><a href="#数组理论基础" class="headerlink" title="数组理论基础"></a>数组理论基础</h3><p>数组是存放在<strong>连续内存空间</strong>上的<strong>相同类型数据</strong>的集合。在删除或者增添元素的时候，就难免要<strong>移动其他元素</strong>的地址。在C++中二维数组在地址空间上是连续的。<br>复习时记得回看C++数组以及<a href="http://c.biancheng.net/view/6749.html">vector的相关函数</a>。</p><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>在<strong>有序数组中查找元素</strong>，并且<strong>没有重复元素</strong>。使用left、right两个指针。需要清楚区间的定义，是左闭右闭还是左闭右开（建议左闭右闭）。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则。时间复杂度为O(logn)</p><blockquote><p>704.<a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html">二分查找</a></p></blockquote><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>（快慢指针法）：通过<strong>两个指针</strong>在一个for循环下完成两个for循环的工作，来降低时间复杂度。要搞清楚每个指针在什么条件下移动，什么条件下不移动。</p><blockquote><p>27.移除元素，977.有序数组的平方，844.有序数组的平方</p></blockquote><h3 id="滑动窗口法"><a href="#滑动窗口法" class="headerlink" title="滑动窗口法"></a>滑动窗口法</h3><p>也属于双指针法，所谓滑动窗口，就是不断的调节<strong>子序列</strong>的起始位置和终止位置，从而得出我们要想的结果。首先想起始位置和终止位置移动会<strong>分别带来什么影响</strong>，然后要确定<strong>窗口内是什么</strong>，<strong>窗口的起始位置的移动规则</strong>，<strong>窗口的结束位置的移动规则</strong>。</p><blockquote><p>209.长度最小的子数组，<a href="https://leetcode.cn/problems/fruit-into-baskets/">904.水果成篮</a>，<a href="https://leetcode.cn/problems/minimum-window-substring/">76.最小覆盖子串</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> s, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> result = INT32_MAX;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口数值之和</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口起始位置</span><br>    <span class="hljs-type">int</span> subLength = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口的长度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) &#123;<br>        sum += nums[j];<br>        <span class="hljs-comment">// 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件</span><br>        <span class="hljs-keyword">while</span> (sum &gt;= s) &#123;<br>            subLength = (j - i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 取子序列的长度</span><br>            result = result &lt; subLength ? result : subLength;<br>            sum -= nums[i];<br>            i++;<br>            <span class="hljs-comment">// 起始位置的移动规则：sum&gt;=s，需要缩小滑动窗口之和，寻找是否存在j结尾的长度更小的子数组</span><br>        &#125;<br>        <span class="hljs-comment">// 结束位置的移动规则：sum&lt;s，需要增大滑动窗口之和，j后移  (while循环结束后sum就会小于s)</span><br>    &#125;<br>    <span class="hljs-comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span><br>    <span class="hljs-keyword">return</span> result == INT32_MAX ? <span class="hljs-number">0</span> : result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="模拟行为"><a href="#模拟行为" class="headerlink" title="模拟行为"></a>模拟行为</h3><p><strong>循环不变量</strong>原则，是写程序中的重要原则。确定模拟过程中遵循的规则。</p><blockquote><p>59.螺旋矩阵II，54.螺旋矩阵</p></blockquote><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="链表理论基础"><a href="#链表理论基础" class="headerlink" title="链表理论基础"></a>链表理论基础</h3><p>链表的节点在内存中是分散存储的，每一个节点由两部分组成，一个是<strong>数据域</strong>一个是<strong>指针域</strong>（存放指向下一个节点的指针），最后一个节点的指针域指向null。<strong>双链表</strong>：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。<strong>循环链表</strong>，顾名思义，就是链表首尾相连。<br>链表的操作：</p><ul><li><strong>删除节点</strong>：定位到删除节点的前一个节点，保存-&gt;next为tmp，将-&gt;next域设为-&gt;next-&gt;next，delete tmp。</li><li><strong>添加节点</strong>：定位到添加位置的前一个位置p，new一个新节点，next域设为p-&gt;next，p-&gt;next设为新节点地址。</li></ul><p>技巧：多<strong>画图模拟</strong>过程，考虑<strong>极端情况</strong>，包括：链表长为0，长为1，头结点位置，尾结点位置等</p><h3 id="虚节点-哨兵节点"><a href="#虚节点-哨兵节点" class="headerlink" title="虚节点&#x2F;哨兵节点"></a>虚节点&#x2F;哨兵节点</h3><p>使用一个头结点之前虚节点（dummyNode）可以有效简化删除&#x2F;添加节点时需要考虑头部位置的情况。</p><blockquote><p>203.移除链表元素，<strong>707</strong>.设计链表</p></blockquote><h3 id="双指针法-1"><a href="#双指针法-1" class="headerlink" title="双指针法"></a>双指针法</h3><p>常见的方式有prev与cur两个相差一步的指针（206、24）、slow与fast两个相差若干步的指针（19、面试02.07）、slow每次走一步fast每次走两步（142）</p><blockquote><p>206.反转链表、24.两两交换链表中的节点</p><p>19.删除链表的倒数第N个节点、面试题 02.07.链表相交</p><p>142.环形链表II</p></blockquote><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><p>一般来说哈希表都是用来<strong>快速判断一个元素是否出现集合里</strong>。对于哈希表，要知道<strong>哈希函数</strong>和<strong>哈希碰撞</strong>在哈希表中的作用。哈希函数是把传入的key映射到哈希表的索引上。哈希碰撞处理有多个key映射到相同索引上时的情景，处理碰撞的普遍方式是拉链法和线性探测法。</p><p>接下来是常见的三种哈希结构：</p><ul><li>数组</li><li>set（集合）</li><li>map（映射）</li></ul><p>集合set是一组同类型数据的集合，unordered_set类似于python中的set。映射map是一组（key，value）键值对（pair类型）的集合，unordered_map类似于python的dict、java的hashmap。在C++中，set 和 map 分别提供以下三种数据结构：</p><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值能否重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>键值能否重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>以上六种常用的是unordered_set，unordered_map。具体接口可查询：<a href="http://c.biancheng.net/view/7250.html">unordered_set</a>、<a href="http://c.biancheng.net/view/7231.html">unordered_map</a></p><h3 id="数组作为哈希表"><a href="#数组作为哈希表" class="headerlink" title="数组作为哈希表"></a>数组作为哈希表</h3><p>数组本身也是一种哈希表或者说map。在一些涉及到字母等的题目中，哈希表元素个数有限（如26个字母），就可以用数组作为简便的哈希表，使用map的空间消耗要比数组大一些，因为map要维护红黑树或者符号表，而且还要做哈希函数的运算，所以数组更加简单直接有效。</p><blockquote><p>242.有效的字母异位词、383.赎金信</p></blockquote><h3 id="set作为哈希表"><a href="#set作为哈希表" class="headerlink" title="set作为哈希表"></a>set作为哈希表</h3><p>在一些需要以较低的时间复杂度判断元素是否在一个集合中，或者是否重复出现过，就可以用unordered_set做容器。</p><blockquote><p>349.两个数组的交集、202.快乐数</p></blockquote><h3 id="map作为哈希表"><a href="#map作为哈希表" class="headerlink" title="map作为哈希表"></a>map作为哈希表</h3><p>map是一种&lt;key, value&gt;的结构，在一些合适的题中很有用，如两数之和（1）、四数相加（454）。但一些题中哈希法太过复杂，反而适合用双指针法，如<strong>三数之和（15）、四数之和（18）</strong>，这两题值得重点关注。</p><blockquote><p>1.两数之和、454.四数相加II</p></blockquote><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>C++字符串：<a href="http://c.biancheng.net/view/2236.html">库函数</a></p><h3 id="双指针法-2"><a href="#双指针法-2" class="headerlink" title="双指针法"></a>双指针法</h3><p>一快一慢两个指针或者一头一尾。<br>很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</p><blockquote><p>344.反转字符串、剑指Offer 05.替换空格、151.翻转字符串里的单词</p></blockquote><h3 id="反转系列"><a href="#反转系列" class="headerlink" title="反转系列"></a>反转系列</h3><p>基本的字符串反转使用一前一后两个指针，时间复杂度是O(n)。一些题目用到了先整体反转再局部反转（151）和先局部反转再整体反转（剑指Offer58-II.左旋转字符串）的技巧。</p><blockquote><p>151.翻转字符串里的单词、剑指Offer58-II.左旋转字符串</p></blockquote><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>KMP算法用于在O(n+m)的时间复杂度内在文本串中匹配模式串。核心思想是当字符串不匹配时，利用已经匹配过的失败信息，跳过一些不可能的字符串匹配。需要掌握的要点是：</p><ul><li>前缀表&#x2F;next数组：作用是记录了模式串与文本串不匹配的时候，模式串应该从哪里开始重新匹配。<strong>next[i]的含义</strong>是在模式串中，下标 i 之前（包括i）的子串中，最长的相同前缀、后缀的长度</li><li>KMP有两种实现方法，包括next数组与前缀表相同、前缀表统一每位减一，两者等价，下面介绍相同的情况</li><li>参考辅助理解KMP：<a href="https://www.zhihu.com/question/21923021">理解KMP</a></li><li>KMP可以解决两种经典问题：模式串匹配问题（28.实现 strStr()）、重复子串问题（459.重复的子字符串）</li><li>KMP包含两部分：快速建立前缀表和利用前缀表进行匹配。</li></ul><h4 id="快速建立前缀表："><a href="#快速建立前缀表：" class="headerlink" title="快速建立前缀表："></a>快速建立前缀表：</h4><p>思路：采用<strong>递推</strong>的方式求next数组。假设next[ 0~ i-1 ]已知的情况下，求next[ i ]的值。</p><ol><li>初始化：j指向前缀末尾位置，i指向后缀末尾位置，j&#x3D;0；</li><li>处理前后缀不相同的情况，j不断根据next[j-1]回退，直至s[i]&#x3D;s[j]或者j&#x3D;0；</li><li>处理前后缀相同的情况，s[i]&#x3D;s[j]，前后缀就可以扩展一位，j++，再赋给next[i]；</li><li>j 赋值给next[i]</li></ol><h4 id="利用前缀表进行匹配："><a href="#利用前缀表进行匹配：" class="headerlink" title="利用前缀表进行匹配："></a>利用前缀表进行匹配：</h4><ol><li>定义两个下标j 指向模式串起始位置，i指向文本串起始位置</li><li>for循环中i从0开始遍历文本串，如果在j位置匹配失败，j根据前缀表next[j-1]不断回溯，直至匹配成功</li><li>如果匹配成功，i、j后移一位（j+1，i在for循环中+1）</li><li>j移动到超出模式串的末尾，表示模式串匹配成功，返回i-模式串长度+1</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span></span>&#123;  <span class="hljs-comment">//next数组与前缀表相同，不减一的做法</span><br>        <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;  <span class="hljs-comment">// 1、初始化：j指向前缀末尾位置，i指向后缀末尾位置</span><br>        next[<span class="hljs-number">0</span>]=j;  <span class="hljs-comment">// next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;s.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-comment">// 每次循环开始时，j的值就是next[i-1]</span><br>            <span class="hljs-keyword">while</span> (j&gt;<span class="hljs-number">0</span> &amp;&amp; s[i]!=s[j])&#123;  <span class="hljs-comment">// 2、处理前后缀不相同的情况，j不断根据next[j-1]回退，直至s[i]=s[j]或者j=0</span><br>                j=next[j<span class="hljs-number">-1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (s[i]==s[j])&#123;  <span class="hljs-comment">// 3、处理前后缀相同的情况，s[i]=s[j]，前后缀就可以扩展一位，j++（即next[i-1]+1），再赋给next[i]</span><br>                j++;<br>            &#125;<br>            next[i]=j;  <span class="hljs-comment">// 4、更新next[i]</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (needle.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">// 处理特殊情况：模式串长度为0</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> next[needle.<span class="hljs-built_in">size</span>()];<br>        <span class="hljs-built_in">getNext</span>(next, needle);  <span class="hljs-comment">// 获得next数组，next[i]含义是下标i之前（包括i）的子串中，最长的相同前缀后缀的长度</span><br>        <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;haystack.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">while</span> (j&gt;<span class="hljs-number">0</span> &amp;&amp; haystack[i]!=needle[j])&#123;<br>                j=next[j<span class="hljs-number">-1</span>];  <span class="hljs-comment">// 如果在j位置匹配失败，j根据前缀表next[j-1]不断回溯，直至匹配成功</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (haystack[i]==needle[j])&#123;<br>                j++;  <span class="hljs-comment">// 匹配成功，j前移一位</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (j==needle.<span class="hljs-built_in">size</span>())&#123;<br>                <span class="hljs-keyword">return</span> i-needle.<span class="hljs-built_in">size</span>()<span class="hljs-number">+1</span>;  <span class="hljs-comment">// j移动到超出模式串的末尾，表示模式串匹配成功，返回i-模式串长度+1</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="双指针法-3"><a href="#双指针法-3" class="headerlink" title="双指针法"></a>双指针法</h2><p>双指针法广泛应用于<strong>数组、链表、字符串</strong>的题目中。</p><h3 id="fast-slow"><a href="#fast-slow" class="headerlink" title="fast &amp; slow"></a>fast &amp; slow</h3><p>定义一快一慢两个指针，有以下几种思路：</p><ul><li><p>fast和slow两个指针根据一些条件移动，复制元素，来模拟数组元素的移动</p><blockquote><p>27.移除元素、剑指Offer 05.替换空格、151.翻转字符串里的单词</p></blockquote></li><li><p>扩充数组至所需大小后，fast&amp;slow指针从后向前移动</p><blockquote><p>剑指Offer 05.替换空格</p></blockquote></li><li><p>fast指针先走几步，fast与slow相差n步，然后两个指针再同步移动</p><blockquote><p>19.删除链表的倒数第N个节点、面试题 02.07.链表相交</p></blockquote></li><li><p>fast每次走两步，slow每次走一步，两者在环中相遇</p><blockquote><p>142.环形链表II</p></blockquote></li></ul><h3 id="left-right"><a href="#left-right" class="headerlink" title="left &amp; right"></a>left &amp; right</h3><p>定义一头一尾两个指针，向中间移动</p><blockquote><p>344.反转字符串、15.三数之和、18.四数之和</p></blockquote><h3 id="pre-cur链表类"><a href="#pre-cur链表类" class="headerlink" title="pre &amp; cur链表类"></a>pre &amp; cur链表类</h3><p>在链表中常定义pre &amp; cur两个指针，来进行链表next的修改</p><blockquote><p>206.反转链表、24.两两交换链表中的节点</p></blockquote><h3 id="反转类"><a href="#反转类" class="headerlink" title="反转类"></a>反转类</h3><p>字符串的反转，不仅可能用到fast &amp; slow，也可能用到先整体反转再局部反转，或先局部反转再整体反转的方法。</p><blockquote><p>344.反转字符串、151.翻转字符串里的单词、剑指Offer58-II.左旋转字符串</p></blockquote><h3 id="N数之和"><a href="#N数之和" class="headerlink" title="N数之和"></a>N数之和</h3><p>先将数组排序，遍历前N-2个数，最后两个数设置left &amp; right两个指针向中间移动，若和小了left向右，和大了right向左。</p><blockquote><p><strong>15.三数之和、18.四数之和</strong></p></blockquote><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>栈是<strong>先进后出</strong>的数据结构，队列是<strong>先进先出</strong>的数据结构。</p><p>stack、queue、priority_queue在STL中属于容器适配器，包装了STL中的基础容器类，本质上还是容器。stack、queue使用的默认基础容器是deque，priority_queue使用的默认基础容器是vector。可以自定义底层容器。</p><p>栈和队列不允许有遍历行为，不提供迭代器。</p><p><strong>优先级队列</strong>与队列相似，只能一端进一端出，但只能访问队头的元素。当元素进入队列后，会进行排序，保证队列按照预定义的优先级排列，默认使用std::less<T>进行从大到小排列。底层采用<strong>vector形式的大顶堆&#x2F;小顶堆</strong>。</p><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 不包含任何元素的 stack 适配器，并采用默认的 deque 基础容器</span><br>stack&lt;<span class="hljs-type">int</span>&gt; values;<br><span class="hljs-comment">// 使用list为基础容器的stack</span><br>stack&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; values;<br><span class="hljs-comment">// 用一个基础容器来初始化 stack 适配器，只要该容器的类型和 stack 底层使用的基础容器类型相同即可</span><br>list&lt;<span class="hljs-type">int</span>&gt; values&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>stack&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">my_stack</span>(values);<br><span class="hljs-comment">// 用一个 stack 适配器来初始化另一个 stack 适配器，只要它们存储的元素类型以及底层采用的基础容器类型相同即可</span><br>stack&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; my_stack=my_stack1;<br><span class="hljs-comment">//stack&lt;int, list&lt;int&gt;&gt; my_stack(my_stack1);</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>empty()</td><td>当 stack 栈中没有元素时，该成员函数返回 true；反之，返回 false。</td></tr><tr><td>size()</td><td>返回 stack 栈中存储元素的个数。</td></tr><tr><td>top()</td><td>返回一个栈顶元素的引用，类型为 T&amp;。如果栈为空，程序会报错。</td></tr><tr><td>push(const T&amp; val)</td><td>先复制 val，再将 val 副本压入栈顶。这是通过调用底层容器的 push_back() 函数完成的。</td></tr><tr><td>pop()</td><td>弹出栈顶元素。</td></tr></tbody></table><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 不包含任何元素的 queue 适配器，并采用默认的 deque 基础容器</span><br>queue&lt;<span class="hljs-type">int</span>&gt; values;<br><span class="hljs-comment">// 使用list为基础容器的queue</span><br>queue&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; values;<br><span class="hljs-comment">// 用一个基础容器来初始化 queue 适配器，只要该容器的类型和 queue 底层使用的基础容器类型相同即可</span><br>list&lt;<span class="hljs-type">int</span>&gt; values&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>queue&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">my_queue</span>(values);<br><span class="hljs-comment">// 用一个 queue 适配器来初始化另一个 queue 适配器，只要它们存储的元素类型以及底层采用的基础容器类型相同即可</span><br>queue&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; my_queue=my_queue1;<br><span class="hljs-comment">//queue&lt;int, list&lt;int&gt;&gt; my_queue(my_queue1);</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>empty()</td><td>如果 queue 中没有元素的话，返回 true。</td></tr><tr><td>size()</td><td>返回 queue 中元素的个数。</td></tr><tr><td>front()</td><td>返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</td></tr><tr><td>back()</td><td>返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</td></tr><tr><td>push(const T&amp; obj)</td><td>在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。</td></tr><tr><td>pop()</td><td>删除 queue 中的第一个元素。</td></tr></tbody></table><h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 空的 priority_queue 容器，底层默认 vector 容器，排序方式默认 std::less&lt;T&gt; 方法，即大顶堆</span><br>priority_queue&lt;<span class="hljs-type">int</span>&gt; values;<br><span class="hljs-comment">//使用普通数组初始化</span><br><span class="hljs-type">int</span> values[]&#123;<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>&#125;;<br><span class="hljs-function">priority_queue&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">copy_values</span><span class="hljs-params">(values,values<span class="hljs-number">+4</span>)</span></span>; <span class="hljs-comment">//&#123;4,2,3,1&#125;</span><br><span class="hljs-comment">//使用序列式容器初始化</span><br>array&lt;<span class="hljs-type">int</span>, 4&gt;values&#123; <span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span> &#125;;<br><span class="hljs-function">priority_queue&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">copy_values</span><span class="hljs-params">(values.begin(),values.end())</span></span>;<span class="hljs-comment">//&#123;4,2,3,1&#125;</span><br><span class="hljs-comment">// 手动指定 priority_queue 使用的底层容器以及排序规则</span><br><span class="hljs-type">int</span> values[]&#123; <span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span> &#125;;<br>priority_queue&lt;<span class="hljs-type">int</span>, deque&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">copy_values</span>(values, values<span class="hljs-number">+4</span>); <span class="hljs-comment">// 小顶堆</span><br><span class="hljs-comment">// 用函数对象类自定义排序规则</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cmp</span> &#123;  <span class="hljs-comment">// 函数对象类</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; left, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; right)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> left.second &gt; right.second;  <span class="hljs-comment">// 小顶堆，从小到大排序</span><br>    &#125;<br>&#125;;<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, Cmp&gt; pri_que;<br></code></pre></td></tr></table></figure><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>empty()</td><td>如果 priority_queue 为空的话，返回 true；反之，返回 false。</td></tr><tr><td>size()</td><td>返回 priority_queue 中存储元素的个数。</td></tr><tr><td>top()</td><td>返回 priority_queue 中第一个元素的引用形式。</td></tr><tr><td>push(const T&amp; obj)</td><td>根据既定的排序规则，将元素 obj 的副本存储到 priority_queue 中适当的位置。</td></tr><tr><td>pop()</td><td>移除 priority_queue 容器适配器中第一个元素。</td></tr></tbody></table><h3 id="栈经典题目"><a href="#栈经典题目" class="headerlink" title="栈经典题目"></a>栈经典题目</h3><p>栈在计算机系统、编译器中应用广泛，如：</p><blockquote><p>20.有效的括号、71.简化路径、1047.删除字符串中的所有相邻重复项、150.逆波兰表达式求值</p></blockquote><h3 id="队列经典题目"><a href="#队列经典题目" class="headerlink" title="队列经典题目"></a>队列经典题目</h3><ul><li><p><strong>单调队列</strong></p><p>在  239.滑动窗口最大值  中，需要这样一种队列：队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队里里的元素数值是由大到小的。这就是<strong>单调队列</strong>，即单调递减或单调递增的队列。设计单调队列的时候，pop和push操作要保持如下规则：</p><p>pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作<br>push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止。</p><blockquote><p>239.滑动窗口最大值</p></blockquote></li><li><p><strong>优先级队列</strong></p><p>优先级队列就是一个披着队列外衣的堆，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。是大顶堆&#x2F;小顶堆的现成的实现。</p><blockquote><p>347.前 K 个高频元素</p></blockquote></li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="理论基础-1"><a href="#理论基础-1" class="headerlink" title="理论基础"></a>理论基础</h3><ul><li><p><strong>满二叉树</strong>：一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，深度为k，有2^k-1个节点</p><img src="https://picr.zz.ac/hoKkzC3-FA_Y-DjZpMnYskBDSzOuJy_jxRtBMGwSn3Q" style="zoom: 25%;" /></li><li><p><strong>完全二叉树</strong>：除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置</p><img src="https://picr.zz.ac/h3hJWdpN87Um5Ljqd-hDNbDEyHMK9h0vPv8xFp6Cdeg" style="zoom: 50%;" /></li><li><p><strong>二叉搜索树</strong>是一个有序树，</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul><img src="https://picr.zz.ac/BvFKnaK07L7_Sg8NbeBlRGRQIiOxBTxgmp90lpK7KfE" style="zoom: 67%;" /></li><li><p><strong>平衡二叉搜索树</strong>：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p><img src="https://picr.zz.ac/s6p9rez3eM0AKAz6Y3n8w5wgxZgD_ZmDfj7_sZpRseo"></p><p>红黑树也是一种平衡二叉树，性能优于平衡二叉树。C++中map、set、multimap，multiset的底层实现都是红黑树。</p></li><li><p><strong>存储方式</strong>：二叉树可以链式存储，也可以顺序存储。顺序存储就是用数组来存储二叉树，如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。链式存储则是通过指针把分布在散落在各个地址的节点串联一起。</p></li><li><p><strong>遍历方式</strong>：</p><ul><li>深度优先遍历（DFS）<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历（BFS）<ul><li>层次遍历（迭代法）</li></ul></li></ul></li></ul><p>其中深度优先的迭代法是用栈的数据结构实现，层次遍历的迭代法是用队列的数据结构实现。</p><h3 id="递归遍历（DFS）"><a href="#递归遍历（DFS）" class="headerlink" title="递归遍历（DFS）"></a>递归遍历（DFS）</h3><p>写递归算法的三要素：</p><ul><li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 前序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右   // 前序遍历，中序和后序修改三句话顺序即可</span><br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-built_in">traversal</span>(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="迭代遍历（DFS）"><a href="#迭代遍历（DFS）" class="headerlink" title="迭代遍历（DFS）"></a>迭代遍历（DFS）</h3><p>使用<strong>栈的结构</strong>来模拟递归的过程，时间复杂度与递归相同，但空间更小。有两种实现方式，第一种实现三种遍历不一致，不好记；第二种实现加入空指针作为待处理的标记，三种遍历写法统一，更好记。记住一种即可。</p><p>注意由于栈的“先进后出”，编写代码时顺序要与前序的“中左右”相反，中&#x2F;后序同理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 前序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root!=<span class="hljs-literal">nullptr</span>) st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>())&#123;<br>            TreeNode* node=st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node!=<span class="hljs-literal">nullptr</span>)&#123;  <span class="hljs-comment">// 非空指针，表示该节点需要访问但不处理</span><br>                st.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 弹出该节点，接下来访问子节点，但不处理（将该节点加入result）该节点</span><br>                <span class="hljs-keyword">if</span> (node-&gt;right!=<span class="hljs-literal">nullptr</span>) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 右</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left!=<span class="hljs-literal">nullptr</span>) st.<span class="hljs-built_in">push</span>(node-&gt;left);  <span class="hljs-comment">// 左，注意这里是用栈的结构，顺序与前序遍历的“中左右”相反，应为“右左中”</span><br>                st.<span class="hljs-built_in">push</span>(node);  <span class="hljs-comment">// 中，  再次将该节点压入栈中</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">nullptr</span>);  <span class="hljs-comment">// 并加上一个空指针表示待处理</span><br>                <span class="hljs-comment">// 中序和后序修改上面四句话的顺序</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 遇到空指针，表示栈中的下一个节点是待处理的</span><br>                st.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 先弹出空指针</span><br>                node=st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(node-&gt;val);  <span class="hljs-comment">// 处理该节点，加入result</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="层序遍历（BFS）"><a href="#层序遍历（BFS）" class="headerlink" title="层序遍历（BFS）"></a>层序遍历（BFS）</h3><p>从左到右一层一层的去遍历二叉树，借助“先进先出”的<strong>队列的数据结构</strong>实现迭代式的写法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>            <span class="hljs-comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size()是不断变化的</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;  <span class="hljs-comment">// 当不需要输出二维的vector时可以省去size变量和for循环</span><br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                vec.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            result.<span class="hljs-built_in">push_back</span>(vec);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><p>二叉树类的题目通常有两种思路：<strong>递归法</strong>和<strong>迭代法</strong>。</p><ul><li>对于递归法，首先要搞清楚递归函数所要实现的功能是什么，然后按照递归算法的三要素来思考。这类做法通常是使用前&#x2F;中&#x2F;后序遍历三者之一</li><li>对于迭代法，通常是采用队列的数据结构，并采用层序遍历的方式（也有例外，如101.对称二叉树使用迭代法，但不是层序遍历），要记住层序遍历的模板</li></ul><blockquote><p>226.翻转二叉树、101.对称二叉树、104.二叉树的最大深度、111.二叉树的最小深度、222.完全二叉树的节点个数、110.平衡二叉树</p></blockquote><p>二叉树的题目可分为以下几种类型：</p><ul><li>求普通二叉树的属性：一般用后序，因为需要用到左右子树的属性来计算本节点的属性，但有例外</li><li>二叉树的修改与构造：使用前序，因为需要先构造中节点</li><li>求二叉搜索树的属性：使用中序</li></ul><p>题目归类：<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87.html">二叉树总结篇</a></p><p>未看的文章：23~33</p><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h3 id="理论基础-2"><a href="#理论基础-2" class="headerlink" title="理论基础"></a>理论基础</h3><p><strong>回溯是递归的副产品，只要有递归就会有回溯</strong>，所以回溯法也经常和二叉树遍历，深度优先搜索混在一起，因为这两种方式都是用了递归。回溯法就是暴力搜索，并不是什么高效的算法，最多再剪枝一下。</p><p><strong>回溯法解决的问题都可以抽象为树形结构</strong>。因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度就构成了树的深度</strong>。递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</p><p><strong><u>回溯法的模板：</u></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>回溯算法能解决如下问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>棋盘问题：N皇后，解数独等等</li></ul><h3 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h3><p><strong>剪枝技巧：</strong></p><ul><li>for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够题目要求的k个元素了，就没有必要搜索了（77.组合）</li><li>已选元素总和如果已经大于n（题中要求的和）了，那么往后遍历就没有意义了，直接剪掉（216.组合总和III）</li><li>其他剪枝技巧需要具体问题具体分析</li></ul><p>组合问题通常需要<strong>startIndex</strong>来控制for循环的起始位置，如果是一个集合来求组合的话，就需要startIndex；如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，如：17.电话号码的字母组合。</p><p><strong>去重问题</strong>：集合元素会有重复，但要求解集不能包含重复的组合。需要理解“同一树枝上重复”与“同一树层上重复”，具体看：40.组合总和II。</p><blockquote><p>77.组合、216.组合总和III、17.电话号码的字母组合、39.组合总和、<strong>40.组合总和II</strong>、<strong>332.重新安排行程</strong></p></blockquote><h3 id="切割问题"><a href="#切割问题" class="headerlink" title="切割问题"></a>切割问题</h3><p>类似于组合问题，需要了解string的基本操作。</p><blockquote><p>131.分割回文串、93.复原IP地址</p></blockquote><h3 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h3><p>在树形结构中子集问题是要收集所有节点的结果，而组合问题是收集叶子节点的结果。</p><blockquote><p>78.子集</p></blockquote><h3 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h3><p>每层都是从0开始搜索而不是startIndex；需要used数组记录path里都放了哪些元素了。</p><blockquote><p>46.全排列</p></blockquote><h3 id="棋盘问题"><a href="#棋盘问题" class="headerlink" title="棋盘问题"></a>棋盘问题</h3><p>一些只需要找到一个解的问题（如：37. 解数独、332.重新安排行程），可以将回溯函数的<strong>返回值设为bool</strong>，当找到解直接用true返回所有递归，代码见<a href="https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html#%E5%9B%9E%E6%BA%AF%E6%B3%95">链接</a></p><blockquote><p>51.N皇后、37.解数独</p></blockquote><h3 id="时间-空间复杂度分析"><a href="#时间-空间复杂度分析" class="headerlink" title="时间&#x2F;空间复杂度分析"></a>时间&#x2F;空间复杂度分析</h3><p><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90">链接</a></p><p>未看的文章：13、14、16、19</p><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h3 id="理论基础-3"><a href="#理论基础-3" class="headerlink" title="理论基础"></a>理论基础</h3><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。贪心的问题通常是<strong>求一个最值</strong>，贪心问题没有一个固定套路，只能靠自己<strong>手动模拟</strong>，如果模拟中用了局部最优推出全局最优的思想，且<strong>找不出反例</strong>，就可以试一试贪心策略，如果不可行，可能需要动态规划。不需要精确的数学推导。</p><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><ul><li><p>有些题目数组是无序的，混乱中并不能产生最值，且题目与元素之间的相对位置无关，此时通常需要<strong>先对数组进行排序</strong>。需要看一下sort函数自定义排序规则的方式（见452. 用最少数量的箭引爆气球）。</p><p>但一些题目关乎相邻元素的关系、求连续子数组，就不能改变元素位置（如376. 摆动序列、 53. 最大子序和）。</p><blockquote><p>455.分发饼干、1005.K次取反后最大化的数组和、<strong>406.根据身高重建队列</strong>、452.用最少数量的箭引爆气球</p></blockquote></li></ul><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="理论基础-4"><a href="#理论基础-4" class="headerlink" title="理论基础"></a>理论基础</h3><p>动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多<strong>重叠子问题</strong>，使用动态规划是最有效的。所以动态规划中<strong>每一个状态一定是由上一个状态推导出来的</strong>，这一点就区分于贪心，贪心没有状态推导，而是<strong>从局部直接选最优</strong>的。</p><p><strong>对于动态规划问题，拆解为如下五步曲：</strong></p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式（由以往的状态推导出当前的状态，即dp[i-1]或dp[i-2]等推出dp[i]。一般要分情况讨论）</li><li>dp数组如何初始化（结合递推公式确定初始化。有时初始化没有实际含义，仅仅是为了保证递推公式）</li><li>确定遍历顺序（for循环顺序，根据递推公式确定，看dp[i]依赖什么）</li><li>举例推导dp数组</li></ol><p><strong>做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果。写出代码后，如果出问题，把dp数组打印出来，看看究竟是不是按照自己思路推导的。</strong></p><blockquote><p>509.斐波那契数、70. 爬楼梯、746. 使用最小花费爬楼梯、62.不同路径、63. 不同路径 II、<strong>343. 整数拆分</strong>、96.不同的二叉搜索树</p></blockquote><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解物品价值总和最大是多少。</p><ul><li>二维dp数组：</li></ul><p>dp数组的定义：<strong>dp[i] [j]表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p><p>递推公式：dp[i] [j] &#x3D; max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i])    分别对应不取物品i和取物品i的两种情况</p><p>初始化：背包容量j为0，即dp[i] [0]，初始化为0；存放编号0的物品，当 j &lt; weight[0]时dp[0] [j] 初始化为0，当j &gt;&#x3D; weight[0]时dp[0] [j] 初始化为 value[0]。</p><p>遍历顺序：先遍历物品再遍历背包容量，或者反过来都可以</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>一维dp数组：</li></ul><p>利用<strong>滚动数组压缩空间复杂度</strong>，每完整刷新一轮数组就是增加了一件物品。</p><p>dp数组的定义：容量为j的背包，所背的物品价值可以最大为dp[j]</p><p>递推公式：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i])</p><p>初始化：背包容量j为0，即dp[0]，初始化为0；其他dp[j]的值随意，但一般也初始化为0。</p><p>遍历顺序：<strong>先遍历物品并且内层倒序遍历背包容量</strong>，不能反过来。倒序是为了保证递推式中用的dp[j - weight[i]]是上一轮的值，即dp[ i - 1 ] [j - weight[i]]。否则每个物品就会多次抽取，就变成了完全背包。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>416.分割等和子集、<strong>1049. 最后一块石头的重量 II</strong></p></blockquote><p>以上两道道题类似，都是<strong>把一组数分成两组，使得两组和的差值最小</strong>。做法是对和较小的那一组做DP，转化为容积为sum&#x2F;2的背包，每个物品的体积和价值都是相同的。dp[sum&#x2F;2]表示从原数组中选择一部分数，在和不超过sum&#x2F;2的情况下，所能达到的最大和。由于已经限制了DP部分的和不超过sum&#x2F;2，所以没有被DP选中的数之和（sum - dp[sum&#x2F;2]）一定是比DP部分的和大的，那么两组和的最小差值就是sum - dp[sum&#x2F;2] - dp[sum&#x2F;2]，不需要加绝对值。</p><blockquote><p>494.目标和、 <strong>474.一和零</strong></p></blockquote><p>目标和也是一组数分为两组，但将问题转化为<strong>恰好装满背包容积</strong>，有多少种装法，初始化有所不同。一和零也是01背包，但背包的容积有两个维度，做法一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 目标和</span><br>dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;  <span class="hljs-comment">// 初始化：加和为0的取法只有一种，即什么数也不取</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=x; j&gt;=nums[i]; j--)&#123;<br>        dp[j] += dp[j-nums[i]];  <span class="hljs-comment">// 递推公式</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><p>由01背包问题延伸而来，<strong>物品数量是无限的</strong>。</p><p><strong>题目总结</strong>：</p><ul><li><p><strong>纯完全背包</strong>，求解物品价值的总和最大是多少：</p><p>与01背包问题的解法区别仅在于遍历顺序，需要将一维dp数组的遍历顺序改为 外层遍历物品并且<strong>内层正序</strong>遍历背包容量。也可以先遍历背包容量再遍历物品。<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85">链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>内层正序遍历背包容量的话，每次递推公式里的 dp[ j - weight[i]] 就已经是被覆盖的值了，即本轮的值 dp[ i ] [ j - weight[i]] ，就可以做到多次选取物品。</p><blockquote><p><a href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html#_322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2">322.零钱兑换</a></p></blockquote></li><li><p><strong>组合数</strong>，每个物品数量无限，求恰好凑成给定价值的组合数有多少：必须<strong>外层for循环遍历物品，内层for遍历背包</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] += dp[j - coins[i]];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">518.零钱兑换 II</a></p></blockquote></li><li><p><strong>排列数</strong>，每个物品数量无限，求恰好凑成给定价值的排列数有多少：必须<strong>外层for遍历背包，内层for循环遍历物品</strong>。<a href="https://leetcode.cn/problems/combination-sum-iv/solution/zu-he-zong-he-iv-by-leetcode-solution-q8zv/">理解看这里</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= amount; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">if</span> (j - coins[i] &gt;= <span class="hljs-number">0</span>) dp[j] += dp[j - coins[i]];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html#_377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-iv">377.组合总和 Ⅳ</a>、<a href="https://programmercarl.com/0139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86.html#_139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86">139.单词拆分</a></p></blockquote></li></ul><h3 id="打家劫舍系列"><a href="#打家劫舍系列" class="headerlink" title="打家劫舍系列"></a>打家劫舍系列</h3><blockquote><p><a href="https://leetcode-cn.com/problems/house-robber/">198.打家劫舍</a></p></blockquote><p>简单的动规题，dp[i] 由 dp[i-1] 和 dp[i-2] 推出</p><blockquote><p><a href="https://leetcode-cn.com/problems/house-robber-ii/">213.打家劫舍II</a></p></blockquote><p>考虑头尾两间房子，分两种情况，分别调用一次198.打家劫舍</p><blockquote><p><a href="https://leetcode.cn/problems/house-robber-iii/">337.打家劫舍 III</a></p></blockquote><p><strong>树形DP</strong>，结合了<strong>动态规划</strong>与<strong>二叉树的后序遍历</strong>。递归函数的返回值是偷与不偷的两个状态所得到的金钱构成的dp数组，必须要<strong>后序遍历</strong>，因为通过递归函数的返回值来计算父节点的dp数组。<a href="https://programmercarl.com/0337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">代码见</a></p><h3 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h3><blockquote><p><a href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">121.买卖股票的最佳时机</a></p><p><a href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">122.买卖股票的最佳时机II</a></p><p><a href="https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html">123.买卖股票的最佳时机III</a></p><p><a href="https://programmercarl.com/0188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV.html">188.买卖股票的最佳时机IV</a></p><p><a href="https://programmercarl.com/0309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html">309.最佳买卖股票时机含冷冻期</a></p><p><a href="https://programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">714.买卖股票的最佳时机含手续费</a></p></blockquote><p>做法类似，将状态分为持有和不持有（限制买卖次数时多分几个状态），定义一个二维的dp数组，第一维表示天数，第二维表示状态，dp[i] [0] 表示第i天结束时持有股票剩余金额，dp[i] [1] 表示第i天结束时不持有股票剩余金额，递推公式由dp[i-1]推出。</p><h3 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h3><blockquote><p>不连续（子序列）：</p><p><a href="https://programmercarl.com/0300.%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.html">300.最长递增子序列</a></p><p><a href="https://programmercarl.com/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html">1143.最长公共子序列</a></p><p><a href="https://programmercarl.com/1035.%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF.html">1035.不相交的线</a></p><p>连续（子数组）：</p><p><a href="https://programmercarl.com/0674.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97.html">674.最长连续递增序列</a></p><p><a href="https://programmercarl.com/0718.%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84.html">718.最长重复子数组</a></p><p><a href="https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">53.最大子序和</a></p><p>编辑距离：</p><p><a href="https://programmercarl.com/0392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.html">392.判断子序列</a></p><p><a href="https://programmercarl.com/0115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.html">115.不同的子序列</a></p><p><a href="https://programmercarl.com/0583.%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.html">583.两个字符串的删除操作</a></p><p><a href="https://programmercarl.com/0072.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html">72.编辑距离</a></p><p>回文串：</p><p><a href="https://programmercarl.com/0647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html">647.回文子串</a></p><p><a href="https://programmercarl.com/0516.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.html">516.最长回文子序列</a></p></blockquote><p>对于dp数组定义，一般是dp[i]表示以s[i]结尾的字符串或者在s[i]之前的。。。递推公式则要分类讨论，循环顺序根据递推公式决定。</p><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p><strong>单调栈的应用场景</strong>：通常是一维数组，要寻找任一个元素的<strong>右边或者左边第一个比自己大或者小的元素的位置</strong>，此时我们就要想到可以用单调栈了。时间复杂度为O(n)。</p><p><strong>单调栈的原理</strong>：当寻找右边第一个比自己大的元素时，栈中元素<strong>从栈底到栈顶应该是从大到小</strong>，遍历时遇到比栈顶元素小的元素，直接入栈；遇到比栈顶元素大的元素，就需要将栈顶元素出栈，再入栈（类似于<strong>汉诺塔</strong>，小盘子只能垒在大盘子上方），此时栈顶元素就已经找到了右边第一个比自己大的元素，即当前遍历的元素。</p><p>使用单调栈主要有三个<strong>判断条件</strong>，可以视情况合并为两个（取决于寻找的是右边严格大于自己的元素，还是大于等于）：</p><ul><li>当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况</li><li>当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况</li><li>当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">stack&lt;<span class="hljs-type">int</span>&gt; st;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(temperatures.size(), <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">// 这里的初始值0取决于问题的需求，表示没有右边比自己大的元素时的结果</span><br>st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;temperatures.<span class="hljs-built_in">size</span>(); i++)&#123;<br>    <span class="hljs-keyword">if</span> (temperatures[i] &lt;= temperatures[st.<span class="hljs-built_in">top</span>()])&#123;  <span class="hljs-comment">// 当前遍历的元素T[i]小于等于栈顶元素T[st.top()]的情况，直接入栈</span><br>        st.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况，取出栈顶元素再入栈</span><br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; temperatures[i] &gt; temperatures[st.<span class="hljs-built_in">top</span>()])&#123;<br>            result[st.<span class="hljs-built_in">top</span>()] = i-st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        st.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> result;<br></code></pre></td></tr></table></figure><p>当寻找右边比自己小的元素、左边比自己大&#x2F;小的元素时，可以进行类比，单调栈的顺序会有不同。</p><blockquote><p>739.每日温度、496.下一个更大元素 I、503.下一个更大元素II、<strong>42.接雨水、84.柱状图中最大的矩形</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>求职</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的Git学习笔记</title>
    <link href="/posts/3059.html"/>
    <url>/posts/3059.html</url>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><p>Git是目前世界上最先进的分布式版本控制系统，可以自动记录每次文件的改动，还可以让同事协作编辑。在2005年由Linus开发。相比集中式，分布式版本控制系统没有“中央服务器”，每个人的电脑上都是一个完整的版本库，不必联网；修改文件后只需把各自的修改推送给对方；还支持分支管理。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><strong>工作区（worktree）：</strong>电脑中本地代码实际存放的目录。</li><li><strong>暂存区（staged&#x2F;index）：</strong>暂时存放文件的修改的地方，一般存放在 <strong>.git</strong> 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）。</li><li><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库。包含了所有的分支与版本。</li></ul><p><img src="https://picr.zz.ac/2KIAZ1j8OdwtihselBqDixPTvQEBt3yZpUKWOYrd8FM"></p><ul><li>图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage&#x2F;index），标记为 “master” 的是 master 分支所代表的目录树。</li><li>当对工作区修改（或新增）的文件执行 <code>git add</code> 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</li><li>当执行提交操作 <code>git commit</code> 命令时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</li><li>HEAD指针指向版本库中当前分支、当前所在的版本（或者说指向某一个分支名，如main；而分支名main也是个指针，指向某一个commit）。可以使用<code>git reset</code>改变HEAD指针指向的版本。HEAD^表示当前版本的父版本，HEAD^^表示上两个版本，以此类推。commit_id也可以用版本号的前几位表示。</li></ul><h2 id="创建版本库（仓库）"><a href="#创建版本库（仓库）" class="headerlink" title="创建版本库（仓库）"></a>创建版本库（仓库）</h2><p>进入某个目录后，执行<code>git init</code>命令。该目录下就会自动生成 .git文件夹，该目录变成一个Git管理的版本库。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li><p><code>git add &lt;file&gt;</code> ：添加文件修改到暂存区</p></li><li><p><code>git commit -m &#39;message&#39;</code> ：提交暂存区的文件修改到版本库的当前分支。git管理的是文件的修改，add与commit操作的对象都是文件的修改。</p></li><li><p><code>git status</code> ：查看工作区的状态，哪些修改未提交</p><h4 id="比较差异："><a href="#比较差异：" class="headerlink" title="比较差异："></a>比较差异：</h4></li><li><p><code>git diff &lt;file&gt;</code> ：查看工作区与暂存区文件的差异</p></li><li><p><code>git diff --staged &lt;file&gt;</code> ：查看暂存区与版本库当前版本文件的差异</p><h4 id="版本回退："><a href="#版本回退：" class="headerlink" title="版本回退："></a>版本回退：</h4></li><li><p><code>git log</code> ：显示当前分支的版本历史，一个commit就对应了一个版本，也是分支图中的一个节点。<code>git log --graph --oneline --all</code>画出所有分支的分支图。</p></li><li><p><code>git reset --hard &lt;commit_id | HEAD&gt;</code> ：暂存区与工作区的文件都回退到某个版本。HEAD指针指向当前所在的版本；如果使用commit_id，HEAD指针和分支名指针也会改变（即版本库的当前版本变了）。</p></li><li><p><code>git reset &lt;commit_id | HEAD&gt;</code> ：（省略了–mixed）版本库与暂存区的文件回退到某个版本，工作区文件不变保留修改，变为未暂存的状态。如果使用commit_id，HEAD指针和分支名指针也会改变。（如果工作区已经和版本库一致，但上次提交的commit有错误，想要修改又不想产生新的commit，可以用此命令回退版本库，但保留工作区修改，修改工作区后重新提交）</p></li><li><p><code>git reflog</code> ：查看命令历史</p><h4 id="撤销修改："><a href="#撤销修改：" class="headerlink" title="撤销修改："></a>撤销修改：</h4></li><li><p><code>git restore &lt;file&gt;</code> ：使用暂存区的文件内容恢复工作区的文件（即丢弃工作区的修改）</p></li><li><p><code>git restore --staged &lt;file&gt;</code> ：使用版本库当前版本（HEAD）的内容恢复暂存区的内容（即取消暂存，工作区保持不变）</p><img src="https://picr.zz.ac/bbjYU1YbxGlq84assSJPgHtfnzGd9UZ9A2vPoGWxbd4" style="zoom: 33%;" /></li><li><p><code>git rm &lt;file&gt;</code> ：删除一个文件，并将删除操作添加至暂存区</p><h4 id="连接远程仓库："><a href="#连接远程仓库：" class="headerlink" title="连接远程仓库："></a>连接远程仓库：</h4></li><li><p><code>git remote add origin git@github.com:AquariusLeo/gitlearning.git</code> ：连接GitHub上的远程仓库，origin是这个远程连接的引用的名字，可以随便改</p></li><li><p><code>git remote -v</code> ：查看连接的远程仓库信息</p></li><li><p><code>git remote show &lt;remote-name&gt;</code>：查看所有的远程连接，或查看指定的连接的信息。</p></li><li><p><code>git push [-u] origin main</code> ：把本地的main分支的修改推送到远程库origin中。-u：将本地的main分支关联到远程库的main分支，即追踪tracking&#x2F;upstream。之后推送修改就不需要加-u。</p></li><li><p><code>git pull</code> ：把远程仓库的最新commit抓取到本地的当前分支。抓取前需要建立与远程分支的追踪关系。</p></li><li><p><code>git branch --set-upstream-to=origin/&lt;branch-name&gt; &lt;local-branch-name&gt;</code>：将本地分支与远程分支建立追踪关系。追踪关系可以用<code>git remote show origin</code>查看。在pull或者push之前都要建立追踪关系，或者使用-u选项</p></li><li><p><code>git remote rm &lt;name&gt;</code> ：删除远程库连接</p></li><li><p><code>git clone &lt;url&gt;</code> ：从远程库克隆。url可以使用ssh协议的<a href="mailto:&#103;&#105;&#x74;&#64;&#x67;&#105;&#116;&#104;&#117;&#98;&#46;&#x63;&#x6f;&#x6d;">&#103;&#105;&#x74;&#64;&#x67;&#105;&#116;&#104;&#117;&#98;&#46;&#x63;&#x6f;&#x6d;</a>……  形式，也可以是http协议的<a href="https://github.com/%E2%80%A6%E2%80%A6">https://github.com/……</a>  形式</p><h4 id="分支管理："><a href="#分支管理：" class="headerlink" title="分支管理："></a>分支管理：</h4></li><li><p><code>git branch</code> ：列出所有的已存在分支</p></li><li><p><code>git branch &lt;branchname&gt;</code> ：创建一个新分支，指向当前HEAD的位置。–delete：删除分支，–move：移动&#x2F;重命名分支，–copy：复制分支</p></li><li><p><code>git switch &lt;branchname&gt;</code> ：切换分支。-c：创建后再切换。</p></li><li><p><code>git merge &lt;branchname&gt;</code> ：合并branchname分支到当前分支。当Git无法自动合并分支时，就必须首先解决冲突，把Git合并失败的文件手动编辑为我们希望的内容。解决冲突后，再add、commit，合并完成。–no-ff：禁用Fast forward模式，在merge时必定生成一个commit，这样可避免删除分支后，会丢掉分支信息。</p></li><li><p><code>git stash</code> ：保存当前工作现场（包括工作区未add的修改和暂存区未commit的修改），之后工作区会是干净的，可以放心地创建新分支。主要用于在开发过程中临时去别的分支修复bug。</p></li><li><p><code>git stash list</code> ：查看所有被保存的工作现场。</p></li><li><p><code>git stash pop</code> ：恢复上一个保存的stash，并把它删除。</p></li><li><p><code>git cherry-pick &lt;commit_id&gt;</code> ：复制某个commit的修改到当前分支。常用于复制bug修复。</p></li><li><p><code>git rebase</code> ：（变基）把本地未push的分叉提交历史整理成直线，使得在查看历史提交的变化时更容易</p><h4 id="多人协作的工作模式："><a href="#多人协作的工作模式：" class="headerlink" title="多人协作的工作模式："></a>多人协作的工作模式：</h4></li><li><p>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</p></li><li><p>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</p></li><li><p>如果pull合并有冲突，则解决冲突，并在本地add、commit提交；</p></li><li><p>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</p></li><li><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to=origin/&lt;branch-name&gt; &lt;local-branch-name&gt;</code>。</p><h4 id="标签管理："><a href="#标签管理：" class="headerlink" title="标签管理："></a>标签管理：</h4></li><li><p>标签是版本库的一个快照，唯一确定了打标签时刻的版本，其实就是指向某个commit的指针。使用标签是为了定义简明的版本号，而不是使用很长的commit_id。</p></li><li><p><code>git tag &lt;tagname&gt; [&lt;commit_id&gt;]</code> ：给某个commit打上标签。<code>git tag</code>会列出所有的标签，<code>git show &lt;tagname&gt;</code>查看标签信息。-d：删除标签。</p></li></ul><h2 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h2><ul><li>定义别名：<code>git config --global alias.st &#39;status&#39;</code></li><li>忽略特殊文件：在.gitignore文件中配置</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>版本管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/posts/3eeb.html"/>
    <url>/posts/3eeb.html</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
