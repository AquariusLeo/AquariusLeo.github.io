<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Bash/Shell/Linux速查表</title>
    <link href="/posts/213f.html"/>
    <url>/posts/213f.html</url>
    
    <content type="html"><![CDATA[<h2 id="Bash-Shell脚本语法与Linux常用命令速查表"><a href="#Bash-Shell脚本语法与Linux常用命令速查表" class="headerlink" title="Bash&#x2F;Shell脚本语法与Linux常用命令速查表"></a>Bash&#x2F;Shell脚本语法与Linux常用命令速查表</h2><p>转载自<a href="https://github.com/skywind3000/awesome-cheatsheets">awesome-cheatsheets</a>，侵删</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">BASH CHEATSHEET (中文速查表)  -  by skywind (created on 2018/02/14)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Version: 47, Last Modified: 2019/09/24 17:58</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">https://github.com/skywind3000/awesome-cheatsheets</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">常用快捷键（默认使用 Emacs 键位）</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>CTRL+A              # 移动到行首，同 &lt;Home&gt;<br>CTRL+B              # 向后移动，同 &lt;Left&gt;<br>CTRL+C              # 结束当前命令<br>CTRL+D              # 删除光标前的字符，同 &lt;Delete&gt; ，或者没有内容时，退出会话<br>CTRL+E              # 移动到行末，同 &lt;End&gt;<br>CTRL+F              # 向前移动，同 &lt;Right&gt;<br>CTRL+G              # 退出当前编辑（比如正在 CTRL+R 搜索历史时）<br>CTRL+H              # 删除光标左边的字符，同 &lt;Backspace&gt;<br>CTRL+K              # 删除光标位置到行末的内容<br>CTRL+L              # 清屏并重新显示<br>CTRL+N              # 移动到命令历史的下一行，同 &lt;Down&gt;<br>CTRL+O              # 类似回车，但是会显示下一行历史<br>CTRL+P              # 移动到命令历史的上一行，同 &lt;Up&gt;<br>CTRL+R              # 历史命令反向搜索，使用 CTRL+G 退出搜索<br>CTRL+S              # 历史命令正向搜索，使用 CTRL+G 退出搜索<br>CTRL+T              # 交换前后两个字符<br>CTRL+U              # 删除字符到行首<br>CTRL+V              # 输入字符字面量，先按 CTRL+V 再按任意键<br>CTRL+W              # 删除光标左边的一个单词<br>CTRL+X              # 列出可能的补全<br>CTRL+Y              # 粘贴前面 CTRL+u/k/w 删除过的内容<br>CTRL+Z              # 暂停前台进程返回 bash，需要时可用 fg 将其切换回前台<br>CTRL+_              # 撤销（undo），有的终端将 CTRL+_ 映射为 CTRL+/ 或 CTRL+7<br><br>ALT+b               # 向后（左边）移动一个单词<br>ALT+d               # 删除光标后（右边）一个单词<br>ALT+f               # 向前（右边）移动一个单词<br>ALT+t               # 交换字符<br>ALT+BACKSPACE       # 删除光标前面一个单词，类似 CTRL+W，但不影响剪贴板<br><br>CTRL+X CTRL+X       # 连续按两次 CTRL+X，光标在当前位置和行首来回跳转 <br>CTRL+X CTRL+E       # 用你指定的编辑器，编辑当前命令<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">BASH 基本操作</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>exit                # 退出当前登录<br>env                 # 显示环境变量<br>echo $SHELL         # 显示你在使用什么 SHELL<br><br>bash                # 使用 bash，用 exit 返回<br>which bash          # 搜索 $PATH，查找哪个程序对应命令 bash<br>whereis bash        # 搜索可执行，头文件和帮助信息的位置，使用系统内建数据库<br>whatis bash         # 查看某个命令的解释，一句话告诉你这是干什么的<br><br>clear               # 清初屏幕内容<br>reset               # 重置终端（当你不小心 cat 了一个二进制，终端状态乱掉时使用）<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">目录操作</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>cd                  # 返回自己 $HOME 目录<br>cd &#123;dirname&#125;        # 进入目录<br>pwd                 # 显示当前所在目录<br>mkdir &#123;dirname&#125;     # 创建目录<br>mkdir -p &#123;dirname&#125;  # 递归创建目录<br>pushd &#123;dirname&#125;     # 目录压栈并进入新目录<br>popd                # 弹出并进入栈顶的目录<br>dirs -v             # 列出当前目录栈<br>cd -                # 回到之前的目录<br>cd -&#123;N&#125;             # 切换到目录栈中的第 N个目录，比如 cd -2 将切换到第二个<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">文件操作</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>ls                  # 显示当前目录内容，后面可接目录名：ls &#123;dir&#125; 显示指定目录<br>ls -l               # 列表方式显示目录内容，包括文件日期，大小，权限等信息<br>ls -1               # 列表方式显示目录内容，只显示文件名称，减号后面是数字 1<br>ls -a               # 显示所有文件和目录，包括隐藏文件（.开头的文件/目录名）<br>ln -s &#123;fn&#125; &#123;link&#125;   # 给指定文件创建一个软链接<br>cp &#123;src&#125; &#123;dest&#125;     # 拷贝文件，cp -r dir1 dir2 可以递归拷贝（目录）<br>rm &#123;fn&#125;             # 删除文件，rm -r 递归删除目录，rm -f 强制删除<br>mv &#123;src&#125; &#123;dest&#125;     # 移动文件，如果 dest 是目录，则移动，是文件名则覆盖<br>touch &#123;fn&#125;          # 创建或者更新一下制定文件<br>cat &#123;fn&#125;            # 输出文件原始内容<br>any_cmd &gt; &#123;fn&#125;      # 执行任意命令并将标准输出重定向到指定文件<br>more &#123;fn&#125;           # 逐屏显示某文件内容，空格翻页，q 退出<br>less &#123;fn&#125;           # 更高级点的 more，更多操作，q 退出<br>head &#123;fn&#125;           # 显示文件头部数行，可用 head -3 abc.txt 显示头三行<br>tail &#123;fn&#125;           # 显示文件尾部数行，可用 tail -3 abc.txt 显示尾部三行<br>tail -f &#123;fn&#125;        # 持续显示文件尾部数据，可用于监控日志<br>nano &#123;fn&#125;           # 使用 nano 编辑器编辑文件<br>vim &#123;fn&#125;            # 使用 vim 编辑文件<br>diff &#123;f1&#125; &#123;f2&#125;      # 比较两个文件的内容<br>wc &#123;fn&#125;             # 统计文件有多少行，多少个单词<br>chmod 644 &#123;fn&#125;      # 修改文件权限为 644，可以接 -R 对目录循环改权限<br>chgrp group &#123;fn&#125;    # 修改文件所属的用户组<br>chown user1 &#123;fn&#125;    # 修改文件所有人为 user1, chown user1:group1 fn 可以修改组<br>file &#123;fn&#125;           # 检测文件的类型和编码<br>basename &#123;fn&#125;       # 查看文件的名字（不包括路径）<br>dirname &#123;fn&#125;        # 查看文件的路径（不包括名字）<br>grep &#123;pat&#125; &#123;fn&#125;     # 在文件中查找出现过 pat 的内容<br>grep -r &#123;pat&#125; .     # 在当前目录下递归查找所有出现过 pat 的文件内容<br>stat &#123;fn&#125;           # 显示文件的详细信息<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">用户管理</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>whoami              # 显示我的用户名<br>who                 # 显示已登录用户信息，w / who / users 内容略有不同<br>w                   # 显示已登录用户信息，w / who / users 内容略有不同<br>users               # 显示已登录用户信息，w / who / users 内容略有不同<br>passwd              # 修改密码，passwd &#123;user&#125; 可以用于 root 修改别人密码<br>finger &#123;user&#125;       # 显示某用户信息，包括 id, 名字, 登录状态等<br>adduser &#123;user&#125;      # 添加用户<br>deluser &#123;user&#125;      # 删除用户<br>w                   # 查看谁在线<br>su                  # 切换到 root 用户<br>su -                # 切换到 root 用户并登录（执行登录脚本）<br>su &#123;user&#125;           # 切换到某用户<br>su -&#123;user&#125;          # 切换到某用户并登录（执行登录脚本）<br>id &#123;user&#125;           # 查看用户的 uid，gid 以及所属其他用户组<br>id -u &#123;user&#125;        # 打印用户 uid<br>id -g &#123;user&#125;        # 打印用户 gid<br>write &#123;user&#125;        # 向某用户发送一句消息<br>last                # 显示最近用户登录列表<br>last &#123;user&#125;         # 显示登录记录<br>lastb               # 显示失败登录记录<br>lastlog             # 显示所有用户的最近登录记录<br>sudo &#123;command&#125;      # 以 root 权限执行某命令<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">进程管理</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>ps                        # 查看当前会话进程<br>ps ax                     # 查看所有进程，类似 ps -e<br>ps aux                    # 查看所有进程详细信息，类似 ps -ef<br>ps auxww                  # 查看所有进程，并且显示进程的完整启动命令<br>ps -u &#123;user&#125;              # 查看某用户进程<br>ps axjf                   # 列出进程树<br>ps xjf -u &#123;user&#125;          # 列出某用户的进程树<br>ps -eo pid,user,command   # 按用户指定的格式查看进程<br>ps aux | grep httpd       # 查看名为 httpd 的所有进程<br>ps --ppid &#123;pid&#125;           # 查看父进程为 pid 的所有进程<br>pstree                    # 树形列出所有进程，pstree 默认一般不带，需安装<br>pstree &#123;user&#125;             # 进程树列出某用户的进程<br>pstree -u                 # 树形列出所有进程以及所属用户<br>pgrep &#123;procname&#125;          # 搜索名字匹配的进程的 pid，比如 pgrep apache2<br><br>kill &#123;pid&#125;                # 结束进程<br>kill -9 &#123;pid&#125;             # 强制结束进程，9/SIGKILL 是强制不可捕获结束信号<br>kill -KILL &#123;pid&#125;          # 强制执行进程，kill -9 的另外一种写法<br>kill -l                   # 查看所有信号<br>kill -l TERM              # 查看 TERM 信号的编号<br>killall &#123;procname&#125;        # 按名称结束所有进程<br>pkill &#123;procname&#125;          # 按名称结束进程，除名称外还可以有其他参数<br><br>top                       # 查看最活跃的进程<br>top -u &#123;user&#125;             # 查看某用户最活跃的进程<br><br>any_command &amp;             # 在后台运行某命令，也可用 CTRL+Z 将当前进程挂到后台<br>jobs                      # 查看所有后台进程（jobs）<br>bg                        # 查看后台进程，并切换过去<br>fg                        # 切换后台进程到前台<br>fg &#123;job&#125;                  # 切换特定后台进程到前台<br><br>trap cmd sig1 sig2        # 在脚本中设置信号处理命令<br>trap &quot;&quot; sig1 sig2         # 在脚本中屏蔽某信号<br>trap - sig1 sig2          # 恢复默认信号处理行为<br><br>nohup &#123;command&#125;           # 长期运行某程序，在你退出登录都保持它运行<br>nohup &#123;command&#125; &amp;         # 在后台长期运行某程序<br>disown &#123;PID|JID&#125;          # 将进程从后台任务列表（jobs）移除<br><br>wait                      # 等待所有后台进程任务结束<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">常用命令：SSH / 系统信息 / 网络</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>ssh user@host             # 以用户 user 登录到远程主机 host<br>ssh -p &#123;port&#125; user@host   # 指定端口登录主机<br>ssh-copy-id user@host     # 拷贝你的 ssh key 到远程主机，避免重复输入密码<br>scp &#123;fn&#125; user@host:path   # 拷贝文件到远程主机<br>scp user@host:path dest   # 从远程主机拷贝文件回来<br>scp -P &#123;port&#125; ...         # 指定端口远程拷贝文件<br><br>uname -a                  # 查看内核版本等信息<br>man &#123;help&#125;                # 查看帮助<br>man -k &#123;keyword&#125;          # 查看哪些帮助文档里包含了该关键字<br>info &#123;help&#125;               # 查看 info pages，比 man 更强的帮助系统<br>uptime                    # 查看系统启动时间<br>date                      # 显示日期<br>cal                       # 显示日历<br>vmstat                    # 显示内存和 CPU 使用情况<br>vmstat 10                 # 每 10 秒打印一行内存和 CPU情况，CTRL+C 退出<br>free                      # 显示内存和交换区使用情况<br>df                        # 显示磁盘使用情况<br>du                        # 显示当前目录占用，du . --max-depth=2 可以指定深度<br>du -h                     # 显示当前目录占用，-h 以方便阅读的格式输出 (K/M/G)<br>uname                     # 显示系统版本号<br>hostname                  # 显示主机名称<br>showkey -a                # 查看终端发送的按键编码<br><br>ping &#123;host&#125;               # ping 远程主机并显示结果，CTRL+C 退出<br>ping -c N &#123;host&#125;          # ping 远程主机 N 次<br>traceroute &#123;host&#125;         # 侦测路由连通情况<br>mtr &#123;host&#125;                # 高级版本 traceroute<br>host &#123;domain&#125;             # DNS 查询，&#123;domain&#125; 前面可加 -a 查看详细信息<br>whois &#123;domain&#125;            # 取得域名 whois 信息<br>dig &#123;domain&#125;              # 取得域名 dns 信息<br>route -n                  # 查看路由表<br>netstat -a                # 列出所有端口<br>netstat -an               # 查看所有连接信息，不解析域名<br>netstat -anp              # 查看所有连接信息，包含进程信息（需要 sudo）<br>netstat -l                # 查看所有监听的端口<br>netstat -t                # 查看所有 TCP 链接<br>netstat -lntu             # 显示所有正在监听的 TCP 和 UDP 信息<br>netstat -lntup            # 显示所有正在监听的 socket 及进程信息<br>netstat -i                # 显示网卡信息<br>netstat -rn               # 显示当前系统路由表，同 route -n<br>ss -an                    # 比 netstat -an 更快速更详细<br>ss -s                     # 统计 TCP 的 established, wait 等<br><br>wget &#123;url&#125;                # 下载文件，可加 --no-check-certificate 忽略 ssl 验证<br>wget -qO- &#123;url&#125;           # 下载文件并输出到标准输出（不保存）<br>curl -sL &#123;url&#125;            # 同 wget -qO- &#123;url&#125; 没有 wget 的时候使用<br><br>sz &#123;file&#125;                 # 发送文件到终端，zmodem 协议<br>rz                        # 接收终端发送过来的文件<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">变量操作</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>varname=value             # 定义变量<br>varname=value command     # 定义子进程变量并执行子进程<br>echo &quot;$varname&quot;           # 查看变量内容<br>echo $$                   # 查看当前 shell 的进程号<br>echo $!                   # 查看最近调用的后台任务进程号<br>echo $?                   # 查看最近一条命令的返回码<br>export VARNAME=value      # 设置环境变量（将会影响到子进程）<br><br>array[0]=valA             # 定义数组<br>array[1]=valB<br>array[2]=valC<br>array=([0]=valA [1]=valB [2]=valC)   # 另一种方式<br>array=(valA valB valC)               # 另一种方式<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;array[i]&#125;               <span class="hljs-comment"># 取得数组中的元素</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;#array[@]&#125;              <span class="hljs-comment"># 取得数组的长度</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;#array[i]&#125;              <span class="hljs-comment"># 取得数组中某个变量的长度</span></span><br><br>declare -a                # 查看所有数组<br>declare -f                # 查看所有函数<br>declare -F                # 查看所有函数，仅显示函数名<br>declare -i                # 查看所有整数<br>declare -r                # 查看所有只读变量<br>declare -x                # 查看所有被导出成环境变量的东西<br>declare -p varname        # 输出变量是怎么定义的（类型+值）<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;varname:-word&#125;          <span class="hljs-comment"># 如果变量不为空则返回变量，否则返回 word</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;varname:=word&#125;          <span class="hljs-comment"># 如果变量不为空则返回变量，否则赋值成 word 并返回</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;varname:?message&#125;       <span class="hljs-comment"># 如果变量不为空则返回变量，否则打印错误信息并退出</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;varname:+word&#125;          <span class="hljs-comment"># 如果变量不为空则返回 word，否则返回 null</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;varname:offset:len&#125;     <span class="hljs-comment"># 取得字符串的子字符串</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;variable#pattern&#125;       <span class="hljs-comment"># 如果变量头部匹配 pattern，则删除最小匹配部分返回剩下的</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;variable##pattern&#125;      <span class="hljs-comment"># 如果变量头部匹配 pattern，则删除最大匹配部分返回剩下的</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;variable%pattern&#125;       <span class="hljs-comment"># 如果变量尾部匹配 pattern，则删除最小匹配部分返回剩下的</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;variable%%pattern&#125;      <span class="hljs-comment"># 如果变量尾部匹配 pattern，则删除最大匹配部分返回剩下的</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;variable/pattern/str&#125;   <span class="hljs-comment"># 将变量中第一个匹配 pattern 的替换成 str，并返回</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;variable//pattern/str&#125;  <span class="hljs-comment"># 将变量中所有匹配 pattern 的地方替换成 str 并返回</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;#varname&#125;               <span class="hljs-comment"># 返回字符串长度</span></span><br><br>*(patternlist)            # 零次或者多次匹配<br>+(patternlist)            # 一次或者多次匹配<br>?(patternlist)            # 零次或者一次匹配<br>@(patternlist)            # 单词匹配<br>!(patternlist)            # 不匹配<br><br>array=($text)             # 按空格分隔 text 成数组，并赋值给变量<br>IFS=&quot;/&quot; array=($text)     # 按斜杆分隔字符串 text 成数组，并赋值给变量<br>text=&quot;$&#123;array[*]&#125;&quot;        # 用空格链接数组并赋值给变量<br>text=$(IFS=/; echo &quot;$&#123;array[*]&#125;&quot;)  # 用斜杠链接数组并赋值给变量<br><br>A=( foo bar &quot;a  b c&quot; 42 ) # 数组定义<br>B=(&quot;$&#123;A[@]:1:2&#125;&quot;)         # 数组切片：B=( bar &quot;a  b c&quot; )<br>C=(&quot;$&#123;A[@]:1&#125;&quot;)           # 数组切片：C=( bar &quot;a  b c&quot; 42 )<br>echo &quot;$&#123;B[@]&#125;&quot;            # bar a  b c<br>echo &quot;$&#123;B[1]&#125;&quot;            # a  b c<br>echo &quot;$&#123;C[@]&#125;&quot;            # bar a  b c 42<br>echo &quot;$&#123;C[@]: -2:2&#125;&quot;      # a  b c 42  减号前的空格是必须的<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">(UNIX <span class="hljs-built_in">command</span>)           <span class="hljs-comment"># 在 subshell 中运行命令 (不会改变当前 shell 的环境)，并将标准输出内容捕获并返回</span></span><br>varname=$(id -u user)     # 将用户名为 user 的 uid 赋值给 varname 变量<br><br>num=$(expr 1 + 2)         # 兼容 posix sh 的计算，使用 expr 命令计算结果<br>num=$(expr $num + 1)      # 数字自增<br>expr 2 \* \( 2 + 3 \)     # 兼容 posix sh 的复杂计算，输出 10<br><br>num=$[1 + 2]              # 计算 1+2 赋值给 num，使用 bash 独有的 $[..] 计算<br>num=$((1 + 2))            # 同上, 但该语法由 POSIX shell 指定<br>num=$(($num + 1))         # 变量递增<br>num=$((num + 1))          # 变量递增，双括号内的 $ 可以省略<br>num=$((1 + (2 + 3) * 2))  # 复杂计算<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">事件指示符 (仅在交互式 shell 生效)</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>!!                  # 上一条命令<br>!^                  # 上一条命令的第一个单词<br>!:n                 # 上一条命令的第n个单词<br>!:n-$               # 上一条命令的第n个单词到最后一个单词<br>!$                  # 上一条命令的最后一个单词<br>!-n:$               # 上n条命令的最后一个单词<br>!string             # 最近一条包含string的命令<br>!^string1^string2   # 最近一条包含string1的命令, 快速替换string1为string2<br>!#                  # 本条命令之前所有的输入内容<br>!#:n                # 本条命令之前的第n个单词, 快速备份cp /etc/passwd !#:1.bak<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">函数</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">定义一个新函数</span><br>function myfunc() &#123;<br>    # $1 代表第一个参数，$N 代表第 N 个参数<br>    # $# 代表参数个数<br>    # $0 代表被调用者自身的名字<br>    # $@ 代表所有参数，类型是个数组，想传递所有参数给其他命令用 cmd &quot;$@&quot; <br>    # $* 空格链接起来的所有参数，类型是字符串<br>    &#123;shell commands ...&#125;<br>&#125;<br><br>myfunc                    # 调用函数 myfunc <br>myfunc arg1 arg2 arg3     # 带参数的函数调用<br>myfunc &quot;$@&quot;               # 将所有参数传递给函数<br>myfunc &quot;$&#123;array[@]&#125;&quot;      # 将一个数组当作多个参数传递给函数<br>shift                     # 参数左移<br><br>unset -f myfunc           # 删除函数<br>declare -f                # 列出函数定义<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">条件判断（兼容 posix sh 的条件判断）：man <span class="hljs-built_in">test</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>statement1 &amp;&amp; statement2  # and 操作符<br>statement1 || statement2  # or 操作符<br><br>exp1 -a exp2              # exp1 和 exp2 同时为真时返回真（POSIX XSI扩展）<br>exp1 -o exp2              # exp1 和 exp2 有一个为真就返回真（POSIX XSI扩展）<br>( expression )            # 如果 expression 为真时返回真，输入注意括号前反斜杆<br>! expression              # 如果 expression 为假那返回真<br><br>str1 = str2               # 判断字符串相等，如 [ &quot;$x&quot; = &quot;$y&quot; ] &amp;&amp; echo yes<br>str1 != str2              # 判断字符串不等，如 [ &quot;$x&quot; != &quot;$y&quot; ] &amp;&amp; echo yes<br>str1 &lt; str2               # 字符串小于，如 [ &quot;$x&quot; \&lt; &quot;$y&quot; ] &amp;&amp; echo yes<br>str2 &gt; str2               # 字符串大于，注意 &lt; 或 &gt; 是字面量，输入时要加反斜杆<br>-n str1                   # 判断字符串不为空（长度大于零）<br>-z str1                   # 判断字符串为空（长度等于零）<br><br>-a file                   # 判断文件存在，如 [ -a /tmp/abc ] &amp;&amp; echo &quot;exists&quot;<br>-d file                   # 判断文件存在，且该文件是一个目录<br>-e file                   # 判断文件存在，和 -a 等价<br>-f file                   # 判断文件存在，且该文件是一个普通文件（非目录等）<br>-r file                   # 判断文件存在，且可读<br>-s file                   # 判断文件存在，且尺寸大于0<br>-w file                   # 判断文件存在，且可写<br>-x file                   # 判断文件存在，且执行<br>-N file                   # 文件上次修改过后还没有读取过<br>-O file                   # 文件存在且属于当前用户<br>-G file                   # 文件存在且匹配你的用户组<br>file1 -nt file2           # 文件1 比 文件2 新<br>file1 -ot file2           # 文件1 比 文件2 旧<br><br>num1 -eq num2             # 数字判断：num1 == num2<br>num1 -ne num2             # 数字判断：num1 != num2<br>num1 -lt num2             # 数字判断：num1 &lt; num2<br>num1 -le num2             # 数字判断：num1 &lt;= num2<br>num1 -gt num2             # 数字判断：num1 &gt; num2<br>num1 -ge num2             # 数字判断：num1 &gt;= num2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">分支控制：<span class="hljs-keyword">if</span> 和经典 <span class="hljs-built_in">test</span>，兼容 posix sh 的条件判断语句</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>test &#123;expression&#125;         # 判断条件为真的话 test 程序返回0 否则非零<br>[ expression ]            # 判断条件为真的话返回0 否则非零<br><br>test &quot;abc&quot; = &quot;def&quot;        # 查看返回值 echo $? 显示 1，因为条件为假<br>test &quot;abc&quot; != &quot;def&quot;       # 查看返回值 echo $? 显示 0，因为条件为真<br><br>test -a /tmp; echo $?     # 调用 test 判断 /tmp 是否存在，并打印 test 的返回值<br>[ -a /tmp ]; echo $?      # 和上面完全等价，/tmp 肯定是存在的，所以输出是 0<br><br>test cond &amp;&amp; cmd1         # 判断条件为真时执行 cmd1<br>[ cond ] &amp;&amp; cmd1          # 和上面完全等价<br>[ cond ] &amp;&amp; cmd1 || cmd2  # 条件为真执行 cmd1 否则执行 cmd2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">判断 /etc/passwd 文件是否存在</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">经典的 <span class="hljs-keyword">if</span> 语句就是判断后面的命令返回值为0的话，认为条件为真，否则为假</span><br>if test -e /etc/passwd; then<br>    echo &quot;alright it exists ... &quot;<br>else<br>    echo &quot;it doesn&#x27;t exist ... &quot;<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">和上面完全等价，[ 是个和 <span class="hljs-built_in">test</span> 一样的可执行程序，但最后一个参数必须为 ]</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这个名字为 <span class="hljs-string">&quot;[&quot;</span> 的可执行程序一般就在 /bin 或 /usr/bin 下面，比 <span class="hljs-built_in">test</span> 优雅些</span><br>if [ -e /etc/passwd ]; then   <br>    echo &quot;alright it exists ... &quot;<br>else<br>    echo &quot;it doesn&#x27;t exist ... &quot;<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">和上面两个完全等价，其实到 bash 时代 [ 已经是内部命令了，用 <span class="hljs-built_in">enable</span> 可以看到</span><br>[ -e /etc/passwd ] &amp;&amp; echo &quot;alright it exists&quot; || echo &quot;it doesn&#x27;t exist&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">判断变量的值</span><br>if [ &quot;$varname&quot; = &quot;foo&quot; ]; then<br>    echo &quot;this is foo&quot;<br>elif [ &quot;$varname&quot; = &quot;bar&quot; ]; then<br>    echo &quot;this is bar&quot;<br>else<br>    echo &quot;neither&quot;<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">复杂条件判断，注意 || 和 &amp;&amp; 是完全兼容 POSIX 的推荐写法</span><br>if [ $x -gt 10 ] &amp;&amp; [ $x -lt 20 ]; then<br>    echo &quot;yes, between 10 and 20&quot;<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以用 &amp;&amp; 命令连接符来做和上面完全等价的事情</span><br>[ $x -gt 10 ] &amp;&amp; [ $x -lt 20 ] &amp;&amp; echo &quot;yes, between 10 and 20&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">小括号和 -a -o 是 POSIX XSI 扩展写法，小括号是字面量，输入时前面要加反斜杆</span><br>if [ \( $x -gt 10 \) -a \( $x -lt 20 \) ]; then<br>    echo &quot;yes, between 10 and 20&quot;<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">同样可以用 &amp;&amp; 命令连接符来做和上面完全等价的事情</span><br>[ \( $x -gt 10 \) -a \( $x -lt 20 \) ] &amp;&amp; echo &quot;yes, between 10 and 20&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">判断程序存在的话就执行</span><br>[ -x /bin/ls ] &amp;&amp; /bin/ls -l<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果不考虑兼容 posix sh 和 dash 这些的话，可用 bash 独有的 ((..)) 和 [[..]]:</span><br>https://www.ibm.com/developerworks/library/l-bash-test/index.html<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">流程控制：<span class="hljs-keyword">while</span> / <span class="hljs-keyword">for</span> / <span class="hljs-keyword">case</span> / <span class="hljs-keyword">until</span></span> <br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">while</span> 循环</span><br>while condition; do<br>    statements<br>done<br><br>i=1<br>while [ $i -le 10 ]; do<br>    echo $i; <br>    i=$(expr $i + 1)<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">for</span> 循环：上面的 <span class="hljs-keyword">while</span> 语句等价</span><br>for i in &#123;1..10&#125;; do<br>    echo $i<br>done<br><br>for name [in list]; do<br>    statements<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">for</span> 列举某目录下面的所有文件</span><br>for f in /home/*; do <br>    echo $f<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">bash 独有的 (( .. )) 语句，更接近 C 语言，但是不兼容 posix sh</span><br>for (( initialisation ; ending condition ; update )); do<br>    statements<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">和上面的写法等价</span><br>for ((i = 0; i &lt; 10; i++)); do echo $i; done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">case</span> 判断</span><br>case expression in <br>    pattern1a | pattern1b | ... )<br>        statements ;;<br>    pattern2 )<br>        statements ;;<br>    * )<br>        otherwise ;;<br>esac<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">until</span> 语句</span><br>until condition; do<br>    statements<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">select</span> 语句</span><br>select name [in list]; do<br>  statements that can use $name<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">命令处理</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>command ls                         # 忽略 alias 直接执行程序或者内建命令 ls<br>builtin cd                         # 忽略 alias 直接运行内建的 cd 命令<br>enable                             # 列出所有 bash 内置命令，或禁止某命令<br>help &#123;builtin_command&#125;             # 查看内置命令的帮助（仅限 bash 内置命令）<br><br>eval $script                       # 对 script 变量中的字符串求值（执行）<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出/输入 重定向</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>cmd1 | cmd2                        # 管道，cmd1 的标准输出接到 cmd2 的标准输入<br>&lt; file                             # 将文件内容重定向为命令的标准输入<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">file                             <span class="hljs-comment"># 将命令的标准输出重定向到文件，会覆盖文件</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt; file                            <span class="hljs-comment"># 将命令的标准输出重定向到文件，追加不覆盖</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">| file                            <span class="hljs-comment"># 强制输出到文件，即便设置过：set -o noclobber</span></span><br><span class="hljs-meta prompt_">n&gt;</span><span class="language-bash">| file                           <span class="hljs-comment"># 强制将文件描述符 n的输出重定向到文件</span></span><br>&lt;&gt; file                            # 同时使用该文件作为标准输入和标准输出<br>n&lt;&gt; file                           # 同时使用文件作为文件描述符 n 的输出和输入<br><span class="hljs-meta prompt_">n&gt; </span><span class="language-bash">file                            <span class="hljs-comment"># 重定向文件描述符 n 的输出到文件</span></span><br>n&lt; file                            # 重定向文件描述符 n 的输入为文件内容<br><span class="hljs-meta prompt_">n&gt;</span><span class="language-bash">&amp;                                <span class="hljs-comment"># 将标准输出 dup/合并 到文件描述符 n</span></span><br>n&lt;&amp;                                # 将标准输入 dump/合并 定向为描述符 n<br><span class="hljs-meta prompt_">n&gt;</span><span class="language-bash">&amp;m                               <span class="hljs-comment"># 文件描述符 n 被作为描述符 m 的副本，输出用</span></span><br>n&lt;&amp;m                               # 文件描述符 n 被作为描述符 m 的副本，输入用<br>&amp;&gt;file                             # 将标准输出和标准错误重定向到文件<br>&lt;&amp;-                                # 关闭标准输入<br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&amp;-                                <span class="hljs-comment"># 关闭标准输出</span></span><br><span class="hljs-meta prompt_">n&gt;</span><span class="language-bash">&amp;-                               <span class="hljs-comment"># 关闭作为输出的文件描述符 n</span></span><br>n&lt;&amp;-                               # 关闭作为输入的文件描述符 n<br>diff &lt;(cmd1) &lt;(cmd2)               # 比较两个命令的输出<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">文本处理 - <span class="hljs-built_in">cut</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>cut -c 1-16                        # 截取每行头16个字符<br>cut -c 1-16 file                   # 截取指定文件中每行头 16个字符<br>cut -c3-                           # 截取每行从第三个字符开始到行末的内容<br>cut -d&#x27;:&#x27; -f5                      # 截取用冒号分隔的第五列内容<br>cut -d&#x27;;&#x27; -f2,10                   # 截取用分号分隔的第二和第十列内容<br>cut -d&#x27; &#x27; -f3-7                    # 截取空格分隔的三到七列<br>echo &quot;hello&quot; | cut -c1-3           # 显示 hel<br>echo &quot;hello sir&quot; | cut -d&#x27; &#x27; -f2   # 显示 sir<br>ps | tr -s &quot; &quot; | cut -d &quot; &quot; -f 2,3,4  # cut 搭配 tr 压缩字符<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">文本处理 - awk / sed</span> <br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>awk &#x27;&#123;print $5&#125;&#x27; file              # 打印文件中以空格分隔的第五列<br>awk -F &#x27;,&#x27; &#x27;&#123;print $5&#125;&#x27; file       # 打印文件中以逗号分隔的第五列<br>awk &#x27;/str/ &#123;print $2&#125;&#x27; file        # 打印文件中包含 str 的所有行的第二列<br>awk -F &#x27;,&#x27; &#x27;&#123;print $NF&#125;&#x27; file      # 打印逗号分隔的文件中的每行最后一列 <br>awk &#x27;&#123;s+=$1&#125; END &#123;print s&#125;&#x27; file   # 计算所有第一列的合<br>awk &#x27;NR%3==1&#x27; file                 # 从第一行开始，每隔三行打印一行<br><br>sed &#x27;s/find/replace/&#x27; file         # 替换文件中首次出现的字符串并输出结果 <br>sed &#x27;10s/find/replace/&#x27; file       # 替换文件第 10 行内容<br>sed &#x27;10,20s/find/replace/&#x27; file    # 替换文件中 10-20 行内容<br>sed -r &#x27;s/regex/replace/g&#x27; file    # 替换文件中所有出现的字符串<br>sed -i &#x27;s/find/replace/g&#x27; file     # 替换文件中所有出现的字符并且覆盖文件<br>sed -i &#x27;/find/i\newline&#x27; file      # 在文件的匹配文本前插入行<br>sed -i &#x27;/find/a\newline&#x27; file      # 在文件的匹配文本后插入行<br>sed &#x27;/line/s/find/replace/&#x27; file   # 先搜索行特征再执行替换<br>sed -e &#x27;s/f/r/&#x27; -e &#x27;s/f/r&#x27; file    # 执行多次替换<br>sed &#x27;s#find#replace#&#x27; file         # 使用 # 替换 / 来避免 pattern 中有斜杆<br>sed -i -r &#x27;s/^\s+//g&#x27; file         # 删除文件每行头部空格<br>sed &#x27;/^$/d&#x27; file                   # 删除文件空行并打印<br>sed -i &#x27;s/\s\+$//&#x27; file            # 删除文件每行末尾多余空格<br>sed -n &#x27;2p&#x27; file                   # 打印文件第二行<br>sed -n &#x27;2,5p&#x27; file                 # 打印文件第二到第五行<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">排序 - <span class="hljs-built_in">sort</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>sort file                          # 排序文件<br>sort -r file                       # 反向排序（降序）<br>sort -n file                       # 使用数字而不是字符串进行比较<br>sort -t: -k 3n /etc/passwd         # 按 passwd 文件的第三列进行排序<br>sort -u file                       # 去重排序<br>sort -h file                       # 支持 K/M/G 等量级符号，可与 du 结合使用<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">快速跳转 - https://github.com/rupa/z</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>source /path/to/z.sh               # .bashrc 中初始化 z.sh<br>z                                  # 列出所有历史路径以及他们的权重<br>z foo                              # 跳到历史路径中匹配 foo 的权重最大的目录<br>z foo bar                          # 跳到历史路径中匹配 foo 和 bar 权重最大的目录<br>z -l foo                           # 列出所有历史路径中匹配 foo 的目录及权重<br>z -r foo                           # 按照最高访问次数优先进行匹配跳转<br>z -t foo                           # 按照最近访问优先进行匹配跳转<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">键盘绑定</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>bind &#x27;&quot;\eh&quot;:&quot;\C-b&quot;&#x27;                # 绑定 ALT+h 为光标左移，同 CTRL+b / &lt;Left&gt;<br>bind &#x27;&quot;\el&quot;:&quot;\C-f&quot;&#x27;                # 绑定 ALT+l 为光标右移，同 CTRL+f / &lt;Right&gt;<br>bind &#x27;&quot;\ej&quot;:&quot;\C-n&quot;&#x27;                # 绑定 ALT+j 为下条历史，同 CTRL+n / &lt;Down&gt;<br>bind &#x27;&quot;\ek&quot;:&quot;\C-p&quot;&#x27;                # 绑定 ALT+k 为上条历史，同 CTRL+p / &lt;Up&gt;<br>bind &#x27;&quot;\eH&quot;:&quot;\eb&quot;&#x27;                 # 绑定 ALT+H 为光标左移一个单词，同 ALT-b <br>bind &#x27;&quot;\eL&quot;:&quot;\ef&quot;&#x27;                 # 绑定 ALT+L 为光标右移一个单词，同 ALT-f <br>bind &#x27;&quot;\eJ&quot;:&quot;\C-a&quot;&#x27;                # 绑定 ALT+J 为移动到行首，同 CTRL+a / &lt;Home&gt;<br>bind &#x27;&quot;\eK&quot;:&quot;\C-e&quot;&#x27;                # 绑定 ALT+K 为移动到行末，同 CTRL+e / &lt;End&gt;<br>bind &#x27;&quot;\e;&quot;:&quot;ls -l\n&quot;&#x27;             # 绑定 ALT+; 为执行 ls -l 命令<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">网络管理：ip / ifconfig / nmap ...</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>ip a                               # 显示所有网络地址，同 ip address<br>ip a show eth1                     # 显示网卡 IP 地址<br>ip a add 172.16.1.23/24 dev eth1   # 添加网卡 IP 地址<br>ip a del 172.16.1.23/24 dev eth1   # 删除网卡 IP 地址<br>ip link show dev eth0              # 显示网卡设备属性<br>ip link set eth1 up                # 激活网卡<br>ip link set eth1 down              # 关闭网卡<br>ip link set eth1 address &#123;mac&#125;     # 修改 MAC 地址<br>ip neighbour                       # 查看 ARP 缓存<br>ip route                           # 查看路由表<br>ip route add 10.1.0.0/24 via 10.0.0.253 dev eth0    # 添加静态路由<br>ip route del 10.1.0.0/24           # 删除静态路由<br><br>ifconfig                           # 显示所有网卡和接口信息<br>ifconfig -a                        # 显示所有网卡（包括开机没启动的）信息<br>ifconfig eth0                      # 指定设备显示信息<br>ifconfig eth0 up                   # 激活网卡<br>ifconfig eth0 down                 # 关闭网卡<br>ifconfig eth0 192.168.120.56       # 给网卡配置 IP 地址<br>ifconfig eth0 10.0.0.8 netmask 255.255.255.0 up     # 配置 IP 并启动<br>ifconfig eth0 hw ether 00:aa:bb:cc:dd:ee            # 修改 MAC 地址<br><br>nmap 10.0.0.12                     # 扫描主机 1-1000 端口<br>nmap -p 1024-65535 10.0.0.12       # 扫描给定端口<br>nmap 10.0.0.0/24                   # 给定网段扫描局域网内所有主机<br>nmap -O -sV 10.0.0.12              # 探测主机服务和操作系统版本<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">有趣的命令</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>man hier                           # 查看文件系统的结构和含义<br>man test                           # 查看 posix sh 的条件判断帮助<br>man ascii                          # 显示 ascii 表<br>getconf LONG_BIT                   # 查看系统是 32 位还是 64 位<br>bind -P                            # 列出所有 bash 的快捷键<br>mount | column -t                  # 漂亮的列出当前加载的文件系统<br>curl ip.cn                         # 取得外网 ip 地址和服务商信息<br>disown -a &amp;&amp; exit                  # 关闭所有后台任务并退出<br>cat /etc/issue                     # 查看 Linux 发行版信息<br>lsof -i port:80                    # 哪个程序在使用 80 端口？<br>showkey -a                         # 取得按键的 ASCII 码<br>svn diff | view -                  # 使用 Vim 来显示带色彩的 diff 输出<br>mv filename.&#123;old,new&#125;              # 快速文件改名<br>time read                          # 使用 CTRL-D 停止，最简单的计时功能<br>cp file.txt&#123;,.bak&#125;                 # 快速备份文件<br>sudo touch /forcefsck              # 强制在下次重启时扫描磁盘<br>find ~ -mmin 60 -type f            # 查找 $HOME 目录中，60 分钟内修改过的文件<br>curl wttr.in/~beijing              # 查看北京的天气预报<br>echo $&#123;SSH_CLIENT%% *&#125;             # 取得你是从什么 IP 链接到当前主机上的<br>echo $[RANDOM%X+1]                 # 取得 1 到 X 之间的随机数<br>bind -x &#x27;&quot;\C-l&quot;:ls -l&#x27;             # 设置 CTRL+l 为执行 ls -l 命令<br>find / -type f -size +5M           # 查找大于 5M 的文件<br>chmod --reference f1 f2            # 将 f2 的权限设置成 f1 一模一样的<br>curl -L cheat.sh                   # 速查表大全<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">常用技巧</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出最常使用的命令</span><br>history | awk &#x27;&#123;a[$2]++&#125;END&#123;for(i in a)&#123;print a[i] &quot; &quot; i&#125;&#125;&#x27; | sort -rn | head<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有网络状态：ESTABLISHED / TIME_WAIT / FIN_WAIT1 / FIN_WAIT2</span> <br>netstat -n | awk &#x27;/^tcp/ &#123;++tt[$NF]&#125; END &#123;for (a in tt) print a, tt[a]&#125;&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过 SSH 来 mount 文件系统</span><br>sshfs name@server:/path/to/folder /path/to/mount/point<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示前十个运行的进程并按内存使用量排序</span><br>ps aux | sort -nk +4 | tail<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在右上角显示时钟</span><br>while sleep 1;do tput sc;tput cup 0 $(($(tput cols)-29));date;tput rc;done&amp;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从网络上的压缩文件中解出一个文件来，并避免保存中间文件</span><br>wget -qO - &quot;http://www.tarball.com/tarball.gz&quot; | tar zxvf -<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">性能测试：测试处理器性能</span><br>python -c &quot;import test.pystone;print(test.pystone.pystones())&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">性能测试：测试内存带宽</span><br>dd if=/dev/zero of=/dev/null bs=1M count=32768<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Linux 下挂载一个 iso 文件</span><br>mount /path/to/file.iso /mnt/cdrom -oloop<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过主机 A 直接 ssh 到主机 B</span><br>ssh -t hostA ssh hostB<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载一个网站的所有图片</span><br>wget -r -l1 --no-parent -nH -nd -P/tmp -A&quot;.gif,.jpg&quot; http://example.com/images<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">快速创建项目目录</span><br>mkdir -p work/&#123;project1,project2&#125;/&#123;src,bin,bak&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">按日期范围查找文件</span><br>find . -type f -newermt &quot;2010-01-01&quot; ! -newermt &quot;2010-06-01&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示当前正在使用网络的进程</span><br>lsof -P -i -n | cut -f 1 -d &quot; &quot;| uniq | tail -n +2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Vim 中保存一个没有权限的文件</span><br>:w !sudo tee &gt; /dev/null %<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在 .bashrc / .bash_profile 中加载另外一个文件（比如你保存在 github 上的配置）</span><br>source ~/github/profiles/my_bash_init.sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">反向代理：将外网主机（202.115.8.1）端口（8443）转发到内网主机 192.168.1.2:443</span><br>ssh -CqTnN -R 0.0.0.0:8443:192.168.1.2:443  user@202.115.8.1<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">正向代理：将本地主机的 8443 端口，通过 192.168.1.3 转发到 192.168.1.2:443</span> <br>ssh -CqTnN -L 0.0.0.0:8443:192.168.1.2:443  user@192.168.1.3<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">socks5 代理：把本地 1080 端口的 socks5 的代理请求通过远程主机转发出去</span><br>ssh -CqTnN -D localhost:1080  user@202.115.8.1<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">终端下正确设置 ALT 键和 BackSpace 键</span><br>http://www.skywind.me/blog/archives/2021<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">有用的函数</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">自动解压：判断文件后缀名并调用相应解压命令</span><br>function q-extract() &#123;<br>    if [ -f $1 ] ; then<br>        case $1 in<br>        *.tar.bz2)   tar -xvjf $1    ;;<br>        *.tar.gz)    tar -xvzf $1    ;;<br>        *.tar.xz)    tar -xvJf $1    ;;<br>        *.bz2)       bunzip2 $1     ;;<br>        *.rar)       rar x $1       ;;<br>        *.gz)        gunzip $1      ;;<br>        *.tar)       tar -xvf $1     ;;<br>        *.tbz2)      tar -xvjf $1    ;;<br>        *.tgz)       tar -xvzf $1    ;;<br>        *.zip)       unzip $1       ;;<br>        *.Z)         uncompress $1  ;;<br>        *.7z)        7z x $1        ;;<br>        *)           echo &quot;don&#x27;t know how to extract &#x27;$1&#x27;...&quot; ;;<br>        esac<br>    else<br>        echo &quot;&#x27;$1&#x27; is not a valid file!&quot;<br>    fi<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">自动压缩：判断后缀名并调用相应压缩程序</span><br>function q-compress() &#123;<br>    if [ -n &quot;$1&quot; ] ; then<br>        FILE=$1<br>        case $FILE in<br>        *.tar) shift &amp;&amp; tar -cf $FILE $* ;;<br>        *.tar.bz2) shift &amp;&amp; tar -cjf $FILE $* ;;<br>        *.tar.xz) shift &amp;&amp; tar -cJf $FILE $* ;;<br>        *.tar.gz) shift &amp;&amp; tar -czf $FILE $* ;;<br>        *.tgz) shift &amp;&amp; tar -czf $FILE $* ;;<br>        *.zip) shift &amp;&amp; zip $FILE $* ;;<br>        *.rar) shift &amp;&amp; rar $FILE $* ;;<br>        esac<br>    else<br>        echo &quot;usage: q-compress &lt;foo.tar.gz&gt; ./foo ./bar&quot;<br>    fi<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">漂亮的带语法高亮的 color <span class="hljs-built_in">cat</span> ，需要先 pip install pygments</span><br>function ccat() &#123;<br>    local style=&quot;monokai&quot;<br>    if [ $# -eq 0 ]; then<br>        pygmentize -P style=$style -P tabsize=4 -f terminal256 -g<br>    else<br>        for NAME in $@; do<br>            pygmentize -P style=$style -P tabsize=4 -f terminal256 -g &quot;$NAME&quot;<br>        done<br>    fi<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">好玩的配置</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">放到你的 ~/.bashrc 配置文件中，给 man 增加漂亮的色彩高亮</span><br>export LESS_TERMCAP_mb=$&#x27;\E[1m\E[32m&#x27;<br>export LESS_TERMCAP_mh=$&#x27;\E[2m&#x27;<br>export LESS_TERMCAP_mr=$&#x27;\E[7m&#x27;<br>export LESS_TERMCAP_md=$&#x27;\E[1m\E[36m&#x27;<br>export LESS_TERMCAP_ZW=&quot;&quot;<br>export LESS_TERMCAP_us=$&#x27;\E[4m\E[1m\E[37m&#x27;<br>export LESS_TERMCAP_me=$&#x27;\E(B\E[m&#x27;<br>export LESS_TERMCAP_ue=$&#x27;\E[24m\E(B\E[m&#x27;<br>export LESS_TERMCAP_ZO=&quot;&quot;<br>export LESS_TERMCAP_ZN=&quot;&quot;<br>export LESS_TERMCAP_se=$&#x27;\E[27m\E(B\E[m&#x27;<br>export LESS_TERMCAP_ZV=&quot;&quot;<br>export LESS_TERMCAP_so=$&#x27;\E[1m\E[33m\E[44m&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ALT+hjkl/HJKL 快速移动光标，将下面内容添加到 ~/.inputrc 中可作用所有工具，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">包括 bash/zsh/python/lua 等使用 readline 的工具，帮助见：info rluserman</span><br>&quot;\eh&quot;: backward-char<br>&quot;\el&quot;: forward-char<br>&quot;\ej&quot;: next-history<br>&quot;\ek&quot;: previous-history<br>&quot;\eH&quot;: backward-word<br>&quot;\eL&quot;: forward-word<br>&quot;\eJ&quot;: beginning-of-line<br>&quot;\eK&quot;: end-of-line<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">References</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#############################################################################</span></span><br><br>https://github.com/Idnan/bash-guide<br>http://www.linuxstall.com/linux-command-line-tips-that-every-linux-user-should-know/<br>https://ss64.com/bash/syntax-keyboard.html<br>http://wiki.bash-hackers.org/commands/classictest<br>https://www.ibm.com/developerworks/library/l-bash-test/index.html<br>https://www.cyberciti.biz/faq/bash-loop-over-file/<br>https://linuxconfig.org/bash-scripting-tutorial<br>https://github.com/LeCoupa/awesome-cheatsheets/blob/master/languages/bash.sh<br>https://devhints.io/bash<br>https://github.com/jlevy/the-art-of-command-line<br>https://yq.aliyun.com/articles/68541<br>https://tiswww.case.edu/php/chet/bash/article.pdf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">vim: <span class="hljs-built_in">set</span> ts=4 sw=4 tw=0 et :</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
      <tag>Bash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux笔记-shell脚本语法</title>
    <link href="/posts/827c.html"/>
    <url>/posts/827c.html</url>
    
    <content type="html"><![CDATA[<h1 id="shell脚本语法"><a href="#shell脚本语法" class="headerlink" title="shell脚本语法"></a>shell脚本语法</h1><h2 id="脚本开头要写的内容"><a href="#脚本开头要写的内容" class="headerlink" title="脚本开头要写的内容"></a>脚本开头要写的内容</h2><ul><li>#!&#x2F;bin&#x2F;bash 或 #!&#x2F;bin&#x2F;bash</li><li>脚本的功能、作者、版本信息等</li><li>预先设置环境变量</li></ul><h2 id="变量相关规则"><a href="#变量相关规则" class="headerlink" title="变量相关规则"></a>变量相关规则</h2><ul><li>设置变量时用等号连接，如：myname&#x3D;vbird</li><li>引用变量的方式：${变量名} 或 $变量名（可能引起歧义的情况下尽量使用花括号）</li><li>输出变量内容：echo  ${变量名}</li><li>变量名不能以数字开头</li><li>等号两边不能直接出现空格，如：myname&#x3D;vbird as是错的</li><li>变量内容若有空格可用单引号或双引号，双引号中的特殊字符保留原本功能，单引号中的特殊字符仅为一般字符，如var&#x3D;”lang is $LANG”，$LANG替换为变量内容</li><li>可用反斜杠\将特殊字符( [Enter]、$、\、空格、’ )转义为一般字符，如：myname&#x3D;vbird\ tsai</li><li>若要扩增变量内容，可以如：PATH&#x3D;”$PATH”:&#x2F;home&#x2F;bin 或 PATH&#x3D;${PATH}:&#x2F;home&#x2F;bin</li><li>若要获得额外的命令所提供的信息进行替换时，可用 $(命令) ，如：version&#x3D;$(uname -r)</li><li>可使用unset取消变量，如：unset  myname</li><li>变量的数值计算，用$((运算式))，如 total&#x3D;$(( ${firstnu}*${secnu} ))，但bash中数值计算最多只能到整数</li><li>变量的默认类型为字符串，若要定义整数：declare -i num&#x3D;12，定义数组：declare -a array&#x3D;(a b c d)</li></ul><h2 id="脚本执行的两种方式"><a href="#脚本执行的两种方式" class="headerlink" title="脚本执行的两种方式"></a>脚本执行的两种方式</h2><ol><li>直接执行：包括：1、使用绝对路径&#x2F;相对路径；2、将所在目录放在PATH环境变量中；（1、2两种需要为脚本文件加上rx权限）3、用bash&#x2F;sh命令执行脚本。特点是在子进程的bash中执行，子进程结束后，变量或操作不会传回父进程。</li><li>利用source：用法是source  脚本名，特点是在父进程中执行，各项操作会在原bash中生效</li></ol><h2 id="test命令的测试功能"><a href="#test命令的测试功能" class="headerlink" title="test命令的测试功能"></a>test命令的测试功能</h2><p>语法：test  选项  文件名&#x2F;变量&#x2F;字符串……</p><p>test命令没有输出，当测试成功，命令返回值 $? 变量为0，失败则为非0。因此可以结合&amp;&amp;、|| 使用。</p><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><ul><li>-e：文件名是否存在</li><li>-f：文件名是否存在且为文件</li><li>-d：文件名是否存在且为目录</li><li>n1 -eq n2：两数值相等（不等使用-ne）</li><li>n1 -gt n2：n1大于n2（小于使用-lt）</li><li>-z  string：字符串是否为空</li><li>str1 &#x3D; str2     （若使用判断符号，必须写为[ str1 &#x3D; str2 ] 或者 [[ str1 &#x3D;&#x3D; str2 ]]）（关于 [] 与 [[]] 的区别可参考<a href="https://tao.zz.ac/unix/test-bracket.html">博客</a>）</li><li>str1 !&#x3D; str2</li><li>-a 且   -o 或     ！非</li></ul><p>更多选项及用法如文件类型、权限检测、文件比较、整数比较、字符串判定、多重条件判定等，见私房菜P396</p><p>常结合命令执行的判断依据&amp;&amp;、|| 使用，如：test  -e  filename  &amp;&amp;  echo  “Exist”  ||  echo  “Not exist”</p><h2 id="判断符号"><a href="#判断符号" class="headerlink" title="判断符号[ ]"></a>判断符号[ ]</h2><p>用法与test相同，如 [ -e  filename ] 等价于 test  -e  filename，也可与&amp;&amp;、|| 结合使用</p><p>注意中括号内的每一个组件之间都要有空格分隔，每一个变量或常量都要有双引号</p><h2 id="默认变量"><a href="#默认变量" class="headerlink" title="默认变量"></a>默认变量</h2><ul><li>$0：脚本文件名</li><li>$1、$2等：依次为各个参数</li><li>$#：输入的参数个数</li><li>$@：所有参数，代表【”$1”  “$2”  “$3”  …】，以空格隔开</li></ul><h2 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ 条件判断式1 ]; then<br>程序段<br>elif [ 条件判断式2 ]; then<br>程序段<br>else<br>程序段<br>fi<br></code></pre></td></tr></table></figure><p>多个条件判断式可以用&amp;&amp;或 || 连接，如 [ 条件判断式1 ] &amp;&amp; [ 条件判断式2 ]</p><h3 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">case $&#123;变量名&#125; in<br>   &quot;第1个变量内容&quot;）<br>程序段<br>;;<br>   &quot;第2个变量内容&quot;）<br>程序段<br>;;<br>   *)<br>程序段<br>;;<br>esac<br></code></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">function 函数名() &#123;<br>函数体<br>&#125;<br></code></pre></td></tr></table></figure><p>函数体中可用$1、$2等代表参数1、参数2等</p><p>调用方式：函数名  参数1  参数2  ……   如：<code>printit 1</code></p><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">while [ 条件判断式 ]<br>do<br>程序段<br>done<br></code></pre></td></tr></table></figure><h4 id="until语句"><a href="#until语句" class="headerlink" title="until语句"></a>until语句</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">until [ 条件判断式 ]<br>do<br>程序段<br>done<br></code></pre></td></tr></table></figure><h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">for var in con1 con2 ...<br>do<br>程序段<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">例子：</span><br>users=$(cut -d &#x27;:&#x27; -f1 /etc/passwd)<br>for username in $&#123;users&#125;<br>do<br>id $&#123;username&#125;<br>done<br></code></pre></td></tr></table></figure><p>in后面的内容可以用 $(seq  n1  n2) 或 {n1…n2} ，代表n1到n2的连续输字</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for (( 初始值; 限制值; 赋值运算 ))<br>do<br>程序段<br>done<br></code></pre></td></tr></table></figure><p>与C语言用法相同</p><h2 id="脚本跟踪与调试"><a href="#脚本跟踪与调试" class="headerlink" title="脚本跟踪与调试"></a>脚本跟踪与调试</h2><p>sh  调试shell脚本</p><p>语法：sh [-nx] 脚本名</p><p>选项</p><ul><li>-n：不执行脚本，仅查询语法问题</li><li>-x：将执行过程显示出来，非常有用，可用于调试</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux笔记-正则表达式</title>
    <link href="/posts/789.html"/>
    <url>/posts/789.html</url>
    
    <content type="html"><![CDATA[<h1 id="正则表达式RegularExpression"><a href="#正则表达式RegularExpression" class="headerlink" title="正则表达式RegularExpression"></a>正则表达式RegularExpression</h1><p>一种字符串处理的表示方式。正则表达式可用在多种场合，常见的用法是用grep&#x2F;sed&#x2F;awk命令对文件内容进行匹配筛选，如 <code>grep -n &quot;g..d&quot; tmp.txt</code> 命令匹配文件中含有g??d形式的行，并输出行号。还可用于vim编辑器中。</p><h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><ul><li>[:alnum:]：英文大小写字符及数字（注意匹配时要写双层方括号，如 [[:alnum:]] 、[^[:digit:]]）</li><li>[:alpha:]：英文大小写字符</li><li>[:lower:]：英文小写字符，即a~z</li><li>[:upper:]：英文大写字符，即A~Z</li><li>[:digit:]：数字，即0~9</li><li>[:blank:]：空格键与Tab键</li><li>[:graph:]：除了空格符（空格键与[Tab]按键）外的其他所有按键</li><li>[:cntrl:]：控制按键，包括CR、LF、Tab、Del等</li><li>[:print:]：代表任何可以被打印出来的字符</li><li>[:punct:]：代表标点符号（punctuation symbol），亦即:”‘?!;:#$</li><li>[:space:]：任何会产生空白的字符，包括空格键、[Tab]、 CR等</li><li>[:xdigit:]：代表十六进制的数字类型，因此包括0 ~ 9、A ~ F、a ~ f 的数字与字符</li></ul><h2 id="基础RE字符"><a href="#基础RE字符" class="headerlink" title="基础RE字符"></a>基础RE字符</h2><ul><li>^word：^匹配行首</li><li>word$：$匹配行尾</li><li>.：小数点，匹配一个任意字符</li><li>*：星号，与一个RE字符搭配使用，表示前一个RE字符重复0到无穷多次（注意正则表达式与通配符不同，通配符中星号代表0到无穷多个字符，？代表任意一个字符）</li><li>\：将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\\‘ 匹配 “\“，而 ‘\(‘ 则匹配 “(“。</li><li>[list]：字符集合，匹配一个方括号中的字符，注意仅匹配一个</li><li>[n1-n2]：字符范围，匹配两个字符之间的连续字符中的一个</li><li>[^list]：反向选择，匹配不在list中的字符</li><li>{n,m}：代表前一个RE字符重复n到m次，{n}表示重复n次，{n,}表示重复至少n次</li></ul><blockquote><p>注意 { 与 } 符号在shell中有特殊含义（用于变量），所以如果在shell中grep使用正则，要加上转义符\ 。例如输入 <code>grep -n &quot;o\&#123;2\&#125;&quot; tmp.txt</code>  将在文件中匹配含有两个o的字符串。在其他地方用正则不用这样。</p></blockquote><h2 id="拓展RE字符"><a href="#拓展RE字符" class="headerlink" title="拓展RE字符"></a>拓展RE字符</h2><ul><li>拓展正则表达式要使用egrep（grep -E的别名）或sed  -r，见私房菜P376</li><li>+：加号，与一个RE字符搭配使用，表示前一个RE字符重复1到无穷多次</li><li>?：问号，与一个RE字符搭配使用，表示前一个RE字符重复0或1次</li><li>|：或，如 gd|god</li><li>( )：标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用</li><li>( )+：多个重复群组的判别</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ul><li>t[ae]st  匹配test或tast</li><li>[^g]oo  匹配oo，但前边不能是g</li><li>[^[:lower:]]oo  匹配oo，前边不能是小写字母</li><li>[0-9]或[[:digit:]]  匹配数字0-9</li><li>^the   匹配位于行首的the</li><li>^[^[:alpha:]]   匹配行首非英文字母</li><li>\.$   匹配以小数点结尾的行</li><li>^$   匹配空白行</li><li>^#   匹配以#开头的行</li><li>a*  匹配0到无穷多个字符a</li><li>aa*  匹配1到无穷多个字符a，以此类推</li><li>.*   匹配0到无穷多个任意字符</li><li>go{2,5}g   匹配两个g中间出现2~5次o</li></ul><blockquote><p>例：<code>grep -n &quot;go\&#123;2,5\&#125;g&quot; tmp.txt</code></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux笔记-Linux快捷键</title>
    <link href="/posts/9abd.html"/>
    <url>/posts/9abd.html</url>
    
    <content type="html"><![CDATA[<h1 id="Linux快捷键"><a href="#Linux快捷键" class="headerlink" title="Linux快捷键"></a>Linux快捷键</h1><ul><li>Ctrl+Alt+F1~F6    切换终端</li><li>Tab    自动补全</li><li>移动光标<ul><li>Ctrl+A    移动光标到开头</li><li>Ctrl+B    移动光标到结尾</li><li>Ctrl+F    光标往后移动一个字符</li><li>Ctrl+B    光标往前移动一个字符</li></ul></li><li>剪切字符<ul><li>Ctrl+K    剪切光标到行尾的字符</li><li>Ctrl+U    剪切光标到行首的字符</li><li>Ctrl+Y    将剪切的字符进行粘贴</li></ul></li><li>复制粘贴<ul><li>Ctrl+Ins    复制</li><li>Shift+Ins    粘贴</li></ul></li><li>Ctrl+C    中断当前命令</li><li>Ctrl+U    删除已输入的命令串</li><li>Ctrl+D    键盘输入结束（End Of File）或离开命令行模式（相当于输入exit）</li><li>Ctrl+R    搜索命令行使用过的历史命令记录</li><li>Ctrl+L    清屏</li><li>Ctrl+Z    暂停</li><li>Ctrl+S    锁屏</li><li>Ctrl+Q    解除锁屏</li><li>Esc+.    获取上一条命令的最后部分</li><li>\ + Enter    在下一行继续输入命令</li><li>Shift+PageUp&#x2F;PageDown    命令行模式下向前&#x2F;后翻页</li><li>!!    执行上一条命令</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CurveZMQ协议简介</title>
    <link href="/posts/f088.html"/>
    <url>/posts/f088.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要介绍ZeroMQ的安全模型——CurveZMQ 协议，简单描述其流程。将个人理解记录为笔记。</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ZeroMQ的安全模型基于 CurveZMQ 协议，该协议基于 Curve25519 椭圆曲线加密算法，使用公钥加密和对称密钥加密相结合的方式。CurveZMQ 提供了端到端的加密通信，确保消息在传输过程中不会被窃听或篡改。同时，CurveZMQ 还实现了一个基于公钥&#x2F;私钥对的认证机制，以验证通信节点的身份。</p><p>CurveZMQ 可以解决重放攻击、放大攻击、MIM攻击、密钥盗窃、客户端识别和各种拒绝服务攻击。</p><p>CurveZMQ 的安全性证明和详细过程参考：<a href="https://rfc.zeromq.org/spec/26/">https://rfc.zeromq.org/spec/26/</a></p><p>其他参考网站：</p><p><a href="https://libzmq.readthedocs.io/en/latest/zmq_curve.html">https://libzmq.readthedocs.io/en/latest/zmq_curve.html</a></p><p><a href="https://blog.csdn.net/weixin_45661808/article/details/145155486">https://blog.csdn.net/weixin_45661808/article/details/145155486</a></p><p><a href="https://developer.aliyun.com/article/1463834">https://developer.aliyun.com/article/1463834</a></p><h2 id="CurveZMQ-加密通信过程"><a href="#CurveZMQ-加密通信过程" class="headerlink" title="CurveZMQ 加密通信过程"></a>CurveZMQ 加密通信过程</h2><h3 id="1-密钥对生成"><a href="#1-密钥对生成" class="headerlink" title="1. 密钥对生成"></a>1. 密钥对生成</h3><p>每个使用 CurveZMQ 的通信端（客户端和服务端）都需要生成一个公钥和私钥的密钥对。这个密钥对由以下两部分组成：</p><ol><li>私钥（Secret Key）：此密钥只能由持有者知道，用于生成共享密钥。</li><li>公钥（Public Key）：这个密钥可以公开，用来交换给对方。</li></ol><p>密钥对生成过程是通过 zmq_curve_keypair() 函数完成的（Curve25519 算法）。</p><p>客户端生成长期的<u>客户端密钥对</u>：<strong>客户端公钥</strong>、<strong>客户端私钥</strong>。</p><p>服务端生成长期的<u>服务端密钥对</u>：<strong>服务端公钥</strong>、<strong>服务端私钥</strong>。</p><h3 id="2-公钥交换"><a href="#2-公钥交换" class="headerlink" title="2. 公钥交换"></a>2. 公钥交换</h3><ul><li>在 CurveZMQ 协议中，公钥用于验证身份并生成共享密钥。因此，通信双方必须交换各自的公钥。</li><li>交换公钥的方式可以是通过配置或预先共享的方式进行。也可以在一个安全的渠道（如 HTTPS）中进行。</li><li>交换完成后，客户端知道服务端长期公钥，服务端知道客户端长期公钥</li></ul><h3 id="3-CurveZMQ握手过程"><a href="#3-CurveZMQ握手过程" class="headerlink" title="3. CurveZMQ握手过程"></a>3. CurveZMQ握手过程</h3><p>握手过程的官方详细介绍见：<a href="https://rfc.zeromq.org/spec/26/">https://rfc.zeromq.org/spec/26/</a></p><div class="note note-primary">            <p><strong>符号定义</strong>：</p><p>客户端长期密钥对记为C ，服务端长期密钥对记为S。</p><p>客户端临时密钥对记为C’，服务端临时密钥对记为S’。</p><p>定义 Box[X] (C-&gt;S) 表示一个加密盒子，它将明文X，“从C加密到S”，这意味着只有C可以创建盒子，只有S可以打开它。盒子是从C到S的单向信息传输。创建和打开盒子的实际步骤是：</p><ul><li><strong>发送方C</strong> 使用<u>C的私钥</u>和<u>S的公钥</u>计算一个共享秘钥（使用Curve25519算法计算出的ECDH秘钥），再生成一个随机数Nonce。然后使用加密函数对明文进行加密（该函数内部通常使用XSalsa20流密码进行加密，并使用Poly1305消息认证码来确保密文的完整性和真实性）</li><li><strong>接收方S</strong> 使用<u>C的公钥</u>和<u>S的私钥</u>计算相同的共享秘钥（根据Curve25519算法的原理，计算出的此秘钥与上方的共享秘钥相等），再加上相同的随机数（随报文发送），使用解密函数即可解密出明文。</li></ul>          </div><ol><li><p>客户端发起连接，首先生成一个临时密钥对。向服务端发出一个<strong>HELLO命令</strong>，其中包含客户端临时公钥。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C">hello = %d5 <span class="hljs-string">&quot;HELLO&quot;</span> hello-version hello-padding hello-client hello-nonce hello-box<br>hello-version = %x1 %x0 ; CurveZMQ major-minor version <br>hello-padding = <span class="hljs-number">72</span>%x00 ; Anti-amplification padding <br>hello-client = <span class="hljs-number">32</span>OCTET ; Client public transient key C<span class="hljs-string">&#x27; </span><br><span class="hljs-string">hello-nonce = 8OCTET ; Short nonce, prefixed by &quot;CurveZMQHELLO---&quot; </span><br><span class="hljs-string">hello-box = 80OCTET ; Signature, Box [64 * %x0](C&#x27;</span>-&gt;S) <br></code></pre></td></tr></table></figure></li><li><p>当服务器收到HELLO时，它会生成自己的临时密钥对，并将这个 服务器临时私钥 编码为“cookie”（cookie&#x3D;客户端临时公钥+服务器临时私钥），作为<strong>WELCOME命令</strong>发送回客户端。WELCOME命令还包含服务器临时公钥，加密后只有客户端可以读取（welcome-box必须使用服务端长期公钥+客户端临时私钥才能解密）。然后丢弃服务端临时密钥对。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C">welcome = %d7 <span class="hljs-string">&quot;WELCOME&quot;</span> welcome-nonce welcome-box<br>welcome-nonce = <span class="hljs-number">16</span>OCTET ; Long nonce, prefixed by <span class="hljs-string">&quot;WELCOME-&quot;</span> <br>welcome-box = <span class="hljs-number">144</span>OCTET ; Box [S<span class="hljs-string">&#x27; + cookie](S-&gt;C&#x27;</span>)<br><br>cookie = cookie-nonce cookie-box <br>cookie-nonce = <span class="hljs-number">16</span>OCTET ; Long nonce, prefixed by <span class="hljs-string">&quot;COOKIE--&quot;</span> <br>cookie-box = <span class="hljs-number">80</span>OCTET ; Box [C<span class="hljs-string">&#x27; + s&#x27;</span>](K)<br></code></pre></td></tr></table></figure></li><li><p>客户端收到WELCOME命令，解密得到服务器临时公钥和“cookie”。然后客户端发回一个<strong>INITIATE命令</strong>，其中包含“cookie”、经过加密的客户端永久公钥，只有服务端能够读取到（因为initiate-box必须用客户端临时公钥+服务端临时私钥才能解密）。服务端可从cookie中读取到客户端临时公钥+之前丢弃的服务器临时私钥。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C">initiate = %d8 <span class="hljs-string">&quot;INITIATE&quot;</span> initiate-cookie initiate-nonce initiate-box <br>initiate-cookie = cookie ; Server-provided cookie <br>initiate-nonce = <span class="hljs-number">8</span>OCTET ; Short nonce, prefixed by <span class="hljs-string">&quot;CurveZMQINITIATE&quot;</span> <br>initiate-box = <span class="hljs-number">144</span>*OCTET ; Box [C + vouch + metadata](C<span class="hljs-string">&#x27;-&gt;S&#x27;</span>) <br><br>vouch = vouch-nonce vouch-box <br>vouch-nonce = <span class="hljs-number">16</span>OCTET ; Long nonce, prefixed by <span class="hljs-string">&quot;VOUCH---&quot;</span> <br>vouch-box = <span class="hljs-number">80</span>OCTET ; Box [C<span class="hljs-string">&#x27;,S](C-&gt;S&#x27;</span>) <br></code></pre></td></tr></table></figure><div class="note note-info">            <p><u>服务端临时密钥对</u>：服务器在发送WELCOME时生成，但是并不保存。而是在cookie中传输给客户端。直到客户端回传回有效的INITIATE命令后，重新从cookie中读取出服务器临时私钥。其目的是将连接状态（服务器临时私钥的密文）交给客户端保存，自己无需在内存中为大量未完成的握手连接保存状态，能有效防御DoS拒绝服务攻击。</p>          </div></li><li><p>服务器读取INITIATE命令，解密后可读取客户端永久公钥（在上方initiate-box中），然后可以对客户端身份进行验证。然后还可以读取cookie，获取客户端临时公钥、服务器临时私钥。随即服务器回复<strong>READY命令</strong>，表示握手成功。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">ready = %d5 <span class="hljs-string">&quot;READY&quot;</span> ready-nonce ready-box <br>ready-nonce = <span class="hljs-number">8</span>OCTET ; Short nonce, prefixed by <span class="hljs-string">&quot;CurveZMQREADY---&quot;</span> <br>ready-box = <span class="hljs-number">16</span>*OCTET ; Box [metadata](S<span class="hljs-string">&#x27;-&gt;C&#x27;</span>) <br></code></pre></td></tr></table></figure></li><li><p>至此，通过安全的方式，双方各自拥有了自己的临时私钥、对方的临时公钥。利用 Curve25519 椭圆曲线算法的特性，双方可以独立地计算出相同的<strong>共享密钥</strong> (Shared Secret)，该密钥将作为本次会话的<strong>会话密钥</strong> (Session Key)。</p></li></ol><p><img src="/../../img/deepseek_mermaid_20250910_b6c48f.png"></p><h3 id="4-加密消息传输阶段"><a href="#4-加密消息传输阶段" class="headerlink" title="4. 加密消息传输阶段"></a>4. 加密消息传输阶段</h3><p>  ZeroMQ 底层使用之前协商出的会话密钥、随机数和 Poly1305 认证加密算法对消息进行加密和认证。消息负载Payload使用发送方临时私钥+接收方临时公钥，和一个在报文中发送的随机数，来进行加密（Curve25519算法）。接收方使用发送方临时公钥+接收方临时私钥，和从报文中读取的随机数nonce，进行解密，得到消息负载Payload。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C">; MESSAGE command, <span class="hljs-number">33</span>+ octets <br>message = %d7 <span class="hljs-string">&quot;MESSAGE&quot;</span> message_nonce message-box <br>message-nonce = <span class="hljs-number">8</span>OCTET ; Short nonce, prefixed by <span class="hljs-string">&quot;CurveZMQMESSAGE-&quot;</span> <br>message-box = <span class="hljs-number">17</span>*OCTET ; Box [payload](S<span class="hljs-string">&#x27;-&gt;C&#x27;</span>) or (C<span class="hljs-string">&#x27;-&gt;S&#x27;</span>) <br>; This is the text sent encrypted in the box <br>payload = payload-flags payload-data <br>payload-flags = OCTET ; Explained below <br>payload-data = *octet ; <span class="hljs-number">0</span> or more octets <br></code></pre></td></tr></table></figure><h2 id="大模型对于CurveZMQ的介绍"><a href="#大模型对于CurveZMQ的介绍" class="headerlink" title="大模型对于CurveZMQ的介绍"></a>大模型对于CurveZMQ的介绍</h2><p>下面提供两份Deepseek对于CurveZMQ的介绍，结合阅读有助于理解：</p><h4 id="文件1："><a href="#文件1：" class="headerlink" title="文件1："></a>文件1：</h4><div class="row">    <embed src="/pdf/基于CurveZMQ的加密通信方案设计-DeepSeek.pdf" width="100%" height="550" type="application/pdf"></div><h4 id="文件2："><a href="#文件2：" class="headerlink" title="文件2："></a>文件2：</h4><div class="row">    <embed src="/pdf/CurveZMQ密钥生成与安全通信详解-DeepSeek.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ZMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学术论文分享 - Hierarchical Reinforcement Learning-based Mobility-aware Content Caching and Delivery Policy for Vehicle Networks</title>
    <link href="/posts/3fb7.html"/>
    <url>/posts/3fb7.html</url>
    
    <content type="html"><![CDATA[<p>在此分享个人在2022年ICA3PP（International Conference on Algorithms and Architectures for Parallel Processing）会议发表的一篇论文。😏</p><p><strong>欢迎引用</strong>：以下为bib格式：🫡</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs routeros">@InProceedings&#123;10.1007/978-3-031-22677-9_3,<br><span class="hljs-attribute">author</span>=<span class="hljs-string">&quot;Zhang, Le</span><br><span class="hljs-string">and Lai, Yongxuan</span><br><span class="hljs-string">and Yang, Fan&quot;</span>,<br><span class="hljs-attribute">editor</span>=<span class="hljs-string">&quot;Meng, Weizhi</span><br><span class="hljs-string">and Lu, Rongxing</span><br><span class="hljs-string">and Min, Geyong</span><br><span class="hljs-string">and Vaidya, Jaideep&quot;</span>,<br><span class="hljs-attribute">title</span>=<span class="hljs-string">&quot;Hierarchical Reinforcement Learning-Based Mobility-Aware Content Caching and Delivery Policy for Vehicle Networks&quot;</span>,<br><span class="hljs-attribute">booktitle</span>=<span class="hljs-string">&quot;Algorithms and Architectures for Parallel Processing&quot;</span>,<br><span class="hljs-attribute">year</span>=<span class="hljs-string">&quot;2023&quot;</span>,<br><span class="hljs-attribute">publisher</span>=<span class="hljs-string">&quot;Springer Nature Switzerland&quot;</span>,<br><span class="hljs-attribute">address</span>=<span class="hljs-string">&quot;Cham&quot;</span>,<br><span class="hljs-attribute">pages</span>=<span class="hljs-string">&quot;43--62&quot;</span>,<br><span class="hljs-attribute">isbn</span>=<span class="hljs-string">&quot;978-3-031-22677-9&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关键词</strong>：mobile edge computing ·vehicle network ·content caching and delivery ·hierarchical reinforcement learning ·deep deterministic policy gradient</p><p><strong>论文发表链接</strong>：<a href="https://link.springer.com/chapter/10.1007/978-3-031-22677-9_3">click here</a></p><div class="row">    <embed src="/pdf/HDRLCaching-论文全文.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>边缘计算</tag>
      
      <tag>车联网</tag>
      
      <tag>强化学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题总结</title>
    <link href="/posts/d4a8.html"/>
    <url>/posts/d4a8.html</url>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组理论基础"><a href="#数组理论基础" class="headerlink" title="数组理论基础"></a>数组理论基础</h3><p>数组是存放在<strong>连续内存空间</strong>上的<strong>相同类型数据</strong>的集合。在删除或者增添元素的时候，就难免要<strong>移动其他元素</strong>的地址。在C++中二维数组在地址空间上是连续的。<br>复习时记得回看C++数组以及<a href="http://c.biancheng.net/view/6749.html">vector的相关函数</a>。</p><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>在<strong>有序数组中查找元素</strong>，并且<strong>没有重复元素</strong>。使用left、right两个指针。需要清楚区间的定义，是左闭右闭还是左闭右开（建议左闭右闭）。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则。时间复杂度为O(logn)</p><blockquote><ol start="704"><li><a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html">二分查找</a></li></ol></blockquote><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>（快慢指针法）：通过<strong>两个指针</strong>在一个for循环下完成两个for循环的工作，来降低时间复杂度。要搞清楚每个指针在什么条件下移动，什么条件下不移动。</p><blockquote><ol start="27"><li>移除元素，977.有序数组的平方，844.有序数组的平方</li></ol></blockquote><h3 id="滑动窗口法"><a href="#滑动窗口法" class="headerlink" title="滑动窗口法"></a>滑动窗口法</h3><p>也属于双指针法，所谓滑动窗口，就是不断的调节<strong>子序列</strong>的起始位置和终止位置，从而得出我们要想的结果。首先想起始位置和终止位置移动会<strong>分别带来什么影响</strong>，然后要确定<strong>窗口内是什么</strong>，<strong>窗口的起始位置的移动规则</strong>，<strong>窗口的结束位置的移动规则</strong>。</p><blockquote><p>209.长度最小的子数组，<a href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮</a>，<a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> s, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> result = INT32_MAX;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口数值之和</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口起始位置</span><br>    <span class="hljs-type">int</span> subLength = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口的长度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) &#123;<br>        sum += nums[j];<br>        <span class="hljs-comment">// 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件</span><br>        <span class="hljs-keyword">while</span> (sum &gt;= s) &#123;<br>            subLength = (j - i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 取子序列的长度</span><br>            result = result &lt; subLength ? result : subLength;<br>            sum -= nums[i];<br>            i++;<br>            <span class="hljs-comment">// 起始位置的移动规则：sum&gt;=s，需要缩小滑动窗口之和，寻找是否存在j结尾的长度更小的子数组</span><br>        &#125;<br>        <span class="hljs-comment">// 结束位置的移动规则：sum&lt;s，需要增大滑动窗口之和，j后移  (while循环结束后sum就会小于s)</span><br>    &#125;<br>    <span class="hljs-comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span><br>    <span class="hljs-keyword">return</span> result == INT32_MAX ? <span class="hljs-number">0</span> : result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="模拟行为"><a href="#模拟行为" class="headerlink" title="模拟行为"></a>模拟行为</h3><p><strong>循环不变量</strong>原则，是写程序中的重要原则。确定模拟过程中遵循的规则。</p><blockquote><p>59.螺旋矩阵II，54.螺旋矩阵</p></blockquote><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="链表理论基础"><a href="#链表理论基础" class="headerlink" title="链表理论基础"></a>链表理论基础</h3><p>链表的节点在内存中是分散存储的，每一个节点由两部分组成，一个是<strong>数据域</strong>一个是<strong>指针域</strong>（存放指向下一个节点的指针），最后一个节点的指针域指向null。<strong>双链表</strong>：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。<strong>循环链表</strong>，顾名思义，就是链表首尾相连。<br>链表的操作：</p><ul><li><strong>删除节点</strong>：定位到删除节点的前一个节点，保存-&gt;next为tmp，将-&gt;next域设为-&gt;next-&gt;next，delete tmp。</li><li><strong>添加节点</strong>：定位到添加位置的前一个位置p，new一个新节点，next域设为p-&gt;next，p-&gt;next设为新节点地址。</li></ul><p>技巧：多<strong>画图模拟</strong>过程，考虑<strong>极端情况</strong>，包括：链表长为0，长为1，头结点位置，尾结点位置等</p><h3 id="虚节点-哨兵节点"><a href="#虚节点-哨兵节点" class="headerlink" title="虚节点&#x2F;哨兵节点"></a>虚节点&#x2F;哨兵节点</h3><p>使用一个头结点之前虚节点（dummyNode）可以有效简化删除&#x2F;添加节点时需要考虑头部位置的情况。</p><blockquote><p>203.移除链表元素，<strong>707</strong>.设计链表</p></blockquote><h3 id="双指针法-1"><a href="#双指针法-1" class="headerlink" title="双指针法"></a>双指针法</h3><p>常见的方式有prev与cur两个相差一步的指针（206、24）、slow与fast两个相差若干步的指针（19、面试02.07）、slow每次走一步fast每次走两步（142）</p><blockquote><p>206.反转链表、24.两两交换链表中的节点</p><p>19.删除链表的倒数第N个节点、面试题 02.07. 链表相交</p><p>142.环形链表II</p></blockquote><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><p>一般来说哈希表都是用来<strong>快速判断一个元素是否出现集合里</strong>。对于哈希表，要知道<strong>哈希函数</strong>和<strong>哈希碰撞</strong>在哈希表中的作用。哈希函数是把传入的key映射到哈希表的索引上。哈希碰撞处理有多个key映射到相同索引上时的情景，处理碰撞的普遍方式是拉链法和线性探测法。</p><p>接下来是常见的三种哈希结构：</p><ul><li>数组</li><li>set（集合）</li><li>map（映射）</li></ul><p>集合set是一组同类型数据的集合，unordered_set类似于python中的set。映射map是一组（key，value）键值对（pair类型）的集合，unordered_map类似于python的dict、java的hashmap。在C++中，set 和 map 分别提供以下三种数据结构：</p><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值能否重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>键值能否重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>以上六种常用的是unordered_set，unordered_map。具体接口可查询：<a href="http://c.biancheng.net/view/7250.html">unordered_set</a>、<a href="http://c.biancheng.net/view/7231.html">unordered_map</a></p><h3 id="数组作为哈希表"><a href="#数组作为哈希表" class="headerlink" title="数组作为哈希表"></a>数组作为哈希表</h3><p>数组本身也是一种哈希表或者说map。在一些涉及到字母等的题目中，哈希表元素个数有限（如26个字母），就可以用数组作为简便的哈希表，使用map的空间消耗要比数组大一些，因为map要维护红黑树或者符号表，而且还要做哈希函数的运算，所以数组更加简单直接有效。</p><blockquote><p>242.有效的字母异位词、383. 赎金信</p></blockquote><h3 id="set作为哈希表"><a href="#set作为哈希表" class="headerlink" title="set作为哈希表"></a>set作为哈希表</h3><p>在一些需要以较低的时间复杂度判断元素是否在一个集合中，或者是否重复出现过，就可以用unordered_set做容器。</p><blockquote><ol start="349"><li>两个数组的交集、202. 快乐数</li></ol></blockquote><h3 id="map作为哈希表"><a href="#map作为哈希表" class="headerlink" title="map作为哈希表"></a>map作为哈希表</h3><p>map是一种&lt;key, value&gt;的结构，在一些合适的题中很有用，如两数之和（1）、四数相加（454）。但一些题中哈希法太过复杂，反而适合用双指针法，如<strong>三数之和（15）、四数之和（18）</strong>，这两题值得重点关注。</p><blockquote><ol><li>两数之和、454.四数相加II</li></ol></blockquote><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>C++字符串：<a href="http://c.biancheng.net/view/2236.html">库函数</a></p><h3 id="双指针法-2"><a href="#双指针法-2" class="headerlink" title="双指针法"></a>双指针法</h3><p>一快一慢两个指针或者一头一尾。<br>很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</p><blockquote><p>344.反转字符串、剑指Offer 05.替换空格、151.翻转字符串里的单词</p></blockquote><h3 id="反转系列"><a href="#反转系列" class="headerlink" title="反转系列"></a>反转系列</h3><p>基本的字符串反转使用一前一后两个指针，时间复杂度是O(n)。一些题目用到了先整体反转再局部反转（151）和先局部反转再整体反转（剑指Offer58-II.左旋转字符串）的技巧。</p><blockquote><p>151.翻转字符串里的单词、剑指Offer58-II.左旋转字符串</p></blockquote><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>KMP算法用于在O(n+m)的时间复杂度内在文本串中匹配模式串。核心思想是当字符串不匹配时，利用已经匹配过的失败信息，跳过一些不可能的字符串匹配。需要掌握的要点是：</p><ul><li>前缀表&#x2F;next数组：作用是记录了模式串与文本串不匹配的时候，模式串应该从哪里开始重新匹配。<strong>next[i]的含义</strong>是在模式串中，下标 i 之前（包括i）的子串中，最长的相同前缀、后缀的长度</li><li>KMP有两种实现方法，包括next数组与前缀表相同、前缀表统一每位减一，两者等价，下面介绍相同的情况</li><li>参考辅助理解KMP：<a href="https://www.zhihu.com/question/21923021">理解KMP</a></li><li>KMP可以解决两种经典问题：模式串匹配问题（28. 实现 strStr()）、重复子串问题（459.重复的子字符串）</li><li>KMP包含两部分：快速建立前缀表和利用前缀表进行匹配。</li></ul><h4 id="快速建立前缀表："><a href="#快速建立前缀表：" class="headerlink" title="快速建立前缀表："></a>快速建立前缀表：</h4><p>思路：采用<strong>递推</strong>的方式求next数组。假设next[ 0~ i-1 ]已知的情况下，求next[ i ]的值。</p><ol><li>初始化：j指向前缀末尾位置，i指向后缀末尾位置，j&#x3D;0；</li><li>处理前后缀不相同的情况，j不断根据next[j-1]回退，直至s[i]&#x3D;s[j]或者j&#x3D;0；</li><li>处理前后缀相同的情况，s[i]&#x3D;s[j]，前后缀就可以扩展一位，j++，再赋给next[i]；</li><li>j 赋值给next[i]</li></ol><h4 id="利用前缀表进行匹配："><a href="#利用前缀表进行匹配：" class="headerlink" title="利用前缀表进行匹配："></a>利用前缀表进行匹配：</h4><ol><li>定义两个下标j 指向模式串起始位置，i指向文本串起始位置</li><li>for循环中i从0开始遍历文本串，如果在j位置匹配失败，j根据前缀表next[j-1]不断回溯，直至匹配成功</li><li>如果匹配成功，i、j后移一位（j+1，i在for循环中+1）</li><li>j移动到超出模式串的末尾，表示模式串匹配成功，返回i-模式串长度+1</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span></span>&#123;  <span class="hljs-comment">//next数组与前缀表相同，不减一的做法</span><br>        <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;  <span class="hljs-comment">// 1、初始化：j指向前缀末尾位置，i指向后缀末尾位置</span><br>        next[<span class="hljs-number">0</span>]=j;  <span class="hljs-comment">// next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;s.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-comment">// 每次循环开始时，j的值就是next[i-1]</span><br>            <span class="hljs-keyword">while</span> (j&gt;<span class="hljs-number">0</span> &amp;&amp; s[i]!=s[j])&#123;  <span class="hljs-comment">// 2、处理前后缀不相同的情况，j不断根据next[j-1]回退，直至s[i]=s[j]或者j=0</span><br>                j=next[j<span class="hljs-number">-1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (s[i]==s[j])&#123;  <span class="hljs-comment">// 3、处理前后缀相同的情况，s[i]=s[j]，前后缀就可以扩展一位，j++（即next[i-1]+1），再赋给next[i]</span><br>                j++;<br>            &#125;<br>            next[i]=j;  <span class="hljs-comment">// 4、更新next[i]</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (needle.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">// 处理特殊情况：模式串长度为0</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> next[needle.<span class="hljs-built_in">size</span>()];<br>        <span class="hljs-built_in">getNext</span>(next, needle);  <span class="hljs-comment">// 获得next数组，next[i]含义是下标i之前（包括i）的子串中，最长的相同前缀后缀的长度</span><br>        <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;haystack.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">while</span> (j&gt;<span class="hljs-number">0</span> &amp;&amp; haystack[i]!=needle[j])&#123;<br>                j=next[j<span class="hljs-number">-1</span>];  <span class="hljs-comment">// 如果在j位置匹配失败，j根据前缀表next[j-1]不断回溯，直至匹配成功</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (haystack[i]==needle[j])&#123;<br>                j++;  <span class="hljs-comment">// 匹配成功，j前移一位</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (j==needle.<span class="hljs-built_in">size</span>())&#123;<br>                <span class="hljs-keyword">return</span> i-needle.<span class="hljs-built_in">size</span>()<span class="hljs-number">+1</span>;  <span class="hljs-comment">// j移动到超出模式串的末尾，表示模式串匹配成功，返回i-模式串长度+1</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="双指针法-3"><a href="#双指针法-3" class="headerlink" title="双指针法"></a>双指针法</h2><p>双指针法广泛应用于<strong>数组、链表、字符串</strong>的题目中。</p><h3 id="fast-slow"><a href="#fast-slow" class="headerlink" title="fast &amp; slow"></a>fast &amp; slow</h3><p>定义一快一慢两个指针，有以下几种思路：</p><ul><li><p>fast和slow两个指针根据一些条件移动，复制元素，来模拟数组元素的移动</p><blockquote><ol start="27"><li>移除元素、剑指Offer 05.替换空格、151.翻转字符串里的单词</li></ol></blockquote></li><li><p>扩充数组至所需大小后，fast&amp;slow指针从后向前移动</p><blockquote><p>剑指Offer 05.替换空格</p></blockquote></li><li><p>fast指针先走几步，fast与slow相差n步，然后两个指针再同步移动</p><blockquote><p>19.删除链表的倒数第N个节点、面试题 02.07. 链表相交</p></blockquote></li><li><p>fast每次走两步，slow每次走一步，两者在环中相遇</p><blockquote><p>142.环形链表II</p></blockquote></li></ul><h3 id="left-right"><a href="#left-right" class="headerlink" title="left &amp; right"></a>left &amp; right</h3><p>定义一头一尾两个指针，向中间移动</p><blockquote><p>344.反转字符串、15.三数之和、18.四数之和</p></blockquote><h3 id="pre-cur链表类"><a href="#pre-cur链表类" class="headerlink" title="pre &amp; cur链表类"></a>pre &amp; cur链表类</h3><p>在链表中常定义pre &amp; cur两个指针，来进行链表next的修改</p><blockquote><p>206.反转链表、24.两两交换链表中的节点</p></blockquote><h3 id="反转类"><a href="#反转类" class="headerlink" title="反转类"></a>反转类</h3><p>字符串的反转，不仅可能用到fast &amp; slow，也可能用到先整体反转再局部反转，或先局部反转再整体反转的方法。</p><blockquote><p>344.反转字符串、151.翻转字符串里的单词、剑指Offer58-II.左旋转字符串</p></blockquote><h3 id="N数之和"><a href="#N数之和" class="headerlink" title="N数之和"></a>N数之和</h3><p>先将数组排序，遍历前N-2个数，最后两个数设置left &amp; right两个指针向中间移动，若和小了left向右，和大了right向左。</p><blockquote><p><strong>15.三数之和、18.四数之和</strong></p></blockquote><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>栈是<strong>先进后出</strong>的数据结构，队列是<strong>先进先出</strong>的数据结构。</p><p>stack、queue、priority_queue在STL中属于容器适配器，包装了STL中的基础容器类，本质上还是容器。stack、queue使用的默认基础容器是deque，priority_queue使用的默认基础容器是vector。可以自定义底层容器。</p><p>栈和队列不允许有遍历行为，不提供迭代器。</p><p><strong>优先级队列</strong>与队列相似，只能一端进一端出，但只能访问队头的元素。当元素进入队列后，会进行排序，保证队列按照预定义的优先级排列，默认使用std::less<T>进行从大到小排列。底层采用<strong>vector形式的大顶堆&#x2F;小顶堆</strong>。</p><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 不包含任何元素的 stack 适配器，并采用默认的 deque 基础容器</span><br>stack&lt;<span class="hljs-type">int</span>&gt; values;<br><span class="hljs-comment">// 使用list为基础容器的stack</span><br>stack&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; values;<br><span class="hljs-comment">// 用一个基础容器来初始化 stack 适配器，只要该容器的类型和 stack 底层使用的基础容器类型相同即可</span><br>list&lt;<span class="hljs-type">int</span>&gt; values&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>stack&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">my_stack</span>(values);<br><span class="hljs-comment">// 用一个 stack 适配器来初始化另一个 stack 适配器，只要它们存储的元素类型以及底层采用的基础容器类型相同即可</span><br>stack&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; my_stack=my_stack1;<br><span class="hljs-comment">//stack&lt;int, list&lt;int&gt;&gt; my_stack(my_stack1);</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>empty()</td><td>当 stack 栈中没有元素时，该成员函数返回 true；反之，返回 false。</td></tr><tr><td>size()</td><td>返回 stack 栈中存储元素的个数。</td></tr><tr><td>top()</td><td>返回一个栈顶元素的引用，类型为 T&amp;。如果栈为空，程序会报错。</td></tr><tr><td>push(const T&amp; val)</td><td>先复制 val，再将 val 副本压入栈顶。这是通过调用底层容器的 push_back() 函数完成的。</td></tr><tr><td>pop()</td><td>弹出栈顶元素。</td></tr></tbody></table><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 不包含任何元素的 queue 适配器，并采用默认的 deque 基础容器</span><br>queue&lt;<span class="hljs-type">int</span>&gt; values;<br><span class="hljs-comment">// 使用list为基础容器的queue</span><br>queue&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; values;<br><span class="hljs-comment">// 用一个基础容器来初始化 queue 适配器，只要该容器的类型和 queue 底层使用的基础容器类型相同即可</span><br>list&lt;<span class="hljs-type">int</span>&gt; values&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>queue&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">my_queue</span>(values);<br><span class="hljs-comment">// 用一个 queue 适配器来初始化另一个 queue 适配器，只要它们存储的元素类型以及底层采用的基础容器类型相同即可</span><br>queue&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; my_queue=my_queue1;<br><span class="hljs-comment">//queue&lt;int, list&lt;int&gt;&gt; my_queue(my_queue1);</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>empty()</td><td>如果 queue 中没有元素的话，返回 true。</td></tr><tr><td>size()</td><td>返回 queue 中元素的个数。</td></tr><tr><td>front()</td><td>返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</td></tr><tr><td>back()</td><td>返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</td></tr><tr><td>push(const T&amp; obj)</td><td>在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。</td></tr><tr><td>pop()</td><td>删除 queue 中的第一个元素。</td></tr></tbody></table><h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 空的 priority_queue 容器，底层默认 vector 容器，排序方式默认 std::less&lt;T&gt; 方法，即大顶堆</span><br>priority_queue&lt;<span class="hljs-type">int</span>&gt; values;<br><span class="hljs-comment">//使用普通数组初始化</span><br><span class="hljs-type">int</span> values[]&#123;<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>&#125;;<br><span class="hljs-function">priority_queue&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">copy_values</span><span class="hljs-params">(values,values<span class="hljs-number">+4</span>)</span></span>; <span class="hljs-comment">//&#123;4,2,3,1&#125;</span><br><span class="hljs-comment">//使用序列式容器初始化</span><br>array&lt;<span class="hljs-type">int</span>, 4&gt;values&#123; <span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span> &#125;;<br><span class="hljs-function">priority_queue&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">copy_values</span><span class="hljs-params">(values.begin(),values.end())</span></span>;<span class="hljs-comment">//&#123;4,2,3,1&#125;</span><br><span class="hljs-comment">// 手动指定 priority_queue 使用的底层容器以及排序规则</span><br><span class="hljs-type">int</span> values[]&#123; <span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span> &#125;;<br>priority_queue&lt;<span class="hljs-type">int</span>, deque&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">copy_values</span>(values, values<span class="hljs-number">+4</span>); <span class="hljs-comment">// 小顶堆</span><br><span class="hljs-comment">// 用函数对象类自定义排序规则</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cmp</span> &#123;  <span class="hljs-comment">// 函数对象类</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; left, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; right)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> left.second &gt; right.second;  <span class="hljs-comment">// 小顶堆，从小到大排序</span><br>    &#125;<br>&#125;;<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, Cmp&gt; pri_que;<br></code></pre></td></tr></table></figure><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>empty()</td><td>如果 priority_queue 为空的话，返回 true；反之，返回 false。</td></tr><tr><td>size()</td><td>返回 priority_queue 中存储元素的个数。</td></tr><tr><td>top()</td><td>返回 priority_queue 中第一个元素的引用形式。</td></tr><tr><td>push(const T&amp; obj)</td><td>根据既定的排序规则，将元素 obj 的副本存储到 priority_queue 中适当的位置。</td></tr><tr><td>pop()</td><td>移除 priority_queue 容器适配器中第一个元素。</td></tr></tbody></table><h3 id="栈经典题目"><a href="#栈经典题目" class="headerlink" title="栈经典题目"></a>栈经典题目</h3><p>栈在计算机系统、编译器中应用广泛，如：</p><blockquote><ol start="20"><li>有效的括号、71. 简化路径、1047. 删除字符串中的所有相邻重复项、150. 逆波兰表达式求值</li></ol></blockquote><h3 id="队列经典题目"><a href="#队列经典题目" class="headerlink" title="队列经典题目"></a>队列经典题目</h3><ul><li><p><strong>单调队列</strong></p><p>在  239. 滑动窗口最大值  中，需要这样一种队列：队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队里里的元素数值是由大到小的。这就是<strong>单调队列</strong>，即单调递减或单调递增的队列。设计单调队列的时候，pop和push操作要保持如下规则：</p><p>pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作<br>push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止。</p><blockquote><ol start="239"><li>滑动窗口最大值</li></ol></blockquote></li><li><p><strong>优先级队列</strong></p><p>优先级队列就是一个披着队列外衣的堆，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。是大顶堆&#x2F;小顶堆的现成的实现。</p><blockquote><p>347.前 K 个高频元素</p></blockquote></li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="理论基础-1"><a href="#理论基础-1" class="headerlink" title="理论基础"></a>理论基础</h3><ul><li><p><strong>满二叉树</strong>：一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，深度为k，有2^k-1个节点</p><img src="https://img-blog.csdnimg.cn/20200806185805576.png" alt="img" style="zoom:25%;" /></li><li><p><strong>完全二叉树</strong>：除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置</p><img src="https://img-blog.csdnimg.cn/20200920221638903.png" alt="img" style="zoom: 33%;" /></li><li><p><strong>二叉搜索树</strong>是一个有序树，</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul></li></ul><img src="https://img-blog.csdnimg.cn/20200806190304693.png" alt="img" style="zoom: 50%;" /><ul><li><p><strong>平衡二叉搜索树</strong>：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><img src="https://img-blog.csdnimg.cn/20200806190511967.png" alt="img" style="zoom:50%;" /><p>红黑树也是一种平衡二叉树，性能优于平衡二叉树。C++中map、set、multimap，multiset的底层实现都是红黑树。</p></li><li><p><strong>存储方式</strong>：二叉树可以链式存储，也可以顺序存储。顺序存储就是用数组来存储二叉树，如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。链式存储则是通过指针把分布在散落在各个地址的节点串联一起。</p></li><li><p><strong>遍历方式</strong>：</p><ul><li>深度优先遍历（DFS）<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历（BFS）<ul><li>层次遍历（迭代法）</li></ul></li></ul></li></ul><p>其中深度优先的迭代法是用栈的数据结构实现，层次遍历的迭代法是用队列的数据结构实现。</p><h3 id="递归遍历（DFS）"><a href="#递归遍历（DFS）" class="headerlink" title="递归遍历（DFS）"></a>递归遍历（DFS）</h3><p>写递归算法的三要素：</p><ul><li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 前序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右   // 前序遍历，中序和后序修改三句话顺序即可</span><br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-built_in">traversal</span>(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="迭代遍历（DFS）"><a href="#迭代遍历（DFS）" class="headerlink" title="迭代遍历（DFS）"></a>迭代遍历（DFS）</h3><p>使用<strong>栈的结构</strong>来模拟递归的过程，时间复杂度与递归相同，但空间更小。有两种实现方式，第一种实现三种遍历不一致，不好记；第二种实现加入空指针作为待处理的标记，三种遍历写法统一，更好记。记住一种即可。</p><p>注意由于栈的“先进后出”，编写代码时顺序要与前序的“中左右”相反，中&#x2F;后序同理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 前序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root!=<span class="hljs-literal">nullptr</span>) st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>())&#123;<br>            TreeNode* node=st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node!=<span class="hljs-literal">nullptr</span>)&#123;  <span class="hljs-comment">// 非空指针，表示该节点需要访问但不处理</span><br>                st.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 弹出该节点，接下来访问子节点，但不处理（将该节点加入result）该节点</span><br>                <span class="hljs-keyword">if</span> (node-&gt;right!=<span class="hljs-literal">nullptr</span>) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 右</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left!=<span class="hljs-literal">nullptr</span>) st.<span class="hljs-built_in">push</span>(node-&gt;left);  <span class="hljs-comment">// 左，注意这里是用栈的结构，顺序与前序遍历的“中左右”相反，应为“右左中”</span><br>                st.<span class="hljs-built_in">push</span>(node);  <span class="hljs-comment">// 中，  再次将该节点压入栈中</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">nullptr</span>);  <span class="hljs-comment">// 并加上一个空指针表示待处理</span><br>                <span class="hljs-comment">// 中序和后序修改上面四句话的顺序</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 遇到空指针，表示栈中的下一个节点是待处理的</span><br>                st.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 先弹出空指针</span><br>                node=st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(node-&gt;val);  <span class="hljs-comment">// 处理该节点，加入result</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="层序遍历（BFS）"><a href="#层序遍历（BFS）" class="headerlink" title="层序遍历（BFS）"></a>层序遍历（BFS）</h3><p>从左到右一层一层的去遍历二叉树，借助“先进先出”的<strong>队列的数据结构</strong>实现迭代式的写法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>            <span class="hljs-comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size()是不断变化的</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;  <span class="hljs-comment">// 当不需要输出二维的vector时可以省去size变量和for循环</span><br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                vec.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            result.<span class="hljs-built_in">push_back</span>(vec);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><p>二叉树类的题目通常有两种思路：<strong>递归法</strong>和<strong>迭代法</strong>。</p><ul><li>对于递归法，首先要搞清楚递归函数所要实现的功能是什么，然后按照递归算法的三要素来思考。这类做法通常是使用前&#x2F;中&#x2F;后序遍历三者之一</li><li>对于迭代法，通常是采用队列的数据结构，并采用层序遍历的方式（也有例外，如101. 对称二叉树使用迭代法，但不是层序遍历），要记住层序遍历的模板</li></ul><blockquote><p>226.翻转二叉树、101. 对称二叉树、104.二叉树的最大深度、111.二叉树的最小深度、222.完全二叉树的节点个数、110.平衡二叉树</p></blockquote><p>二叉树的题目可分为以下几种类型：</p><ul><li>求普通二叉树的属性：一般用后序，因为需要用到左右子树的属性来计算本节点的属性，但有例外</li><li>二叉树的修改与构造：使用前序，因为需要先构造中节点</li><li>求二叉搜索树的属性：使用中序</li></ul><p>题目归类：<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87.html">二叉树总结篇</a></p><p>未看的文章：23~33</p><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h3 id="理论基础-2"><a href="#理论基础-2" class="headerlink" title="理论基础"></a>理论基础</h3><p><strong>回溯是递归的副产品，只要有递归就会有回溯</strong>，所以回溯法也经常和二叉树遍历，深度优先搜索混在一起，因为这两种方式都是用了递归。回溯法就是暴力搜索，并不是什么高效的算法，最多再剪枝一下。</p><p><strong>回溯法解决的问题都可以抽象为树形结构</strong>。因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度就构成了树的深度</strong>。递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</p><p><strong><u>回溯法的模板：</u></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>回溯算法能解决如下问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>棋盘问题：N皇后，解数独等等</li></ul><h3 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h3><p><strong>剪枝技巧：</strong></p><ul><li>for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够题目要求的k个元素了，就没有必要搜索了（77.组合）</li><li>已选元素总和如果已经大于n（题中要求的和）了，那么往后遍历就没有意义了，直接剪掉（216.组合总和III）</li><li>其他剪枝技巧需要具体问题具体分析</li></ul><p>组合问题通常需要<strong>startIndex</strong>来控制for循环的起始位置，如果是一个集合来求组合的话，就需要startIndex；如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，如：17.电话号码的字母组合。</p><p><strong>去重问题</strong>：集合元素会有重复，但要求解集不能包含重复的组合。需要理解“同一树枝上重复”与“同一树层上重复”，具体看：40.组合总和II。</p><blockquote><p>77.组合、216.组合总和III、17.电话号码的字母组合、39. 组合总和、<strong>40.组合总和II</strong>、<strong>332.重新安排行程</strong></p></blockquote><h3 id="切割问题"><a href="#切割问题" class="headerlink" title="切割问题"></a>切割问题</h3><p>类似于组合问题，需要了解string的基本操作。</p><blockquote><p>131.分割回文串、93.复原IP地址</p></blockquote><h3 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h3><p>在树形结构中子集问题是要收集所有节点的结果，而组合问题是收集叶子节点的结果。</p><blockquote><p>78.子集</p></blockquote><h3 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h3><p>每层都是从0开始搜索而不是startIndex；需要used数组记录path里都放了哪些元素了。</p><blockquote><p>46.全排列</p></blockquote><h3 id="棋盘问题"><a href="#棋盘问题" class="headerlink" title="棋盘问题"></a>棋盘问题</h3><p>一些只需要找到一个解的问题（如：37. 解数独、332.重新安排行程），可以将回溯函数的<strong>返回值设为bool</strong>，当找到解直接用true返回所有递归，代码见<a href="https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html#%E5%9B%9E%E6%BA%AF%E6%B3%95">链接</a></p><blockquote><p>51.N皇后、37.解数独</p></blockquote><h3 id="时间-空间复杂度分析"><a href="#时间-空间复杂度分析" class="headerlink" title="时间&#x2F;空间复杂度分析"></a>时间&#x2F;空间复杂度分析</h3><p><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90">链接</a></p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211030124742.png" style="zoom: 80%;" /><p>未看的文章：13、14、16、19</p><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h3 id="理论基础-3"><a href="#理论基础-3" class="headerlink" title="理论基础"></a>理论基础</h3><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。贪心的问题通常是<strong>求一个最值</strong>，贪心问题没有一个固定套路，只能靠自己<strong>手动模拟</strong>，如果模拟中用了局部最优推出全局最优的思想，且<strong>找不出反例</strong>，就可以试一试贪心策略，如果不可行，可能需要动态规划。不需要精确的数学推导。</p><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><ul><li><p>有些题目数组是无序的，混乱中并不能产生最值，且题目与元素之间的相对位置无关，此时通常需要<strong>先对数组进行排序</strong>。需要看一下sort函数自定义排序规则的方式（见452. 用最少数量的箭引爆气球）。</p><p>但一些题目关乎相邻元素的关系、求连续子数组，就不能改变元素位置（如376. 摆动序列、 53. 最大子序和）。</p><blockquote><p>455.分发饼干、1005.K次取反后最大化的数组和、<strong>406.根据身高重建队列</strong>、452. 用最少数量的箭引爆气球</p></blockquote></li></ul><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="理论基础-4"><a href="#理论基础-4" class="headerlink" title="理论基础"></a>理论基础</h3><p>动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多<strong>重叠子问题</strong>，使用动态规划是最有效的。所以动态规划中<strong>每一个状态一定是由上一个状态推导出来的</strong>，这一点就区分于贪心，贪心没有状态推导，而是<strong>从局部直接选最优</strong>的。</p><p><strong>对于动态规划问题，拆解为如下五步曲：</strong></p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式（由以往的状态推导出当前的状态，即dp[i-1]或dp[i-2]等推出dp[i]。一般要分情况讨论）</li><li>dp数组如何初始化（结合递推公式确定初始化。有时初始化没有实际含义，仅仅是为了保证递推公式）</li><li>确定遍历顺序（for循环顺序，根据递推公式确定，看dp[i]依赖什么）</li><li>举例推导dp数组</li></ol><p><strong>做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果。写出代码后，如果出问题，把dp数组打印出来，看看究竟是不是按照自己思路推导的。</strong></p><blockquote><ol start="509"><li>斐波那契数、70. 爬楼梯、746. 使用最小花费爬楼梯、62.不同路径、63. 不同路径 II、<strong>343. 整数拆分</strong>、96.不同的二叉搜索树</li></ol></blockquote><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解物品价值总和最大是多少。</p><ul><li>二维dp数组：</li></ul><p>dp数组的定义：<strong>dp[i] [j]表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p><p>递推公式：dp[i] [j] &#x3D; max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i])    分别对应不取物品i和取物品i的两种情况</p><p>初始化：背包容量j为0，即dp[i] [0]，初始化为0；存放编号0的物品，当 j &lt; weight[0]时dp[0] [j] 初始化为0，当j &gt;&#x3D; weight[0]时dp[0] [j] 初始化为 value[0]。</p><p>遍历顺序：先遍历物品再遍历背包容量，或者反过来都可以</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>一维dp数组：</li></ul><p>利用<strong>滚动数组压缩空间复杂度</strong>，每完整刷新一轮数组就是增加了一件物品。</p><p>dp数组的定义：容量为j的背包，所背的物品价值可以最大为dp[j]</p><p>递推公式：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i])</p><p>初始化：背包容量j为0，即dp[0]，初始化为0；其他dp[j]的值随意，但一般也初始化为0。</p><p>遍历顺序：<strong>先遍历物品并且内层倒序遍历背包容量</strong>，不能反过来。倒序是为了保证递推式中用的dp[j - weight[i]]是上一轮的值，即dp[ i - 1 ] [j - weight[i]]。否则每个物品就会多次抽取，就变成了完全背包。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="416"><li>分割等和子集、<strong>1049. 最后一块石头的重量 II</strong></li></ol></blockquote><p>以上两道道题类似，都是<strong>把一组数分成两组，使得两组和的差值最小</strong>。做法是对和较小的那一组做DP，转化为容积为sum&#x2F;2的背包，每个物品的体积和价值都是相同的。dp[sum&#x2F;2]表示从原数组中选择一部分数，在和不超过sum&#x2F;2的情况下，所能达到的最大和。由于已经限制了DP部分的和不超过sum&#x2F;2，所以没有被DP选中的数之和（sum - dp[sum&#x2F;2]）一定是比DP部分的和大的，那么两组和的最小差值就是sum - dp[sum&#x2F;2] - dp[sum&#x2F;2]，不需要加绝对值。</p><blockquote><ol start="494"><li>目标和、 <strong>474.一和零</strong></li></ol></blockquote><p>目标和也是一组数分为两组，但将问题转化为<strong>恰好装满背包容积</strong>，有多少种装法，初始化有所不同。一和零也是01背包，但背包的容积有两个维度，做法一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 目标和</span><br>dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;  <span class="hljs-comment">// 初始化：加和为0的取法只有一种，即什么数也不取</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=x; j&gt;=nums[i]; j--)&#123;<br>        dp[j] += dp[j-nums[i]];  <span class="hljs-comment">// 递推公式</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><p>由01背包问题延伸而来，<strong>物品数量是无限的</strong>。</p><p><strong>题目总结</strong>：</p><ul><li><p><strong>纯完全背包</strong>，求解物品价值的总和最大是多少：</p><p>与01背包问题的解法区别仅在于遍历顺序，需要将一维dp数组的遍历顺序改为 外层遍历物品并且<strong>内层正序</strong>遍历背包容量。也可以先遍历背包容量再遍历物品。<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85">链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>内层正序遍历背包容量的话，每次递推公式里的 dp[ j - weight[i]] 就已经是被覆盖的值了，即本轮的值 dp[ i ] [ j - weight[i]] ，就可以做到多次选取物品。</p><blockquote><p><a href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html#_322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2">322. 零钱兑换</a></p></blockquote></li><li><p><strong>组合数</strong>，每个物品数量无限，求恰好凑成给定价值的组合数有多少：必须<strong>外层for循环遍历物品，内层for遍历背包</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] += dp[j - coins[i]];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">518. 零钱兑换 II</a></p></blockquote></li><li><p><strong>排列数</strong>，每个物品数量无限，求恰好凑成给定价值的排列数有多少：必须<strong>外层for遍历背包，内层for循环遍历物品</strong>。<a href="https://leetcode.cn/problems/combination-sum-iv/solution/zu-he-zong-he-iv-by-leetcode-solution-q8zv/">理解看这里</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= amount; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">if</span> (j - coins[i] &gt;= <span class="hljs-number">0</span>) dp[j] += dp[j - coins[i]];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html#_377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-iv">377. 组合总和 Ⅳ</a>、<a href="https://programmercarl.com/0139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86.html#_139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86">139.单词拆分</a></p></blockquote></li></ul><h3 id="打家劫舍系列"><a href="#打家劫舍系列" class="headerlink" title="打家劫舍系列"></a>打家劫舍系列</h3><blockquote><p><a href="https://leetcode-cn.com/problems/house-robber/">198.打家劫舍</a></p></blockquote><p>简单的动规题，dp[i] 由 dp[i-1] 和 dp[i-2] 推出</p><blockquote><p><a href="https://leetcode-cn.com/problems/house-robber-ii/">213.打家劫舍II</a></p></blockquote><p>考虑头尾两间房子，分两种情况，分别调用一次198.打家劫舍</p><blockquote><p><a href="https://leetcode.cn/problems/house-robber-iii/">337.打家劫舍 III</a></p></blockquote><p><strong>树形DP</strong>，结合了<strong>动态规划</strong>与<strong>二叉树的后序遍历</strong>。递归函数的返回值是偷与不偷的两个状态所得到的金钱构成的dp数组，必须要<strong>后序遍历</strong>，因为通过递归函数的返回值来计算父节点的dp数组。<a href="https://programmercarl.com/0337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">代码见</a></p><h3 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h3><blockquote><p><a href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">121.买卖股票的最佳时机</a></p><p><a href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">122.买卖股票的最佳时机II</a></p><p><a href="https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html">123.买卖股票的最佳时机III</a></p><p><a href="https://programmercarl.com/0188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV.html">188.买卖股票的最佳时机IV</a></p><p><a href="https://programmercarl.com/0309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html">309.最佳买卖股票时机含冷冻期</a></p><p><a href="https://programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">714.买卖股票的最佳时机含手续费</a></p></blockquote><p>做法类似，将状态分为持有和不持有（限制买卖次数时多分几个状态），定义一个二维的dp数组，第一维表示天数，第二维表示状态，dp[i] [0] 表示第i天结束时持有股票剩余金额，dp[i] [1] 表示第i天结束时不持有股票剩余金额，递推公式由dp[i-1]推出。</p><h3 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h3><blockquote><p>不连续（子序列）：</p><p><a href="https://programmercarl.com/0300.%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.html">300.最长递增子序列</a></p><p><a href="https://programmercarl.com/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html">1143.最长公共子序列</a></p><p><a href="https://programmercarl.com/1035.%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF.html">1035.不相交的线</a></p><p>连续（子数组）：</p><p><a href="https://programmercarl.com/0674.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97.html">674.最长连续递增序列</a></p><p><a href="https://programmercarl.com/0718.%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84.html">718.最长重复子数组</a></p><p><a href="https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">53.最大子序和</a></p><p>编辑距离：</p><p><a href="https://programmercarl.com/0392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.html">392.判断子序列</a></p><p><a href="https://programmercarl.com/0115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.html">115.不同的子序列</a></p><p><a href="https://programmercarl.com/0583.%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.html">583.两个字符串的删除操作</a></p><p><a href="https://programmercarl.com/0072.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html">72.编辑距离</a></p><p>回文串：</p><p><a href="https://programmercarl.com/0647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html">647.回文子串</a></p><p><a href="https://programmercarl.com/0516.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.html">516.最长回文子序列</a></p></blockquote><p>对于dp数组定义，一般是dp[i]表示以s[i]结尾的字符串或者在s[i]之前的。。。递推公式则要分类讨论，循环顺序根据递推公式决定。</p><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p><strong>单调栈的应用场景</strong>：通常是一维数组，要寻找任一个元素的<strong>右边或者左边第一个比自己大或者小的元素的位置</strong>，此时我们就要想到可以用单调栈了。时间复杂度为O(n)。</p><p><strong>单调栈的原理</strong>：当寻找右边第一个比自己大的元素时，栈中元素<strong>从栈底到栈顶应该是从大到小</strong>，遍历时遇到比栈顶元素小的元素，直接入栈；遇到比栈顶元素大的元素，就需要将栈顶元素出栈，再入栈（类似于<strong>汉诺塔</strong>，小盘子只能垒在大盘子上方），此时栈顶元素就已经找到了右边第一个比自己大的元素，即当前遍历的元素。</p><p>使用单调栈主要有三个<strong>判断条件</strong>，可以视情况合并为两个（取决于寻找的是右边严格大于自己的元素，还是大于等于）：</p><ul><li>当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况</li><li>当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况</li><li>当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">stack&lt;<span class="hljs-type">int</span>&gt; st;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(temperatures.size(), <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">// 这里的初始值0取决于问题的需求，表示没有右边比自己大的元素时的结果</span><br>st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;temperatures.<span class="hljs-built_in">size</span>(); i++)&#123;<br>    <span class="hljs-keyword">if</span> (temperatures[i] &lt;= temperatures[st.<span class="hljs-built_in">top</span>()])&#123;  <span class="hljs-comment">// 当前遍历的元素T[i]小于等于栈顶元素T[st.top()]的情况，直接入栈</span><br>        st.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况，取出栈顶元素再入栈</span><br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; temperatures[i] &gt; temperatures[st.<span class="hljs-built_in">top</span>()])&#123;<br>            result[st.<span class="hljs-built_in">top</span>()] = i-st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        st.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> result;<br></code></pre></td></tr></table></figure><p>当寻找右边比自己小的元素、左边比自己大&#x2F;小的元素时，可以进行类比，单调栈的顺序会有不同。</p><blockquote><p>739.每日温度、496.下一个更大元素 I、503.下一个更大元素II、<strong>42. 接雨水、84.柱状图中最大的矩形</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>求职</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的Git学习笔记</title>
    <link href="/posts/3059.html"/>
    <url>/posts/3059.html</url>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><p>Git是目前世界上最先进的分布式版本控制系统，可以自动记录每次文件的改动，还可以让同事协作编辑。在2005年由Linus开发。相比集中式，分布式版本控制系统没有“中央服务器”，每个人的电脑上都是一个完整的版本库，不必联网；修改文件后只需把各自的修改推送给对方；还支持分支管理。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><strong>工作区（worktree）：</strong>电脑中本地代码实际存放的目录。</li><li><strong>暂存区（staged&#x2F;index）：</strong>暂时存放文件的修改的地方，一般存放在 <strong>.git</strong> 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）。</li><li><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库。包含了所有的分支与版本。</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2015/02/1352126739_7909.jpg" alt="工作区与版本库"></p><ul><li>图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage&#x2F;index），标记为 “master” 的是 master 分支所代表的目录树。</li><li>当对工作区修改（或新增）的文件执行 <code>git add</code> 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</li><li>当执行提交操作 <code>git commit</code> 命令时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</li><li>HEAD指针指向版本库中当前分支、当前所在的版本（或者说指向某一个分支名，如main；而分支名main也是个指针，指向某一个commit）。可以使用<code>git reset</code>改变HEAD指针指向的版本。HEAD^表示当前版本的父版本，HEAD^^表示上两个版本，以此类推。commit_id也可以用版本号的前几位表示。</li></ul><h2 id="创建版本库（仓库）"><a href="#创建版本库（仓库）" class="headerlink" title="创建版本库（仓库）"></a>创建版本库（仓库）</h2><p>进入某个目录后，执行<code>git init</code>命令。该目录下就会自动生成 .git文件夹，该目录变成一个Git管理的版本库。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li><p><code>git add &lt;file&gt;</code> ：添加文件修改到暂存区</p></li><li><p><code>git commit -m &#39;message&#39;</code> ：提交暂存区的文件修改到版本库的当前分支。git管理的是文件的修改，add与commit操作的对象都是文件的修改。</p></li><li><p><code>git status</code> ：查看工作区的状态，哪些修改未提交</p><h4 id="比较差异："><a href="#比较差异：" class="headerlink" title="比较差异："></a>比较差异：</h4></li><li><p><code>git diff &lt;file&gt;</code> ：查看工作区与暂存区文件的差异</p></li><li><p><code>git diff --staged &lt;file&gt;</code> ：查看暂存区与版本库当前版本文件的差异</p><h4 id="版本回退："><a href="#版本回退：" class="headerlink" title="版本回退："></a>版本回退：</h4></li><li><p><code>git log</code> ：显示当前分支的版本历史，一个commit就对应了一个版本，也是分支图中的一个节点。<code>git log --graph --oneline --all</code>画出所有分支的分支图。</p></li><li><p><code>git reset --hard &lt;commit_id | HEAD&gt;</code> ：暂存区与工作区的文件都回退到某个版本。HEAD指针指向当前所在的版本；如果使用commit_id，HEAD指针和分支名指针也会改变（即版本库的当前版本变了）。</p></li><li><p><code>git reset &lt;commit_id | HEAD&gt;</code> ：（省略了–mixed）版本库与暂存区的文件回退到某个版本，工作区文件不变保留修改，变为未暂存的状态。如果使用commit_id，HEAD指针和分支名指针也会改变。（如果工作区已经和版本库一致，但上次提交的commit有错误，想要修改又不想产生新的commit，可以用此命令回退版本库，但保留工作区修改，修改工作区后重新提交）</p></li><li><p><code>git reflog</code> ：查看命令历史</p><h4 id="撤销修改："><a href="#撤销修改：" class="headerlink" title="撤销修改："></a>撤销修改：</h4></li><li><p><code>git restore &lt;file&gt;</code> ：使用暂存区的文件内容恢复工作区的文件（即丢弃工作区的修改）</p></li><li><p><code>git restore --staged &lt;file&gt;</code> ：使用版本库当前版本（HEAD）的内容恢复暂存区的内容（即取消暂存，工作区保持不变）</p><img src="https://pub-68498345ab4b4950815fe9ca6cfa90be.r2.dev/picgo/20250105214320883.png" alt="撤销与提交操作" style="zoom:50%;" /></li><li><p><code>git rm &lt;file&gt;</code> ：删除一个文件，并将删除操作添加至暂存区</p><h4 id="连接远程仓库："><a href="#连接远程仓库：" class="headerlink" title="连接远程仓库："></a>连接远程仓库：</h4></li><li><p><code>git remote add origin git@github.com:AquariusLeo/gitlearning.git</code> ：连接GitHub上的远程仓库，origin是这个远程连接的引用的名字，可以随便改</p></li><li><p><code>git remote -v</code> ：查看连接的远程仓库信息</p></li><li><p><code>git remote show &lt;remote-name&gt;</code>：查看所有的远程连接，或查看指定的连接的信息。</p></li><li><p><code>git push [-u] origin main</code> ：把本地的main分支的修改推送到远程库origin中。-u：将本地的main分支关联到远程库的main分支，即追踪tracking&#x2F;upstream。之后推送修改就不需要加-u。</p></li><li><p><code>git pull</code> ：把远程仓库的最新commit抓取到本地的当前分支。抓取前需要建立与远程分支的追踪关系。</p></li><li><p><code>git branch --set-upstream-to=origin/&lt;branch-name&gt; &lt;local-branch-name&gt;</code>：将本地分支与远程分支建立追踪关系。追踪关系可以用<code>git remote show origin</code>查看。在pull或者push之前都要建立追踪关系，或者使用-u选项</p></li><li><p><code>git remote rm &lt;name&gt;</code> ：删除远程库连接</p></li><li><p><code>git clone &lt;url&gt;</code> ：从远程库克隆。url可以使用ssh协议的<a href="mailto:&#x67;&#105;&#116;&#64;&#103;&#x69;&#x74;&#104;&#x75;&#x62;&#46;&#99;&#111;&#x6d;">&#x67;&#105;&#116;&#64;&#103;&#x69;&#x74;&#104;&#x75;&#x62;&#46;&#99;&#111;&#x6d;</a>……  形式，也可以是http协议的<a href="https://github.com/%E2%80%A6%E2%80%A6">https://github.com/……</a>  形式</p><h4 id="分支管理："><a href="#分支管理：" class="headerlink" title="分支管理："></a>分支管理：</h4></li><li><p><code>git branch</code> ：列出所有的已存在分支</p></li><li><p><code>git branch &lt;branchname&gt;</code> ：创建一个新分支，指向当前HEAD的位置。–delete：删除分支，–move：移动&#x2F;重命名分支，–copy：复制分支</p></li><li><p><code>git switch &lt;branchname&gt;</code> ：切换分支。-c：创建后再切换。</p></li><li><p><code>git merge &lt;branchname&gt;</code> ：合并branchname分支到当前分支。当Git无法自动合并分支时，就必须首先解决冲突，把Git合并失败的文件手动编辑为我们希望的内容。解决冲突后，再add、commit，合并完成。–no-ff：禁用Fast forward模式，在merge时必定生成一个commit，这样可避免删除分支后，会丢掉分支信息。</p></li><li><p><code>git stash</code> ：保存当前工作现场（包括工作区未add的修改和暂存区未commit的修改），之后工作区会是干净的，可以放心地创建新分支。主要用于在开发过程中临时去别的分支修复bug。</p></li><li><p><code>git stash list</code> ：查看所有被保存的工作现场。</p></li><li><p><code>git stash pop</code> ：恢复上一个保存的stash，并把它删除。</p></li><li><p><code>git cherry-pick &lt;commit_id&gt;</code> ：复制某个commit的修改到当前分支。常用于复制bug修复。</p></li><li><p><code>git rebase</code> ：（变基）把本地未push的分叉提交历史整理成直线，使得在查看历史提交的变化时更容易</p><h4 id="多人协作的工作模式："><a href="#多人协作的工作模式：" class="headerlink" title="多人协作的工作模式："></a>多人协作的工作模式：</h4></li><li><p>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</p></li><li><p>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</p></li><li><p>如果pull合并有冲突，则解决冲突，并在本地add、commit提交；</p></li><li><p>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</p></li><li><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to=origin/&lt;branch-name&gt; &lt;local-branch-name&gt;</code>。</p><h4 id="标签管理："><a href="#标签管理：" class="headerlink" title="标签管理："></a>标签管理：</h4></li><li><p>标签是版本库的一个快照，唯一确定了打标签时刻的版本，其实就是指向某个commit的指针。使用标签是为了定义简明的版本号，而不是使用很长的commit_id。</p></li><li><p><code>git tag &lt;tagname&gt; [&lt;commit_id&gt;]</code> ：给某个commit打上标签。<code>git tag</code>会列出所有的标签，<code>git show &lt;tagname&gt;</code>查看标签信息。-d：删除标签。</p></li></ul><h2 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h2><ul><li>定义别名：<code>git config --global alias.st &#39;status&#39;</code></li><li>忽略特殊文件：在.gitignore文件中配置</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>版本管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/posts/3eeb.html"/>
    <url>/posts/3eeb.html</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
